{
  "components": {
    "schemas": {
      "io.k8s.api.admissionregistration.v1.AuditAnnotation": {
        "description": "AuditAnnotation describes how to produce an audit annotation for an API request.",
        "type": "object",
        "required": ["key", "valueExpression"],
        "properties": {
          "key": {
            "description": "key specifies the audit annotation key. The audit annotation keys of a ValidatingAdmissionPolicy must be unique. The key must be a qualified name ([A-Za-z0-9][-A-Za-z0-9_.]*) no more than 63 bytes in length.\n\nThe key is combined with the resource name of the ValidatingAdmissionPolicy to construct an audit annotation key: \"{ValidatingAdmissionPolicy name}/{key}\".\n\nIf an admission webhook uses the same resource name as this ValidatingAdmissionPolicy and the same audit annotation key, the annotation key will be identical. In this case, the first annotation written with the key will be included in the audit event and all subsequent annotations with the same key will be discarded.\n\nRequired.",
            "type": "string",
            "default": ""
          },
          "valueExpression": {
            "description": "valueExpression represents the expression which is evaluated by CEL to produce an audit annotation value. The expression must evaluate to either a string or null value. If the expression evaluates to a string, the audit annotation is included with the string value. If the expression evaluates to null or empty string the audit annotation will be omitted. The valueExpression may be no longer than 5kb in length. If the result of the valueExpression is more than 10kb in length, it will be truncated to 10kb.\n\nIf multiple ValidatingAdmissionPolicyBinding resources match an API request, then the valueExpression will be evaluated for each binding. All unique values produced by the valueExpressions will be joined together in a comma-separated list.\n\nRequired.",
            "type": "string",
            "default": ""
          }
        }
      },
      "io.k8s.api.admissionregistration.v1.ExpressionWarning": {
        "description": "ExpressionWarning is a warning information that targets a specific expression.",
        "type": "object",
        "required": ["fieldRef", "warning"],
        "properties": {
          "fieldRef": {
            "description": "The path to the field that refers the expression. For example, the reference to the expression of the first item of validations is \"spec.validations[0].expression\"",
            "type": "string",
            "default": ""
          },
          "warning": {
            "description": "The content of type checking information in a human-readable form. Each line of the warning contains the type that the expression is checked against, followed by the type check error from the compiler.",
            "type": "string",
            "default": ""
          }
        }
      },
      "io.k8s.api.admissionregistration.v1.MatchCondition": {
        "description": "MatchCondition represents a condition which must by fulfilled for a request to be sent to a webhook.",
        "type": "object",
        "required": ["name", "expression"],
        "properties": {
          "expression": {
            "description": "Expression represents the expression which will be evaluated by CEL. Must evaluate to bool. CEL expressions have access to the contents of the AdmissionRequest and Authorizer, organized into CEL variables:\n\n'object' - The object from the incoming request. The value is null for DELETE requests. 'oldObject' - The existing object. The value is null for CREATE requests. 'request' - Attributes of the admission request(/pkg/apis/admission/types.go#AdmissionRequest). 'authorizer' - A CEL Authorizer. May be used to perform authorization checks for the principal (user or service account) of the request.\n  See https://pkg.go.dev/k8s.io/apiserver/pkg/cel/library#Authz\n'authorizer.requestResource' - A CEL ResourceCheck constructed from the 'authorizer' and configured with the\n  request resource.\nDocumentation on CEL: https://kubernetes.io/docs/reference/using-api/cel/\n\nRequired.",
            "type": "string",
            "default": ""
          },
          "name": {
            "description": "Name is an identifier for this match condition, used for strategic merging of MatchConditions, as well as providing an identifier for logging purposes. A good name should be descriptive of the associated expression. Name must be a qualified name consisting of alphanumeric characters, '-', '_' or '.', and must start and end with an alphanumeric character (e.g. 'MyName',  or 'my.name',  or '123-abc', regex used for validation is '([A-Za-z0-9][-A-Za-z0-9_.]*)?[A-Za-z0-9]') with an optional DNS subdomain prefix and '/' (e.g. 'example.com/MyName')\n\nRequired.",
            "type": "string",
            "default": ""
          }
        }
      },
      "io.k8s.api.admissionregistration.v1.MatchResources": {
        "description": "MatchResources decides whether to run the admission control policy on an object based on whether it meets the match criteria. The exclude rules take precedence over include rules (if a resource matches both, it is excluded)",
        "type": "object",
        "properties": {
          "excludeResourceRules": {
            "description": "ExcludeResourceRules describes what operations on what resources/subresources the ValidatingAdmissionPolicy should not care about. The exclude rules take precedence over include rules (if a resource matches both, it is excluded)",
            "type": "array",
            "items": {
              "default": {},
              "allOf": [
                {
                  "$ref": "#/components/schemas/io.k8s.api.admissionregistration.v1.NamedRuleWithOperations"
                }
              ]
            },
            "x-kubernetes-list-type": "atomic"
          },
          "matchPolicy": {
            "description": "matchPolicy defines how the \"MatchResources\" list is used to match incoming requests. Allowed values are \"Exact\" or \"Equivalent\".\n\n- Exact: match a request only if it exactly matches a specified rule. For example, if deployments can be modified via apps/v1, apps/v1beta1, and extensions/v1beta1, but \"rules\" only included `apiGroups:[\"apps\"], apiVersions:[\"v1\"], resources: [\"deployments\"]`, a request to apps/v1beta1 or extensions/v1beta1 would not be sent to the ValidatingAdmissionPolicy.\n\n- Equivalent: match a request if modifies a resource listed in rules, even via another API group or version. For example, if deployments can be modified via apps/v1, apps/v1beta1, and extensions/v1beta1, and \"rules\" only included `apiGroups:[\"apps\"], apiVersions:[\"v1\"], resources: [\"deployments\"]`, a request to apps/v1beta1 or extensions/v1beta1 would be converted to apps/v1 and sent to the ValidatingAdmissionPolicy.\n\nDefaults to \"Equivalent\"\n\nPossible enum values:\n - `\"Equivalent\"` means requests should be sent to the webhook if they modify a resource listed in rules via another API group or version.\n - `\"Exact\"` means requests should only be sent to the webhook if they exactly match a given rule.",
            "type": "string",
            "enum": ["Equivalent", "Exact"]
          },
          "namespaceSelector": {
            "description": "NamespaceSelector decides whether to run the admission control policy on an object based on whether the namespace for that object matches the selector. If the object itself is a namespace, the matching is performed on object.metadata.labels. If the object is another cluster scoped resource, it never skips the policy.\n\nFor example, to run the webhook on any objects whose namespace is not associated with \"runlevel\" of \"0\" or \"1\";  you will set the selector as follows: \"namespaceSelector\": {\n  \"matchExpressions\": [\n    {\n      \"key\": \"runlevel\",\n      \"operator\": \"NotIn\",\n      \"values\": [\n        \"0\",\n        \"1\"\n      ]\n    }\n  ]\n}\n\nIf instead you want to only run the policy on any objects whose namespace is associated with the \"environment\" of \"prod\" or \"staging\"; you will set the selector as follows: \"namespaceSelector\": {\n  \"matchExpressions\": [\n    {\n      \"key\": \"environment\",\n      \"operator\": \"In\",\n      \"values\": [\n        \"prod\",\n        \"staging\"\n      ]\n    }\n  ]\n}\n\nSee https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/ for more examples of label selectors.\n\nDefault to the empty LabelSelector, which matches everything.",
            "allOf": [
              {
                "$ref": "#/components/schemas/io.k8s.apimachinery.pkg.apis.meta.v1.LabelSelector"
              }
            ]
          },
          "objectSelector": {
            "description": "ObjectSelector decides whether to run the validation based on if the object has matching labels. objectSelector is evaluated against both the oldObject and newObject that would be sent to the cel validation, and is considered to match if either object matches the selector. A null object (oldObject in the case of create, or newObject in the case of delete) or an object that cannot have labels (like a DeploymentRollback or a PodProxyOptions object) is not considered to match. Use the object selector only if the webhook is opt-in, because end users may skip the admission webhook by setting the labels. Default to the empty LabelSelector, which matches everything.",
            "allOf": [
              {
                "$ref": "#/components/schemas/io.k8s.apimachinery.pkg.apis.meta.v1.LabelSelector"
              }
            ]
          },
          "resourceRules": {
            "description": "ResourceRules describes what operations on what resources/subresources the ValidatingAdmissionPolicy matches. The policy cares about an operation if it matches _any_ Rule.",
            "type": "array",
            "items": {
              "default": {},
              "allOf": [
                {
                  "$ref": "#/components/schemas/io.k8s.api.admissionregistration.v1.NamedRuleWithOperations"
                }
              ]
            },
            "x-kubernetes-list-type": "atomic"
          }
        },
        "x-kubernetes-map-type": "atomic"
      },
      "io.k8s.api.admissionregistration.v1.MutatingWebhook": {
        "description": "MutatingWebhook describes an admission webhook and the resources and operations it applies to.",
        "type": "object",
        "required": [
          "name",
          "clientConfig",
          "sideEffects",
          "admissionReviewVersions"
        ],
        "properties": {
          "admissionReviewVersions": {
            "description": "AdmissionReviewVersions is an ordered list of preferred `AdmissionReview` versions the Webhook expects. API server will try to use first version in the list which it supports. If none of the versions specified in this list supported by API server, validation will fail for this object. If a persisted webhook configuration specifies allowed versions and does not include any versions known to the API Server, calls to the webhook will fail and be subject to the failure policy.",
            "type": "array",
            "items": { "type": "string", "default": "" },
            "x-kubernetes-list-type": "atomic"
          },
          "clientConfig": {
            "description": "ClientConfig defines how to communicate with the hook. Required",
            "default": {},
            "allOf": [
              {
                "$ref": "#/components/schemas/io.k8s.api.admissionregistration.v1.WebhookClientConfig"
              }
            ]
          },
          "failurePolicy": {
            "description": "FailurePolicy defines how unrecognized errors from the admission endpoint are handled - allowed values are Ignore or Fail. Defaults to Fail.\n\nPossible enum values:\n - `\"Fail\"` means that an error calling the webhook causes the admission to fail.\n - `\"Ignore\"` means that an error calling the webhook is ignored.",
            "type": "string",
            "enum": ["Fail", "Ignore"]
          },
          "matchConditions": {
            "description": "MatchConditions is a list of conditions that must be met for a request to be sent to this webhook. Match conditions filter requests that have already been matched by the rules, namespaceSelector, and objectSelector. An empty list of matchConditions matches all requests. There are a maximum of 64 match conditions allowed.\n\nThe exact matching logic is (in order):\n  1. If ANY matchCondition evaluates to FALSE, the webhook is skipped.\n  2. If ALL matchConditions evaluate to TRUE, the webhook is called.\n  3. If any matchCondition evaluates to an error (but none are FALSE):\n     - If failurePolicy=Fail, reject the request\n     - If failurePolicy=Ignore, the error is ignored and the webhook is skipped",
            "type": "array",
            "items": {
              "default": {},
              "allOf": [
                {
                  "$ref": "#/components/schemas/io.k8s.api.admissionregistration.v1.MatchCondition"
                }
              ]
            },
            "x-kubernetes-list-map-keys": ["name"],
            "x-kubernetes-list-type": "map",
            "x-kubernetes-patch-merge-key": "name",
            "x-kubernetes-patch-strategy": "merge"
          },
          "matchPolicy": {
            "description": "matchPolicy defines how the \"rules\" list is used to match incoming requests. Allowed values are \"Exact\" or \"Equivalent\".\n\n- Exact: match a request only if it exactly matches a specified rule. For example, if deployments can be modified via apps/v1, apps/v1beta1, and extensions/v1beta1, but \"rules\" only included `apiGroups:[\"apps\"], apiVersions:[\"v1\"], resources: [\"deployments\"]`, a request to apps/v1beta1 or extensions/v1beta1 would not be sent to the webhook.\n\n- Equivalent: match a request if modifies a resource listed in rules, even via another API group or version. For example, if deployments can be modified via apps/v1, apps/v1beta1, and extensions/v1beta1, and \"rules\" only included `apiGroups:[\"apps\"], apiVersions:[\"v1\"], resources: [\"deployments\"]`, a request to apps/v1beta1 or extensions/v1beta1 would be converted to apps/v1 and sent to the webhook.\n\nDefaults to \"Equivalent\"\n\nPossible enum values:\n - `\"Equivalent\"` means requests should be sent to the webhook if they modify a resource listed in rules via another API group or version.\n - `\"Exact\"` means requests should only be sent to the webhook if they exactly match a given rule.",
            "type": "string",
            "enum": ["Equivalent", "Exact"]
          },
          "name": {
            "description": "The name of the admission webhook. Name should be fully qualified, e.g., imagepolicy.kubernetes.io, where \"imagepolicy\" is the name of the webhook, and kubernetes.io is the name of the organization. Required.",
            "type": "string",
            "default": ""
          },
          "namespaceSelector": {
            "description": "NamespaceSelector decides whether to run the webhook on an object based on whether the namespace for that object matches the selector. If the object itself is a namespace, the matching is performed on object.metadata.labels. If the object is another cluster scoped resource, it never skips the webhook.\n\nFor example, to run the webhook on any objects whose namespace is not associated with \"runlevel\" of \"0\" or \"1\";  you will set the selector as follows: \"namespaceSelector\": {\n  \"matchExpressions\": [\n    {\n      \"key\": \"runlevel\",\n      \"operator\": \"NotIn\",\n      \"values\": [\n        \"0\",\n        \"1\"\n      ]\n    }\n  ]\n}\n\nIf instead you want to only run the webhook on any objects whose namespace is associated with the \"environment\" of \"prod\" or \"staging\"; you will set the selector as follows: \"namespaceSelector\": {\n  \"matchExpressions\": [\n    {\n      \"key\": \"environment\",\n      \"operator\": \"In\",\n      \"values\": [\n        \"prod\",\n        \"staging\"\n      ]\n    }\n  ]\n}\n\nSee https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/ for more examples of label selectors.\n\nDefault to the empty LabelSelector, which matches everything.",
            "allOf": [
              {
                "$ref": "#/components/schemas/io.k8s.apimachinery.pkg.apis.meta.v1.LabelSelector"
              }
            ]
          },
          "objectSelector": {
            "description": "ObjectSelector decides whether to run the webhook based on if the object has matching labels. objectSelector is evaluated against both the oldObject and newObject that would be sent to the webhook, and is considered to match if either object matches the selector. A null object (oldObject in the case of create, or newObject in the case of delete) or an object that cannot have labels (like a DeploymentRollback or a PodProxyOptions object) is not considered to match. Use the object selector only if the webhook is opt-in, because end users may skip the admission webhook by setting the labels. Default to the empty LabelSelector, which matches everything.",
            "allOf": [
              {
                "$ref": "#/components/schemas/io.k8s.apimachinery.pkg.apis.meta.v1.LabelSelector"
              }
            ]
          },
          "reinvocationPolicy": {
            "description": "reinvocationPolicy indicates whether this webhook should be called multiple times as part of a single admission evaluation. Allowed values are \"Never\" and \"IfNeeded\".\n\nNever: the webhook will not be called more than once in a single admission evaluation.\n\nIfNeeded: the webhook will be called at least one additional time as part of the admission evaluation if the object being admitted is modified by other admission plugins after the initial webhook call. Webhooks that specify this option *must* be idempotent, able to process objects they previously admitted. Note: * the number of additional invocations is not guaranteed to be exactly one. * if additional invocations result in further modifications to the object, webhooks are not guaranteed to be invoked again. * webhooks that use this option may be reordered to minimize the number of additional invocations. * to validate an object after all mutations are guaranteed complete, use a validating admission webhook instead.\n\nDefaults to \"Never\".\n\nPossible enum values:\n - `\"IfNeeded\"` indicates that the webhook may be called at least one additional time as part of the admission evaluation if the object being admitted is modified by other admission plugins after the initial webhook call.\n - `\"Never\"` indicates that the webhook must not be called more than once in a single admission evaluation.",
            "type": "string",
            "enum": ["IfNeeded", "Never"]
          },
          "rules": {
            "description": "Rules describes what operations on what resources/subresources the webhook cares about. The webhook cares about an operation if it matches _any_ Rule. However, in order to prevent ValidatingAdmissionWebhooks and MutatingAdmissionWebhooks from putting the cluster in a state which cannot be recovered from without completely disabling the plugin, ValidatingAdmissionWebhooks and MutatingAdmissionWebhooks are never called on admission requests for ValidatingWebhookConfiguration and MutatingWebhookConfiguration objects.",
            "type": "array",
            "items": {
              "default": {},
              "allOf": [
                {
                  "$ref": "#/components/schemas/io.k8s.api.admissionregistration.v1.RuleWithOperations"
                }
              ]
            },
            "x-kubernetes-list-type": "atomic"
          },
          "sideEffects": {
            "description": "SideEffects states whether this webhook has side effects. Acceptable values are: None, NoneOnDryRun (webhooks created via v1beta1 may also specify Some or Unknown). Webhooks with side effects MUST implement a reconciliation system, since a request may be rejected by a future step in the admission chain and the side effects therefore need to be undone. Requests with the dryRun attribute will be auto-rejected if they match a webhook with sideEffects == Unknown or Some.\n\nPossible enum values:\n - `\"None\"` means that calling the webhook will have no side effects.\n - `\"NoneOnDryRun\"` means that calling the webhook will possibly have side effects, but if the request being reviewed has the dry-run attribute, the side effects will be suppressed.\n - `\"Some\"` means that calling the webhook will possibly have side effects. If a request with the dry-run attribute would trigger a call to this webhook, the request will instead fail.\n - `\"Unknown\"` means that no information is known about the side effects of calling the webhook. If a request with the dry-run attribute would trigger a call to this webhook, the request will instead fail.",
            "type": "string",
            "enum": ["None", "NoneOnDryRun", "Some", "Unknown"]
          },
          "timeoutSeconds": {
            "description": "TimeoutSeconds specifies the timeout for this webhook. After the timeout passes, the webhook call will be ignored or the API call will fail based on the failure policy. The timeout value must be between 1 and 30 seconds. Default to 10 seconds.",
            "type": "integer",
            "format": "int32"
          }
        }
      },
      "io.k8s.api.admissionregistration.v1.MutatingWebhookConfiguration": {
        "description": "MutatingWebhookConfiguration describes the configuration of and admission webhook that accept or reject and may change the object.",
        "type": "object",
        "properties": {
          "apiVersion": {
            "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
            "type": "string"
          },
          "kind": {
            "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
            "type": "string"
          },
          "metadata": {
            "description": "Standard object metadata; More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata.",
            "default": {},
            "allOf": [
              {
                "$ref": "#/components/schemas/io.k8s.apimachinery.pkg.apis.meta.v1.ObjectMeta"
              }
            ]
          },
          "webhooks": {
            "description": "Webhooks is a list of webhooks and the affected resources and operations.",
            "type": "array",
            "items": {
              "default": {},
              "allOf": [
                {
                  "$ref": "#/components/schemas/io.k8s.api.admissionregistration.v1.MutatingWebhook"
                }
              ]
            },
            "x-kubernetes-list-map-keys": ["name"],
            "x-kubernetes-list-type": "map",
            "x-kubernetes-patch-merge-key": "name",
            "x-kubernetes-patch-strategy": "merge"
          }
        },
        "x-kubernetes-group-version-kind": [
          {
            "group": "admissionregistration.k8s.io",
            "kind": "MutatingWebhookConfiguration",
            "version": "v1"
          }
        ]
      },
      "io.k8s.api.admissionregistration.v1.MutatingWebhookConfigurationList": {
        "description": "MutatingWebhookConfigurationList is a list of MutatingWebhookConfiguration.",
        "type": "object",
        "required": ["items"],
        "properties": {
          "apiVersion": {
            "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
            "type": "string"
          },
          "items": {
            "description": "List of MutatingWebhookConfiguration.",
            "type": "array",
            "items": {
              "default": {},
              "allOf": [
                {
                  "$ref": "#/components/schemas/io.k8s.api.admissionregistration.v1.MutatingWebhookConfiguration"
                }
              ]
            }
          },
          "kind": {
            "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
            "type": "string"
          },
          "metadata": {
            "description": "Standard list metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
            "default": {},
            "allOf": [
              {
                "$ref": "#/components/schemas/io.k8s.apimachinery.pkg.apis.meta.v1.ListMeta"
              }
            ]
          }
        },
        "x-kubernetes-group-version-kind": [
          {
            "group": "admissionregistration.k8s.io",
            "kind": "MutatingWebhookConfigurationList",
            "version": "v1"
          }
        ]
      },
      "io.k8s.api.admissionregistration.v1.NamedRuleWithOperations": {
        "description": "NamedRuleWithOperations is a tuple of Operations and Resources with ResourceNames.",
        "type": "object",
        "properties": {
          "apiGroups": {
            "description": "APIGroups is the API groups the resources belong to. '*' is all groups. If '*' is present, the length of the slice must be one. Required.",
            "type": "array",
            "items": { "type": "string", "default": "" },
            "x-kubernetes-list-type": "atomic"
          },
          "apiVersions": {
            "description": "APIVersions is the API versions the resources belong to. '*' is all versions. If '*' is present, the length of the slice must be one. Required.",
            "type": "array",
            "items": { "type": "string", "default": "" },
            "x-kubernetes-list-type": "atomic"
          },
          "operations": {
            "description": "Operations is the operations the admission hook cares about - CREATE, UPDATE, DELETE, CONNECT or * for all of those operations and any future admission operations that are added. If '*' is present, the length of the slice must be one. Required.",
            "type": "array",
            "items": {
              "type": "string",
              "default": "",
              "enum": ["*", "CONNECT", "CREATE", "DELETE", "UPDATE"]
            },
            "x-kubernetes-list-type": "atomic"
          },
          "resourceNames": {
            "description": "ResourceNames is an optional white list of names that the rule applies to.  An empty set means that everything is allowed.",
            "type": "array",
            "items": { "type": "string", "default": "" },
            "x-kubernetes-list-type": "atomic"
          },
          "resources": {
            "description": "Resources is a list of resources this rule applies to.\n\nFor example: 'pods' means pods. 'pods/log' means the log subresource of pods. '*' means all resources, but not subresources. 'pods/*' means all subresources of pods. '*/scale' means all scale subresources. '*/*' means all resources and their subresources.\n\nIf wildcard is present, the validation rule will ensure resources do not overlap with each other.\n\nDepending on the enclosing object, subresources might not be allowed. Required.",
            "type": "array",
            "items": { "type": "string", "default": "" },
            "x-kubernetes-list-type": "atomic"
          },
          "scope": {
            "description": "scope specifies the scope of this rule. Valid values are \"Cluster\", \"Namespaced\", and \"*\" \"Cluster\" means that only cluster-scoped resources will match this rule. Namespace API objects are cluster-scoped. \"Namespaced\" means that only namespaced resources will match this rule. \"*\" means that there are no scope restrictions. Subresources match the scope of their parent resource. Default is \"*\".",
            "type": "string"
          }
        },
        "x-kubernetes-map-type": "atomic"
      },
      "io.k8s.api.admissionregistration.v1.ParamKind": {
        "description": "ParamKind is a tuple of Group Kind and Version.",
        "type": "object",
        "properties": {
          "apiVersion": {
            "description": "APIVersion is the API group version the resources belong to. In format of \"group/version\". Required.",
            "type": "string"
          },
          "kind": {
            "description": "Kind is the API kind the resources belong to. Required.",
            "type": "string"
          }
        },
        "x-kubernetes-map-type": "atomic"
      },
      "io.k8s.api.admissionregistration.v1.ParamRef": {
        "description": "ParamRef describes how to locate the params to be used as input to expressions of rules applied by a policy binding.",
        "type": "object",
        "properties": {
          "name": {
            "description": "name is the name of the resource being referenced.\n\nOne of `name` or `selector` must be set, but `name` and `selector` are mutually exclusive properties. If one is set, the other must be unset.\n\nA single parameter used for all admission requests can be configured by setting the `name` field, leaving `selector` blank, and setting namespace if `paramKind` is namespace-scoped.",
            "type": "string"
          },
          "namespace": {
            "description": "namespace is the namespace of the referenced resource. Allows limiting the search for params to a specific namespace. Applies to both `name` and `selector` fields.\n\nA per-namespace parameter may be used by specifying a namespace-scoped `paramKind` in the policy and leaving this field empty.\n\n- If `paramKind` is cluster-scoped, this field MUST be unset. Setting this field results in a configuration error.\n\n- If `paramKind` is namespace-scoped, the namespace of the object being evaluated for admission will be used when this field is left unset. Take care that if this is left empty the binding must not match any cluster-scoped resources, which will result in an error.",
            "type": "string"
          },
          "parameterNotFoundAction": {
            "description": "`parameterNotFoundAction` controls the behavior of the binding when the resource exists, and name or selector is valid, but there are no parameters matched by the binding. If the value is set to `Allow`, then no matched parameters will be treated as successful validation by the binding. If set to `Deny`, then no matched parameters will be subject to the `failurePolicy` of the policy.\n\nAllowed values are `Allow` or `Deny`\n\nRequired",
            "type": "string"
          },
          "selector": {
            "description": "selector can be used to match multiple param objects based on their labels. Supply selector: {} to match all resources of the ParamKind.\n\nIf multiple params are found, they are all evaluated with the policy expressions and the results are ANDed together.\n\nOne of `name` or `selector` must be set, but `name` and `selector` are mutually exclusive properties. If one is set, the other must be unset.",
            "allOf": [
              {
                "$ref": "#/components/schemas/io.k8s.apimachinery.pkg.apis.meta.v1.LabelSelector"
              }
            ]
          }
        },
        "x-kubernetes-map-type": "atomic"
      },
      "io.k8s.api.admissionregistration.v1.RuleWithOperations": {
        "description": "RuleWithOperations is a tuple of Operations and Resources. It is recommended to make sure that all the tuple expansions are valid.",
        "type": "object",
        "properties": {
          "apiGroups": {
            "description": "APIGroups is the API groups the resources belong to. '*' is all groups. If '*' is present, the length of the slice must be one. Required.",
            "type": "array",
            "items": { "type": "string", "default": "" },
            "x-kubernetes-list-type": "atomic"
          },
          "apiVersions": {
            "description": "APIVersions is the API versions the resources belong to. '*' is all versions. If '*' is present, the length of the slice must be one. Required.",
            "type": "array",
            "items": { "type": "string", "default": "" },
            "x-kubernetes-list-type": "atomic"
          },
          "operations": {
            "description": "Operations is the operations the admission hook cares about - CREATE, UPDATE, DELETE, CONNECT or * for all of those operations and any future admission operations that are added. If '*' is present, the length of the slice must be one. Required.",
            "type": "array",
            "items": {
              "type": "string",
              "default": "",
              "enum": ["*", "CONNECT", "CREATE", "DELETE", "UPDATE"]
            },
            "x-kubernetes-list-type": "atomic"
          },
          "resources": {
            "description": "Resources is a list of resources this rule applies to.\n\nFor example: 'pods' means pods. 'pods/log' means the log subresource of pods. '*' means all resources, but not subresources. 'pods/*' means all subresources of pods. '*/scale' means all scale subresources. '*/*' means all resources and their subresources.\n\nIf wildcard is present, the validation rule will ensure resources do not overlap with each other.\n\nDepending on the enclosing object, subresources might not be allowed. Required.",
            "type": "array",
            "items": { "type": "string", "default": "" },
            "x-kubernetes-list-type": "atomic"
          },
          "scope": {
            "description": "scope specifies the scope of this rule. Valid values are \"Cluster\", \"Namespaced\", and \"*\" \"Cluster\" means that only cluster-scoped resources will match this rule. Namespace API objects are cluster-scoped. \"Namespaced\" means that only namespaced resources will match this rule. \"*\" means that there are no scope restrictions. Subresources match the scope of their parent resource. Default is \"*\".",
            "type": "string"
          }
        }
      },
      "io.k8s.api.admissionregistration.v1.ServiceReference": {
        "description": "ServiceReference holds a reference to Service.legacy.k8s.io",
        "type": "object",
        "required": ["namespace", "name"],
        "properties": {
          "name": {
            "description": "`name` is the name of the service. Required",
            "type": "string",
            "default": ""
          },
          "namespace": {
            "description": "`namespace` is the namespace of the service. Required",
            "type": "string",
            "default": ""
          },
          "path": {
            "description": "`path` is an optional URL path which will be sent in any request to this service.",
            "type": "string"
          },
          "port": {
            "description": "If specified, the port on the service that hosting webhook. Default to 443 for backward compatibility. `port` should be a valid port number (1-65535, inclusive).",
            "type": "integer",
            "format": "int32"
          }
        }
      },
      "io.k8s.api.admissionregistration.v1.TypeChecking": {
        "description": "TypeChecking contains results of type checking the expressions in the ValidatingAdmissionPolicy",
        "type": "object",
        "properties": {
          "expressionWarnings": {
            "description": "The type checking warnings for each expression.",
            "type": "array",
            "items": {
              "default": {},
              "allOf": [
                {
                  "$ref": "#/components/schemas/io.k8s.api.admissionregistration.v1.ExpressionWarning"
                }
              ]
            },
            "x-kubernetes-list-type": "atomic"
          }
        }
      },
      "io.k8s.api.admissionregistration.v1.ValidatingAdmissionPolicy": {
        "description": "ValidatingAdmissionPolicy describes the definition of an admission validation policy that accepts or rejects an object without changing it.",
        "type": "object",
        "properties": {
          "apiVersion": {
            "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
            "type": "string"
          },
          "kind": {
            "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
            "type": "string"
          },
          "metadata": {
            "description": "Standard object metadata; More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata.",
            "default": {},
            "allOf": [
              {
                "$ref": "#/components/schemas/io.k8s.apimachinery.pkg.apis.meta.v1.ObjectMeta"
              }
            ]
          },
          "spec": {
            "description": "Specification of the desired behavior of the ValidatingAdmissionPolicy.",
            "default": {},
            "allOf": [
              {
                "$ref": "#/components/schemas/io.k8s.api.admissionregistration.v1.ValidatingAdmissionPolicySpec"
              }
            ]
          },
          "status": {
            "description": "The status of the ValidatingAdmissionPolicy, including warnings that are useful to determine if the policy behaves in the expected way. Populated by the system. Read-only.",
            "default": {},
            "allOf": [
              {
                "$ref": "#/components/schemas/io.k8s.api.admissionregistration.v1.ValidatingAdmissionPolicyStatus"
              }
            ]
          }
        },
        "x-kubernetes-group-version-kind": [
          {
            "group": "admissionregistration.k8s.io",
            "kind": "ValidatingAdmissionPolicy",
            "version": "v1"
          }
        ]
      },
      "io.k8s.api.admissionregistration.v1.ValidatingAdmissionPolicyBinding": {
        "description": "ValidatingAdmissionPolicyBinding binds the ValidatingAdmissionPolicy with paramerized resources. ValidatingAdmissionPolicyBinding and parameter CRDs together define how cluster administrators configure policies for clusters.\n\nFor a given admission request, each binding will cause its policy to be evaluated N times, where N is 1 for policies/bindings that don't use params, otherwise N is the number of parameters selected by the binding.\n\nThe CEL expressions of a policy must have a computed CEL cost below the maximum CEL budget. Each evaluation of the policy is given an independent CEL cost budget. Adding/removing policies, bindings, or params can not affect whether a given (policy, binding, param) combination is within its own CEL budget.",
        "type": "object",
        "properties": {
          "apiVersion": {
            "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
            "type": "string"
          },
          "kind": {
            "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
            "type": "string"
          },
          "metadata": {
            "description": "Standard object metadata; More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata.",
            "default": {},
            "allOf": [
              {
                "$ref": "#/components/schemas/io.k8s.apimachinery.pkg.apis.meta.v1.ObjectMeta"
              }
            ]
          },
          "spec": {
            "description": "Specification of the desired behavior of the ValidatingAdmissionPolicyBinding.",
            "default": {},
            "allOf": [
              {
                "$ref": "#/components/schemas/io.k8s.api.admissionregistration.v1.ValidatingAdmissionPolicyBindingSpec"
              }
            ]
          }
        },
        "x-kubernetes-group-version-kind": [
          {
            "group": "admissionregistration.k8s.io",
            "kind": "ValidatingAdmissionPolicyBinding",
            "version": "v1"
          }
        ]
      },
      "io.k8s.api.admissionregistration.v1.ValidatingAdmissionPolicyBindingList": {
        "description": "ValidatingAdmissionPolicyBindingList is a list of ValidatingAdmissionPolicyBinding.",
        "type": "object",
        "required": ["items"],
        "properties": {
          "apiVersion": {
            "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
            "type": "string"
          },
          "items": {
            "description": "List of PolicyBinding.",
            "type": "array",
            "items": {
              "default": {},
              "allOf": [
                {
                  "$ref": "#/components/schemas/io.k8s.api.admissionregistration.v1.ValidatingAdmissionPolicyBinding"
                }
              ]
            }
          },
          "kind": {
            "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
            "type": "string"
          },
          "metadata": {
            "description": "Standard list metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
            "default": {},
            "allOf": [
              {
                "$ref": "#/components/schemas/io.k8s.apimachinery.pkg.apis.meta.v1.ListMeta"
              }
            ]
          }
        },
        "x-kubernetes-group-version-kind": [
          {
            "group": "admissionregistration.k8s.io",
            "kind": "ValidatingAdmissionPolicyBindingList",
            "version": "v1"
          }
        ]
      },
      "io.k8s.api.admissionregistration.v1.ValidatingAdmissionPolicyBindingSpec": {
        "description": "ValidatingAdmissionPolicyBindingSpec is the specification of the ValidatingAdmissionPolicyBinding.",
        "type": "object",
        "properties": {
          "matchResources": {
            "description": "MatchResources declares what resources match this binding and will be validated by it. Note that this is intersected with the policy's matchConstraints, so only requests that are matched by the policy can be selected by this. If this is unset, all resources matched by the policy are validated by this binding When resourceRules is unset, it does not constrain resource matching. If a resource is matched by the other fields of this object, it will be validated. Note that this is differs from ValidatingAdmissionPolicy matchConstraints, where resourceRules are required.",
            "allOf": [
              {
                "$ref": "#/components/schemas/io.k8s.api.admissionregistration.v1.MatchResources"
              }
            ]
          },
          "paramRef": {
            "description": "paramRef specifies the parameter resource used to configure the admission control policy. It should point to a resource of the type specified in ParamKind of the bound ValidatingAdmissionPolicy. If the policy specifies a ParamKind and the resource referred to by ParamRef does not exist, this binding is considered mis-configured and the FailurePolicy of the ValidatingAdmissionPolicy applied. If the policy does not specify a ParamKind then this field is ignored, and the rules are evaluated without a param.",
            "allOf": [
              {
                "$ref": "#/components/schemas/io.k8s.api.admissionregistration.v1.ParamRef"
              }
            ]
          },
          "policyName": {
            "description": "PolicyName references a ValidatingAdmissionPolicy name which the ValidatingAdmissionPolicyBinding binds to. If the referenced resource does not exist, this binding is considered invalid and will be ignored Required.",
            "type": "string"
          },
          "validationActions": {
            "description": "validationActions declares how Validations of the referenced ValidatingAdmissionPolicy are enforced. If a validation evaluates to false it is always enforced according to these actions.\n\nFailures defined by the ValidatingAdmissionPolicy's FailurePolicy are enforced according to these actions only if the FailurePolicy is set to Fail, otherwise the failures are ignored. This includes compilation errors, runtime errors and misconfigurations of the policy.\n\nvalidationActions is declared as a set of action values. Order does not matter. validationActions may not contain duplicates of the same action.\n\nThe supported actions values are:\n\n\"Deny\" specifies that a validation failure results in a denied request.\n\n\"Warn\" specifies that a validation failure is reported to the request client in HTTP Warning headers, with a warning code of 299. Warnings can be sent both for allowed or denied admission responses.\n\n\"Audit\" specifies that a validation failure is included in the published audit event for the request. The audit event will contain a `validation.policy.admission.k8s.io/validation_failure` audit annotation with a value containing the details of the validation failures, formatted as a JSON list of objects, each with the following fields: - message: The validation failure message string - policy: The resource name of the ValidatingAdmissionPolicy - binding: The resource name of the ValidatingAdmissionPolicyBinding - expressionIndex: The index of the failed validations in the ValidatingAdmissionPolicy - validationActions: The enforcement actions enacted for the validation failure Example audit annotation: `\"validation.policy.admission.k8s.io/validation_failure\": \"[{\"message\": \"Invalid value\", {\"policy\": \"policy.example.com\", {\"binding\": \"policybinding.example.com\", {\"expressionIndex\": \"1\", {\"validationActions\": [\"Audit\"]}]\"`\n\nClients should expect to handle additional values by ignoring any values not recognized.\n\n\"Deny\" and \"Warn\" may not be used together since this combination needlessly duplicates the validation failure both in the API response body and the HTTP warning headers.\n\nRequired.",
            "type": "array",
            "items": {
              "type": "string",
              "default": "",
              "enum": ["Audit", "Deny", "Warn"]
            },
            "x-kubernetes-list-type": "set"
          }
        }
      },
      "io.k8s.api.admissionregistration.v1.ValidatingAdmissionPolicyList": {
        "description": "ValidatingAdmissionPolicyList is a list of ValidatingAdmissionPolicy.",
        "type": "object",
        "required": ["items"],
        "properties": {
          "apiVersion": {
            "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
            "type": "string"
          },
          "items": {
            "description": "List of ValidatingAdmissionPolicy.",
            "type": "array",
            "items": {
              "default": {},
              "allOf": [
                {
                  "$ref": "#/components/schemas/io.k8s.api.admissionregistration.v1.ValidatingAdmissionPolicy"
                }
              ]
            }
          },
          "kind": {
            "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
            "type": "string"
          },
          "metadata": {
            "description": "Standard list metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
            "default": {},
            "allOf": [
              {
                "$ref": "#/components/schemas/io.k8s.apimachinery.pkg.apis.meta.v1.ListMeta"
              }
            ]
          }
        },
        "x-kubernetes-group-version-kind": [
          {
            "group": "admissionregistration.k8s.io",
            "kind": "ValidatingAdmissionPolicyList",
            "version": "v1"
          }
        ]
      },
      "io.k8s.api.admissionregistration.v1.ValidatingAdmissionPolicySpec": {
        "description": "ValidatingAdmissionPolicySpec is the specification of the desired behavior of the AdmissionPolicy.",
        "type": "object",
        "properties": {
          "auditAnnotations": {
            "description": "auditAnnotations contains CEL expressions which are used to produce audit annotations for the audit event of the API request. validations and auditAnnotations may not both be empty; a least one of validations or auditAnnotations is required.",
            "type": "array",
            "items": {
              "default": {},
              "allOf": [
                {
                  "$ref": "#/components/schemas/io.k8s.api.admissionregistration.v1.AuditAnnotation"
                }
              ]
            },
            "x-kubernetes-list-type": "atomic"
          },
          "failurePolicy": {
            "description": "failurePolicy defines how to handle failures for the admission policy. Failures can occur from CEL expression parse errors, type check errors, runtime errors and invalid or mis-configured policy definitions or bindings.\n\nA policy is invalid if spec.paramKind refers to a non-existent Kind. A binding is invalid if spec.paramRef.name refers to a non-existent resource.\n\nfailurePolicy does not define how validations that evaluate to false are handled.\n\nWhen failurePolicy is set to Fail, ValidatingAdmissionPolicyBinding validationActions define how failures are enforced.\n\nAllowed values are Ignore or Fail. Defaults to Fail.\n\nPossible enum values:\n - `\"Fail\"` means that an error calling the webhook causes the admission to fail.\n - `\"Ignore\"` means that an error calling the webhook is ignored.",
            "type": "string",
            "enum": ["Fail", "Ignore"]
          },
          "matchConditions": {
            "description": "MatchConditions is a list of conditions that must be met for a request to be validated. Match conditions filter requests that have already been matched by the rules, namespaceSelector, and objectSelector. An empty list of matchConditions matches all requests. There are a maximum of 64 match conditions allowed.\n\nIf a parameter object is provided, it can be accessed via the `params` handle in the same manner as validation expressions.\n\nThe exact matching logic is (in order):\n  1. If ANY matchCondition evaluates to FALSE, the policy is skipped.\n  2. If ALL matchConditions evaluate to TRUE, the policy is evaluated.\n  3. If any matchCondition evaluates to an error (but none are FALSE):\n     - If failurePolicy=Fail, reject the request\n     - If failurePolicy=Ignore, the policy is skipped",
            "type": "array",
            "items": {
              "default": {},
              "allOf": [
                {
                  "$ref": "#/components/schemas/io.k8s.api.admissionregistration.v1.MatchCondition"
                }
              ]
            },
            "x-kubernetes-list-map-keys": ["name"],
            "x-kubernetes-list-type": "map",
            "x-kubernetes-patch-merge-key": "name",
            "x-kubernetes-patch-strategy": "merge"
          },
          "matchConstraints": {
            "description": "MatchConstraints specifies what resources this policy is designed to validate. The AdmissionPolicy cares about a request if it matches _all_ Constraints. However, in order to prevent clusters from being put into an unstable state that cannot be recovered from via the API ValidatingAdmissionPolicy cannot match ValidatingAdmissionPolicy and ValidatingAdmissionPolicyBinding. Required.",
            "allOf": [
              {
                "$ref": "#/components/schemas/io.k8s.api.admissionregistration.v1.MatchResources"
              }
            ]
          },
          "paramKind": {
            "description": "ParamKind specifies the kind of resources used to parameterize this policy. If absent, there are no parameters for this policy and the param CEL variable will not be provided to validation expressions. If ParamKind refers to a non-existent kind, this policy definition is mis-configured and the FailurePolicy is applied. If paramKind is specified but paramRef is unset in ValidatingAdmissionPolicyBinding, the params variable will be null.",
            "allOf": [
              {
                "$ref": "#/components/schemas/io.k8s.api.admissionregistration.v1.ParamKind"
              }
            ]
          },
          "validations": {
            "description": "Validations contain CEL expressions which is used to apply the validation. Validations and AuditAnnotations may not both be empty; a minimum of one Validations or AuditAnnotations is required.",
            "type": "array",
            "items": {
              "default": {},
              "allOf": [
                {
                  "$ref": "#/components/schemas/io.k8s.api.admissionregistration.v1.Validation"
                }
              ]
            },
            "x-kubernetes-list-type": "atomic"
          },
          "variables": {
            "description": "Variables contain definitions of variables that can be used in composition of other expressions. Each variable is defined as a named CEL expression. The variables defined here will be available under `variables` in other expressions of the policy except MatchConditions because MatchConditions are evaluated before the rest of the policy.\n\nThe expression of a variable can refer to other variables defined earlier in the list but not those after. Thus, Variables must be sorted by the order of first appearance and acyclic.",
            "type": "array",
            "items": {
              "default": {},
              "allOf": [
                {
                  "$ref": "#/components/schemas/io.k8s.api.admissionregistration.v1.Variable"
                }
              ]
            },
            "x-kubernetes-list-map-keys": ["name"],
            "x-kubernetes-list-type": "map",
            "x-kubernetes-patch-merge-key": "name",
            "x-kubernetes-patch-strategy": "merge"
          }
        }
      },
      "io.k8s.api.admissionregistration.v1.ValidatingAdmissionPolicyStatus": {
        "description": "ValidatingAdmissionPolicyStatus represents the status of an admission validation policy.",
        "type": "object",
        "properties": {
          "conditions": {
            "description": "The conditions represent the latest available observations of a policy's current state.",
            "type": "array",
            "items": {
              "default": {},
              "allOf": [
                {
                  "$ref": "#/components/schemas/io.k8s.apimachinery.pkg.apis.meta.v1.Condition"
                }
              ]
            },
            "x-kubernetes-list-map-keys": ["type"],
            "x-kubernetes-list-type": "map"
          },
          "observedGeneration": {
            "description": "The generation observed by the controller.",
            "type": "integer",
            "format": "int64"
          },
          "typeChecking": {
            "description": "The results of type checking for each expression. Presence of this field indicates the completion of the type checking.",
            "allOf": [
              {
                "$ref": "#/components/schemas/io.k8s.api.admissionregistration.v1.TypeChecking"
              }
            ]
          }
        }
      },
      "io.k8s.api.admissionregistration.v1.ValidatingWebhook": {
        "description": "ValidatingWebhook describes an admission webhook and the resources and operations it applies to.",
        "type": "object",
        "required": [
          "name",
          "clientConfig",
          "sideEffects",
          "admissionReviewVersions"
        ],
        "properties": {
          "admissionReviewVersions": {
            "description": "AdmissionReviewVersions is an ordered list of preferred `AdmissionReview` versions the Webhook expects. API server will try to use first version in the list which it supports. If none of the versions specified in this list supported by API server, validation will fail for this object. If a persisted webhook configuration specifies allowed versions and does not include any versions known to the API Server, calls to the webhook will fail and be subject to the failure policy.",
            "type": "array",
            "items": { "type": "string", "default": "" },
            "x-kubernetes-list-type": "atomic"
          },
          "clientConfig": {
            "description": "ClientConfig defines how to communicate with the hook. Required",
            "default": {},
            "allOf": [
              {
                "$ref": "#/components/schemas/io.k8s.api.admissionregistration.v1.WebhookClientConfig"
              }
            ]
          },
          "failurePolicy": {
            "description": "FailurePolicy defines how unrecognized errors from the admission endpoint are handled - allowed values are Ignore or Fail. Defaults to Fail.\n\nPossible enum values:\n - `\"Fail\"` means that an error calling the webhook causes the admission to fail.\n - `\"Ignore\"` means that an error calling the webhook is ignored.",
            "type": "string",
            "enum": ["Fail", "Ignore"]
          },
          "matchConditions": {
            "description": "MatchConditions is a list of conditions that must be met for a request to be sent to this webhook. Match conditions filter requests that have already been matched by the rules, namespaceSelector, and objectSelector. An empty list of matchConditions matches all requests. There are a maximum of 64 match conditions allowed.\n\nThe exact matching logic is (in order):\n  1. If ANY matchCondition evaluates to FALSE, the webhook is skipped.\n  2. If ALL matchConditions evaluate to TRUE, the webhook is called.\n  3. If any matchCondition evaluates to an error (but none are FALSE):\n     - If failurePolicy=Fail, reject the request\n     - If failurePolicy=Ignore, the error is ignored and the webhook is skipped",
            "type": "array",
            "items": {
              "default": {},
              "allOf": [
                {
                  "$ref": "#/components/schemas/io.k8s.api.admissionregistration.v1.MatchCondition"
                }
              ]
            },
            "x-kubernetes-list-map-keys": ["name"],
            "x-kubernetes-list-type": "map",
            "x-kubernetes-patch-merge-key": "name",
            "x-kubernetes-patch-strategy": "merge"
          },
          "matchPolicy": {
            "description": "matchPolicy defines how the \"rules\" list is used to match incoming requests. Allowed values are \"Exact\" or \"Equivalent\".\n\n- Exact: match a request only if it exactly matches a specified rule. For example, if deployments can be modified via apps/v1, apps/v1beta1, and extensions/v1beta1, but \"rules\" only included `apiGroups:[\"apps\"], apiVersions:[\"v1\"], resources: [\"deployments\"]`, a request to apps/v1beta1 or extensions/v1beta1 would not be sent to the webhook.\n\n- Equivalent: match a request if modifies a resource listed in rules, even via another API group or version. For example, if deployments can be modified via apps/v1, apps/v1beta1, and extensions/v1beta1, and \"rules\" only included `apiGroups:[\"apps\"], apiVersions:[\"v1\"], resources: [\"deployments\"]`, a request to apps/v1beta1 or extensions/v1beta1 would be converted to apps/v1 and sent to the webhook.\n\nDefaults to \"Equivalent\"\n\nPossible enum values:\n - `\"Equivalent\"` means requests should be sent to the webhook if they modify a resource listed in rules via another API group or version.\n - `\"Exact\"` means requests should only be sent to the webhook if they exactly match a given rule.",
            "type": "string",
            "enum": ["Equivalent", "Exact"]
          },
          "name": {
            "description": "The name of the admission webhook. Name should be fully qualified, e.g., imagepolicy.kubernetes.io, where \"imagepolicy\" is the name of the webhook, and kubernetes.io is the name of the organization. Required.",
            "type": "string",
            "default": ""
          },
          "namespaceSelector": {
            "description": "NamespaceSelector decides whether to run the webhook on an object based on whether the namespace for that object matches the selector. If the object itself is a namespace, the matching is performed on object.metadata.labels. If the object is another cluster scoped resource, it never skips the webhook.\n\nFor example, to run the webhook on any objects whose namespace is not associated with \"runlevel\" of \"0\" or \"1\";  you will set the selector as follows: \"namespaceSelector\": {\n  \"matchExpressions\": [\n    {\n      \"key\": \"runlevel\",\n      \"operator\": \"NotIn\",\n      \"values\": [\n        \"0\",\n        \"1\"\n      ]\n    }\n  ]\n}\n\nIf instead you want to only run the webhook on any objects whose namespace is associated with the \"environment\" of \"prod\" or \"staging\"; you will set the selector as follows: \"namespaceSelector\": {\n  \"matchExpressions\": [\n    {\n      \"key\": \"environment\",\n      \"operator\": \"In\",\n      \"values\": [\n        \"prod\",\n        \"staging\"\n      ]\n    }\n  ]\n}\n\nSee https://kubernetes.io/docs/concepts/overview/working-with-objects/labels for more examples of label selectors.\n\nDefault to the empty LabelSelector, which matches everything.",
            "allOf": [
              {
                "$ref": "#/components/schemas/io.k8s.apimachinery.pkg.apis.meta.v1.LabelSelector"
              }
            ]
          },
          "objectSelector": {
            "description": "ObjectSelector decides whether to run the webhook based on if the object has matching labels. objectSelector is evaluated against both the oldObject and newObject that would be sent to the webhook, and is considered to match if either object matches the selector. A null object (oldObject in the case of create, or newObject in the case of delete) or an object that cannot have labels (like a DeploymentRollback or a PodProxyOptions object) is not considered to match. Use the object selector only if the webhook is opt-in, because end users may skip the admission webhook by setting the labels. Default to the empty LabelSelector, which matches everything.",
            "allOf": [
              {
                "$ref": "#/components/schemas/io.k8s.apimachinery.pkg.apis.meta.v1.LabelSelector"
              }
            ]
          },
          "rules": {
            "description": "Rules describes what operations on what resources/subresources the webhook cares about. The webhook cares about an operation if it matches _any_ Rule. However, in order to prevent ValidatingAdmissionWebhooks and MutatingAdmissionWebhooks from putting the cluster in a state which cannot be recovered from without completely disabling the plugin, ValidatingAdmissionWebhooks and MutatingAdmissionWebhooks are never called on admission requests for ValidatingWebhookConfiguration and MutatingWebhookConfiguration objects.",
            "type": "array",
            "items": {
              "default": {},
              "allOf": [
                {
                  "$ref": "#/components/schemas/io.k8s.api.admissionregistration.v1.RuleWithOperations"
                }
              ]
            },
            "x-kubernetes-list-type": "atomic"
          },
          "sideEffects": {
            "description": "SideEffects states whether this webhook has side effects. Acceptable values are: None, NoneOnDryRun (webhooks created via v1beta1 may also specify Some or Unknown). Webhooks with side effects MUST implement a reconciliation system, since a request may be rejected by a future step in the admission chain and the side effects therefore need to be undone. Requests with the dryRun attribute will be auto-rejected if they match a webhook with sideEffects == Unknown or Some.\n\nPossible enum values:\n - `\"None\"` means that calling the webhook will have no side effects.\n - `\"NoneOnDryRun\"` means that calling the webhook will possibly have side effects, but if the request being reviewed has the dry-run attribute, the side effects will be suppressed.\n - `\"Some\"` means that calling the webhook will possibly have side effects. If a request with the dry-run attribute would trigger a call to this webhook, the request will instead fail.\n - `\"Unknown\"` means that no information is known about the side effects of calling the webhook. If a request with the dry-run attribute would trigger a call to this webhook, the request will instead fail.",
            "type": "string",
            "enum": ["None", "NoneOnDryRun", "Some", "Unknown"]
          },
          "timeoutSeconds": {
            "description": "TimeoutSeconds specifies the timeout for this webhook. After the timeout passes, the webhook call will be ignored or the API call will fail based on the failure policy. The timeout value must be between 1 and 30 seconds. Default to 10 seconds.",
            "type": "integer",
            "format": "int32"
          }
        }
      },
      "io.k8s.api.admissionregistration.v1.ValidatingWebhookConfiguration": {
        "description": "ValidatingWebhookConfiguration describes the configuration of and admission webhook that accept or reject and object without changing it.",
        "type": "object",
        "properties": {
          "apiVersion": {
            "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
            "type": "string"
          },
          "kind": {
            "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
            "type": "string"
          },
          "metadata": {
            "description": "Standard object metadata; More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata.",
            "default": {},
            "allOf": [
              {
                "$ref": "#/components/schemas/io.k8s.apimachinery.pkg.apis.meta.v1.ObjectMeta"
              }
            ]
          },
          "webhooks": {
            "description": "Webhooks is a list of webhooks and the affected resources and operations.",
            "type": "array",
            "items": {
              "default": {},
              "allOf": [
                {
                  "$ref": "#/components/schemas/io.k8s.api.admissionregistration.v1.ValidatingWebhook"
                }
              ]
            },
            "x-kubernetes-list-map-keys": ["name"],
            "x-kubernetes-list-type": "map",
            "x-kubernetes-patch-merge-key": "name",
            "x-kubernetes-patch-strategy": "merge"
          }
        },
        "x-kubernetes-group-version-kind": [
          {
            "group": "admissionregistration.k8s.io",
            "kind": "ValidatingWebhookConfiguration",
            "version": "v1"
          }
        ]
      },
      "io.k8s.api.admissionregistration.v1.ValidatingWebhookConfigurationList": {
        "description": "ValidatingWebhookConfigurationList is a list of ValidatingWebhookConfiguration.",
        "type": "object",
        "required": ["items"],
        "properties": {
          "apiVersion": {
            "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
            "type": "string"
          },
          "items": {
            "description": "List of ValidatingWebhookConfiguration.",
            "type": "array",
            "items": {
              "default": {},
              "allOf": [
                {
                  "$ref": "#/components/schemas/io.k8s.api.admissionregistration.v1.ValidatingWebhookConfiguration"
                }
              ]
            }
          },
          "kind": {
            "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
            "type": "string"
          },
          "metadata": {
            "description": "Standard list metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
            "default": {},
            "allOf": [
              {
                "$ref": "#/components/schemas/io.k8s.apimachinery.pkg.apis.meta.v1.ListMeta"
              }
            ]
          }
        },
        "x-kubernetes-group-version-kind": [
          {
            "group": "admissionregistration.k8s.io",
            "kind": "ValidatingWebhookConfigurationList",
            "version": "v1"
          }
        ]
      },
      "io.k8s.api.admissionregistration.v1.Validation": {
        "description": "Validation specifies the CEL expression which is used to apply the validation.",
        "type": "object",
        "required": ["expression"],
        "properties": {
          "expression": {
            "description": "Expression represents the expression which will be evaluated by CEL. ref: https://github.com/google/cel-spec CEL expressions have access to the contents of the API request/response, organized into CEL variables as well as some other useful variables:\n\n- 'object' - The object from the incoming request. The value is null for DELETE requests. - 'oldObject' - The existing object. The value is null for CREATE requests. - 'request' - Attributes of the API request([ref](/pkg/apis/admission/types.go#AdmissionRequest)). - 'params' - Parameter resource referred to by the policy binding being evaluated. Only populated if the policy has a ParamKind. - 'namespaceObject' - The namespace object that the incoming object belongs to. The value is null for cluster-scoped resources. - 'variables' - Map of composited variables, from its name to its lazily evaluated value.\n  For example, a variable named 'foo' can be accessed as 'variables.foo'.\n- 'authorizer' - A CEL Authorizer. May be used to perform authorization checks for the principal (user or service account) of the request.\n  See https://pkg.go.dev/k8s.io/apiserver/pkg/cel/library#Authz\n- 'authorizer.requestResource' - A CEL ResourceCheck constructed from the 'authorizer' and configured with the\n  request resource.\n\nThe `apiVersion`, `kind`, `metadata.name` and `metadata.generateName` are always accessible from the root of the object. No other metadata properties are accessible.\n\nOnly property names of the form `[a-zA-Z_.-/][a-zA-Z0-9_.-/]*` are accessible. Accessible property names are escaped according to the following rules when accessed in the expression: - '__' escapes to '__underscores__' - '.' escapes to '__dot__' - '-' escapes to '__dash__' - '/' escapes to '__slash__' - Property names that exactly match a CEL RESERVED keyword escape to '__{keyword}__'. The keywords are:\n\t  \"true\", \"false\", \"null\", \"in\", \"as\", \"break\", \"const\", \"continue\", \"else\", \"for\", \"function\", \"if\",\n\t  \"import\", \"let\", \"loop\", \"package\", \"namespace\", \"return\".\nExamples:\n  - Expression accessing a property named \"namespace\": {\"Expression\": \"object.__namespace__ \u003e 0\"}\n  - Expression accessing a property named \"x-prop\": {\"Expression\": \"object.x__dash__prop \u003e 0\"}\n  - Expression accessing a property named \"redact__d\": {\"Expression\": \"object.redact__underscores__d \u003e 0\"}\n\nEquality on arrays with list type of 'set' or 'map' ignores element order, i.e. [1, 2] == [2, 1]. Concatenation on arrays with x-kubernetes-list-type use the semantics of the list type:\n  - 'set': `X + Y` performs a union where the array positions of all elements in `X` are preserved and\n    non-intersecting elements in `Y` are appended, retaining their partial order.\n  - 'map': `X + Y` performs a merge where the array positions of all keys in `X` are preserved but the values\n    are overwritten by values in `Y` when the key sets of `X` and `Y` intersect. Elements in `Y` with\n    non-intersecting keys are appended, retaining their partial order.\nRequired.",
            "type": "string",
            "default": ""
          },
          "message": {
            "description": "Message represents the message displayed when validation fails. The message is required if the Expression contains line breaks. The message must not contain line breaks. If unset, the message is \"failed rule: {Rule}\". e.g. \"must be a URL with the host matching spec.host\" If the Expression contains line breaks. Message is required. The message must not contain line breaks. If unset, the message is \"failed Expression: {Expression}\".",
            "type": "string"
          },
          "messageExpression": {
            "description": "messageExpression declares a CEL expression that evaluates to the validation failure message that is returned when this rule fails. Since messageExpression is used as a failure message, it must evaluate to a string. If both message and messageExpression are present on a validation, then messageExpression will be used if validation fails. If messageExpression results in a runtime error, the runtime error is logged, and the validation failure message is produced as if the messageExpression field were unset. If messageExpression evaluates to an empty string, a string with only spaces, or a string that contains line breaks, then the validation failure message will also be produced as if the messageExpression field were unset, and the fact that messageExpression produced an empty string/string with only spaces/string with line breaks will be logged. messageExpression has access to all the same variables as the `expression` except for 'authorizer' and 'authorizer.requestResource'. Example: \"object.x must be less than max (\"+string(params.max)+\")\"",
            "type": "string"
          },
          "reason": {
            "description": "Reason represents a machine-readable description of why this validation failed. If this is the first validation in the list to fail, this reason, as well as the corresponding HTTP response code, are used in the HTTP response to the client. The currently supported reasons are: \"Unauthorized\", \"Forbidden\", \"Invalid\", \"RequestEntityTooLarge\". If not set, StatusReasonInvalid is used in the response to the client.",
            "type": "string"
          }
        }
      },
      "io.k8s.api.admissionregistration.v1.Variable": {
        "description": "Variable is the definition of a variable that is used for composition. A variable is defined as a named expression.",
        "type": "object",
        "required": ["name", "expression"],
        "properties": {
          "expression": {
            "description": "Expression is the expression that will be evaluated as the value of the variable. The CEL expression has access to the same identifiers as the CEL expressions in Validation.",
            "type": "string",
            "default": ""
          },
          "name": {
            "description": "Name is the name of the variable. The name must be a valid CEL identifier and unique among all variables. The variable can be accessed in other expressions through `variables` For example, if name is \"foo\", the variable will be available as `variables.foo`",
            "type": "string",
            "default": ""
          }
        },
        "x-kubernetes-map-type": "atomic"
      },
      "io.k8s.api.admissionregistration.v1.WebhookClientConfig": {
        "description": "WebhookClientConfig contains the information to make a TLS connection with the webhook",
        "type": "object",
        "properties": {
          "caBundle": {
            "description": "`caBundle` is a PEM encoded CA bundle which will be used to validate the webhook's server certificate. If unspecified, system trust roots on the apiserver are used.",
            "type": "string",
            "format": "byte"
          },
          "service": {
            "description": "`service` is a reference to the service for this webhook. Either `service` or `url` must be specified.\n\nIf the webhook is running within the cluster, then you should use `service`.",
            "allOf": [
              {
                "$ref": "#/components/schemas/io.k8s.api.admissionregistration.v1.ServiceReference"
              }
            ]
          },
          "url": {
            "description": "`url` gives the location of the webhook, in standard URL form (`scheme://host:port/path`). Exactly one of `url` or `service` must be specified.\n\nThe `host` should not refer to a service running in the cluster; use the `service` field instead. The host might be resolved via external DNS in some apiservers (e.g., `kube-apiserver` cannot resolve in-cluster DNS as that would be a layering violation). `host` may also be an IP address.\n\nPlease note that using `localhost` or `127.0.0.1` as a `host` is risky unless you take great care to run this webhook on all hosts which run an apiserver which might need to make calls to this webhook. Such installs are likely to be non-portable, i.e., not easy to turn up in a new cluster.\n\nThe scheme must be \"https\"; the URL must begin with \"https://\".\n\nA path is optional, and if present may be any string permissible in a URL. You may use the path to pass an arbitrary string to the webhook, for example, a cluster identifier.\n\nAttempting to use a user or basic auth e.g. \"user:password@\" is not allowed. Fragments (\"#...\") and query parameters (\"?...\") are not allowed, either.",
            "type": "string"
          }
        }
      },
      "io.k8s.api.admissionregistration.v1alpha1.AuditAnnotation": {
        "description": "AuditAnnotation describes how to produce an audit annotation for an API request.",
        "type": "object",
        "required": ["key", "valueExpression"],
        "properties": {
          "key": {
            "description": "key specifies the audit annotation key. The audit annotation keys of a ValidatingAdmissionPolicy must be unique. The key must be a qualified name ([A-Za-z0-9][-A-Za-z0-9_.]*) no more than 63 bytes in length.\n\nThe key is combined with the resource name of the ValidatingAdmissionPolicy to construct an audit annotation key: \"{ValidatingAdmissionPolicy name}/{key}\".\n\nIf an admission webhook uses the same resource name as this ValidatingAdmissionPolicy and the same audit annotation key, the annotation key will be identical. In this case, the first annotation written with the key will be included in the audit event and all subsequent annotations with the same key will be discarded.\n\nRequired.",
            "type": "string",
            "default": ""
          },
          "valueExpression": {
            "description": "valueExpression represents the expression which is evaluated by CEL to produce an audit annotation value. The expression must evaluate to either a string or null value. If the expression evaluates to a string, the audit annotation is included with the string value. If the expression evaluates to null or empty string the audit annotation will be omitted. The valueExpression may be no longer than 5kb in length. If the result of the valueExpression is more than 10kb in length, it will be truncated to 10kb.\n\nIf multiple ValidatingAdmissionPolicyBinding resources match an API request, then the valueExpression will be evaluated for each binding. All unique values produced by the valueExpressions will be joined together in a comma-separated list.\n\nRequired.",
            "type": "string",
            "default": ""
          }
        }
      },
      "io.k8s.api.admissionregistration.v1alpha1.ExpressionWarning": {
        "description": "ExpressionWarning is a warning information that targets a specific expression.",
        "type": "object",
        "required": ["fieldRef", "warning"],
        "properties": {
          "fieldRef": {
            "description": "The path to the field that refers the expression. For example, the reference to the expression of the first item of validations is \"spec.validations[0].expression\"",
            "type": "string",
            "default": ""
          },
          "warning": {
            "description": "The content of type checking information in a human-readable form. Each line of the warning contains the type that the expression is checked against, followed by the type check error from the compiler.",
            "type": "string",
            "default": ""
          }
        }
      },
      "io.k8s.api.admissionregistration.v1alpha1.MatchCondition": {
        "type": "object",
        "required": ["name", "expression"],
        "properties": {
          "expression": {
            "description": "Expression represents the expression which will be evaluated by CEL. Must evaluate to bool. CEL expressions have access to the contents of the AdmissionRequest and Authorizer, organized into CEL variables:\n\n'object' - The object from the incoming request. The value is null for DELETE requests. 'oldObject' - The existing object. The value is null for CREATE requests. 'request' - Attributes of the admission request(/pkg/apis/admission/types.go#AdmissionRequest). 'authorizer' - A CEL Authorizer. May be used to perform authorization checks for the principal (user or service account) of the request.\n  See https://pkg.go.dev/k8s.io/apiserver/pkg/cel/library#Authz\n'authorizer.requestResource' - A CEL ResourceCheck constructed from the 'authorizer' and configured with the\n  request resource.\nDocumentation on CEL: https://kubernetes.io/docs/reference/using-api/cel/\n\nRequired.",
            "type": "string",
            "default": ""
          },
          "name": {
            "description": "Name is an identifier for this match condition, used for strategic merging of MatchConditions, as well as providing an identifier for logging purposes. A good name should be descriptive of the associated expression. Name must be a qualified name consisting of alphanumeric characters, '-', '_' or '.', and must start and end with an alphanumeric character (e.g. 'MyName',  or 'my.name',  or '123-abc', regex used for validation is '([A-Za-z0-9][-A-Za-z0-9_.]*)?[A-Za-z0-9]') with an optional DNS subdomain prefix and '/' (e.g. 'example.com/MyName')\n\nRequired.",
            "type": "string",
            "default": ""
          }
        }
      },
      "io.k8s.api.admissionregistration.v1alpha1.MatchResources": {
        "description": "MatchResources decides whether to run the admission control policy on an object based on whether it meets the match criteria. The exclude rules take precedence over include rules (if a resource matches both, it is excluded)",
        "type": "object",
        "properties": {
          "excludeResourceRules": {
            "description": "ExcludeResourceRules describes what operations on what resources/subresources the ValidatingAdmissionPolicy should not care about. The exclude rules take precedence over include rules (if a resource matches both, it is excluded)",
            "type": "array",
            "items": {
              "default": {},
              "allOf": [
                {
                  "$ref": "#/components/schemas/io.k8s.api.admissionregistration.v1alpha1.NamedRuleWithOperations"
                }
              ]
            },
            "x-kubernetes-list-type": "atomic"
          },
          "matchPolicy": {
            "description": "matchPolicy defines how the \"MatchResources\" list is used to match incoming requests. Allowed values are \"Exact\" or \"Equivalent\".\n\n- Exact: match a request only if it exactly matches a specified rule. For example, if deployments can be modified via apps/v1, apps/v1beta1, and extensions/v1beta1, but \"rules\" only included `apiGroups:[\"apps\"], apiVersions:[\"v1\"], resources: [\"deployments\"]`, a request to apps/v1beta1 or extensions/v1beta1 would not be sent to the ValidatingAdmissionPolicy.\n\n- Equivalent: match a request if modifies a resource listed in rules, even via another API group or version. For example, if deployments can be modified via apps/v1, apps/v1beta1, and extensions/v1beta1, and \"rules\" only included `apiGroups:[\"apps\"], apiVersions:[\"v1\"], resources: [\"deployments\"]`, a request to apps/v1beta1 or extensions/v1beta1 would be converted to apps/v1 and sent to the ValidatingAdmissionPolicy.\n\nDefaults to \"Equivalent\"\n\nPossible enum values:\n - `\"Equivalent\"` means requests should be sent to the webhook if they modify a resource listed in rules via another API group or version.\n - `\"Exact\"` means requests should only be sent to the webhook if they exactly match a given rule.",
            "type": "string",
            "enum": ["Equivalent", "Exact"]
          },
          "namespaceSelector": {
            "description": "NamespaceSelector decides whether to run the admission control policy on an object based on whether the namespace for that object matches the selector. If the object itself is a namespace, the matching is performed on object.metadata.labels. If the object is another cluster scoped resource, it never skips the policy.\n\nFor example, to run the webhook on any objects whose namespace is not associated with \"runlevel\" of \"0\" or \"1\";  you will set the selector as follows: \"namespaceSelector\": {\n  \"matchExpressions\": [\n    {\n      \"key\": \"runlevel\",\n      \"operator\": \"NotIn\",\n      \"values\": [\n        \"0\",\n        \"1\"\n      ]\n    }\n  ]\n}\n\nIf instead you want to only run the policy on any objects whose namespace is associated with the \"environment\" of \"prod\" or \"staging\"; you will set the selector as follows: \"namespaceSelector\": {\n  \"matchExpressions\": [\n    {\n      \"key\": \"environment\",\n      \"operator\": \"In\",\n      \"values\": [\n        \"prod\",\n        \"staging\"\n      ]\n    }\n  ]\n}\n\nSee https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/ for more examples of label selectors.\n\nDefault to the empty LabelSelector, which matches everything.",
            "allOf": [
              {
                "$ref": "#/components/schemas/io.k8s.apimachinery.pkg.apis.meta.v1.LabelSelector"
              }
            ]
          },
          "objectSelector": {
            "description": "ObjectSelector decides whether to run the validation based on if the object has matching labels. objectSelector is evaluated against both the oldObject and newObject that would be sent to the cel validation, and is considered to match if either object matches the selector. A null object (oldObject in the case of create, or newObject in the case of delete) or an object that cannot have labels (like a DeploymentRollback or a PodProxyOptions object) is not considered to match. Use the object selector only if the webhook is opt-in, because end users may skip the admission webhook by setting the labels. Default to the empty LabelSelector, which matches everything.",
            "allOf": [
              {
                "$ref": "#/components/schemas/io.k8s.apimachinery.pkg.apis.meta.v1.LabelSelector"
              }
            ]
          },
          "resourceRules": {
            "description": "ResourceRules describes what operations on what resources/subresources the ValidatingAdmissionPolicy matches. The policy cares about an operation if it matches _any_ Rule.",
            "type": "array",
            "items": {
              "default": {},
              "allOf": [
                {
                  "$ref": "#/components/schemas/io.k8s.api.admissionregistration.v1alpha1.NamedRuleWithOperations"
                }
              ]
            },
            "x-kubernetes-list-type": "atomic"
          }
        },
        "x-kubernetes-map-type": "atomic"
      },
      "io.k8s.api.admissionregistration.v1alpha1.NamedRuleWithOperations": {
        "description": "NamedRuleWithOperations is a tuple of Operations and Resources with ResourceNames.",
        "type": "object",
        "properties": {
          "apiGroups": {
            "description": "APIGroups is the API groups the resources belong to. '*' is all groups. If '*' is present, the length of the slice must be one. Required.",
            "type": "array",
            "items": { "type": "string", "default": "" },
            "x-kubernetes-list-type": "atomic"
          },
          "apiVersions": {
            "description": "APIVersions is the API versions the resources belong to. '*' is all versions. If '*' is present, the length of the slice must be one. Required.",
            "type": "array",
            "items": { "type": "string", "default": "" },
            "x-kubernetes-list-type": "atomic"
          },
          "operations": {
            "description": "Operations is the operations the admission hook cares about - CREATE, UPDATE, DELETE, CONNECT or * for all of those operations and any future admission operations that are added. If '*' is present, the length of the slice must be one. Required.",
            "type": "array",
            "items": {
              "type": "string",
              "default": "",
              "enum": ["*", "CONNECT", "CREATE", "DELETE", "UPDATE"]
            },
            "x-kubernetes-list-type": "atomic"
          },
          "resourceNames": {
            "description": "ResourceNames is an optional white list of names that the rule applies to.  An empty set means that everything is allowed.",
            "type": "array",
            "items": { "type": "string", "default": "" },
            "x-kubernetes-list-type": "atomic"
          },
          "resources": {
            "description": "Resources is a list of resources this rule applies to.\n\nFor example: 'pods' means pods. 'pods/log' means the log subresource of pods. '*' means all resources, but not subresources. 'pods/*' means all subresources of pods. '*/scale' means all scale subresources. '*/*' means all resources and their subresources.\n\nIf wildcard is present, the validation rule will ensure resources do not overlap with each other.\n\nDepending on the enclosing object, subresources might not be allowed. Required.",
            "type": "array",
            "items": { "type": "string", "default": "" },
            "x-kubernetes-list-type": "atomic"
          },
          "scope": {
            "description": "scope specifies the scope of this rule. Valid values are \"Cluster\", \"Namespaced\", and \"*\" \"Cluster\" means that only cluster-scoped resources will match this rule. Namespace API objects are cluster-scoped. \"Namespaced\" means that only namespaced resources will match this rule. \"*\" means that there are no scope restrictions. Subresources match the scope of their parent resource. Default is \"*\".",
            "type": "string"
          }
        },
        "x-kubernetes-map-type": "atomic"
      },
      "io.k8s.api.admissionregistration.v1alpha1.ParamKind": {
        "description": "ParamKind is a tuple of Group Kind and Version.",
        "type": "object",
        "properties": {
          "apiVersion": {
            "description": "APIVersion is the API group version the resources belong to. In format of \"group/version\". Required.",
            "type": "string"
          },
          "kind": {
            "description": "Kind is the API kind the resources belong to. Required.",
            "type": "string"
          }
        },
        "x-kubernetes-map-type": "atomic"
      },
      "io.k8s.api.admissionregistration.v1alpha1.ParamRef": {
        "description": "ParamRef describes how to locate the params to be used as input to expressions of rules applied by a policy binding.",
        "type": "object",
        "properties": {
          "name": {
            "description": "`name` is the name of the resource being referenced.\n\n`name` and `selector` are mutually exclusive properties. If one is set, the other must be unset.",
            "type": "string"
          },
          "namespace": {
            "description": "namespace is the namespace of the referenced resource. Allows limiting the search for params to a specific namespace. Applies to both `name` and `selector` fields.\n\nA per-namespace parameter may be used by specifying a namespace-scoped `paramKind` in the policy and leaving this field empty.\n\n- If `paramKind` is cluster-scoped, this field MUST be unset. Setting this field results in a configuration error.\n\n- If `paramKind` is namespace-scoped, the namespace of the object being evaluated for admission will be used when this field is left unset. Take care that if this is left empty the binding must not match any cluster-scoped resources, which will result in an error.",
            "type": "string"
          },
          "parameterNotFoundAction": {
            "description": "`parameterNotFoundAction` controls the behavior of the binding when the resource exists, and name or selector is valid, but there are no parameters matched by the binding. If the value is set to `Allow`, then no matched parameters will be treated as successful validation by the binding. If set to `Deny`, then no matched parameters will be subject to the `failurePolicy` of the policy.\n\nAllowed values are `Allow` or `Deny` Default to `Deny`\n\nPossible enum values:\n - `\"Allow\"` Ignore means that an error finding params for a binding is ignored\n - `\"Deny\"` Fail means that an error finding params for a binding is ignored",
            "type": "string",
            "enum": ["Allow", "Deny"]
          },
          "selector": {
            "description": "selector can be used to match multiple param objects based on their labels. Supply selector: {} to match all resources of the ParamKind.\n\nIf multiple params are found, they are all evaluated with the policy expressions and the results are ANDed together.\n\nOne of `name` or `selector` must be set, but `name` and `selector` are mutually exclusive properties. If one is set, the other must be unset.",
            "allOf": [
              {
                "$ref": "#/components/schemas/io.k8s.apimachinery.pkg.apis.meta.v1.LabelSelector"
              }
            ]
          }
        },
        "x-kubernetes-map-type": "atomic"
      },
      "io.k8s.api.admissionregistration.v1alpha1.TypeChecking": {
        "description": "TypeChecking contains results of type checking the expressions in the ValidatingAdmissionPolicy",
        "type": "object",
        "properties": {
          "expressionWarnings": {
            "description": "The type checking warnings for each expression.",
            "type": "array",
            "items": {
              "default": {},
              "allOf": [
                {
                  "$ref": "#/components/schemas/io.k8s.api.admissionregistration.v1alpha1.ExpressionWarning"
                }
              ]
            },
            "x-kubernetes-list-type": "atomic"
          }
        }
      },
      "io.k8s.api.admissionregistration.v1alpha1.ValidatingAdmissionPolicy": {
        "description": "ValidatingAdmissionPolicy describes the definition of an admission validation policy that accepts or rejects an object without changing it.",
        "type": "object",
        "properties": {
          "apiVersion": {
            "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
            "type": "string"
          },
          "kind": {
            "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
            "type": "string"
          },
          "metadata": {
            "description": "Standard object metadata; More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata.",
            "default": {},
            "allOf": [
              {
                "$ref": "#/components/schemas/io.k8s.apimachinery.pkg.apis.meta.v1.ObjectMeta"
              }
            ]
          },
          "spec": {
            "description": "Specification of the desired behavior of the ValidatingAdmissionPolicy.",
            "default": {},
            "allOf": [
              {
                "$ref": "#/components/schemas/io.k8s.api.admissionregistration.v1alpha1.ValidatingAdmissionPolicySpec"
              }
            ]
          },
          "status": {
            "description": "The status of the ValidatingAdmissionPolicy, including warnings that are useful to determine if the policy behaves in the expected way. Populated by the system. Read-only.",
            "default": {},
            "allOf": [
              {
                "$ref": "#/components/schemas/io.k8s.api.admissionregistration.v1alpha1.ValidatingAdmissionPolicyStatus"
              }
            ]
          }
        },
        "x-kubernetes-group-version-kind": [
          {
            "group": "admissionregistration.k8s.io",
            "kind": "ValidatingAdmissionPolicy",
            "version": "v1alpha1"
          }
        ]
      },
      "io.k8s.api.admissionregistration.v1alpha1.ValidatingAdmissionPolicyBinding": {
        "description": "ValidatingAdmissionPolicyBinding binds the ValidatingAdmissionPolicy with paramerized resources. ValidatingAdmissionPolicyBinding and parameter CRDs together define how cluster administrators configure policies for clusters.\n\nFor a given admission request, each binding will cause its policy to be evaluated N times, where N is 1 for policies/bindings that don't use params, otherwise N is the number of parameters selected by the binding.\n\nThe CEL expressions of a policy must have a computed CEL cost below the maximum CEL budget. Each evaluation of the policy is given an independent CEL cost budget. Adding/removing policies, bindings, or params can not affect whether a given (policy, binding, param) combination is within its own CEL budget.",
        "type": "object",
        "properties": {
          "apiVersion": {
            "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
            "type": "string"
          },
          "kind": {
            "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
            "type": "string"
          },
          "metadata": {
            "description": "Standard object metadata; More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata.",
            "default": {},
            "allOf": [
              {
                "$ref": "#/components/schemas/io.k8s.apimachinery.pkg.apis.meta.v1.ObjectMeta"
              }
            ]
          },
          "spec": {
            "description": "Specification of the desired behavior of the ValidatingAdmissionPolicyBinding.",
            "default": {},
            "allOf": [
              {
                "$ref": "#/components/schemas/io.k8s.api.admissionregistration.v1alpha1.ValidatingAdmissionPolicyBindingSpec"
              }
            ]
          }
        },
        "x-kubernetes-group-version-kind": [
          {
            "group": "admissionregistration.k8s.io",
            "kind": "ValidatingAdmissionPolicyBinding",
            "version": "v1alpha1"
          }
        ]
      },
      "io.k8s.api.admissionregistration.v1alpha1.ValidatingAdmissionPolicyBindingList": {
        "description": "ValidatingAdmissionPolicyBindingList is a list of ValidatingAdmissionPolicyBinding.",
        "type": "object",
        "required": ["items"],
        "properties": {
          "apiVersion": {
            "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
            "type": "string"
          },
          "items": {
            "description": "List of PolicyBinding.",
            "type": "array",
            "items": {
              "default": {},
              "allOf": [
                {
                  "$ref": "#/components/schemas/io.k8s.api.admissionregistration.v1alpha1.ValidatingAdmissionPolicyBinding"
                }
              ]
            }
          },
          "kind": {
            "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
            "type": "string"
          },
          "metadata": {
            "description": "Standard list metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
            "default": {},
            "allOf": [
              {
                "$ref": "#/components/schemas/io.k8s.apimachinery.pkg.apis.meta.v1.ListMeta"
              }
            ]
          }
        },
        "x-kubernetes-group-version-kind": [
          {
            "group": "admissionregistration.k8s.io",
            "kind": "ValidatingAdmissionPolicyBindingList",
            "version": "v1alpha1"
          }
        ]
      },
      "io.k8s.api.admissionregistration.v1alpha1.ValidatingAdmissionPolicyBindingSpec": {
        "description": "ValidatingAdmissionPolicyBindingSpec is the specification of the ValidatingAdmissionPolicyBinding.",
        "type": "object",
        "properties": {
          "matchResources": {
            "description": "MatchResources declares what resources match this binding and will be validated by it. Note that this is intersected with the policy's matchConstraints, so only requests that are matched by the policy can be selected by this. If this is unset, all resources matched by the policy are validated by this binding When resourceRules is unset, it does not constrain resource matching. If a resource is matched by the other fields of this object, it will be validated. Note that this is differs from ValidatingAdmissionPolicy matchConstraints, where resourceRules are required.",
            "allOf": [
              {
                "$ref": "#/components/schemas/io.k8s.api.admissionregistration.v1alpha1.MatchResources"
              }
            ]
          },
          "paramRef": {
            "description": "paramRef specifies the parameter resource used to configure the admission control policy. It should point to a resource of the type specified in ParamKind of the bound ValidatingAdmissionPolicy. If the policy specifies a ParamKind and the resource referred to by ParamRef does not exist, this binding is considered mis-configured and the FailurePolicy of the ValidatingAdmissionPolicy applied. If the policy does not specify a ParamKind then this field is ignored, and the rules are evaluated without a param.",
            "allOf": [
              {
                "$ref": "#/components/schemas/io.k8s.api.admissionregistration.v1alpha1.ParamRef"
              }
            ]
          },
          "policyName": {
            "description": "PolicyName references a ValidatingAdmissionPolicy name which the ValidatingAdmissionPolicyBinding binds to. If the referenced resource does not exist, this binding is considered invalid and will be ignored Required.",
            "type": "string"
          },
          "validationActions": {
            "description": "validationActions declares how Validations of the referenced ValidatingAdmissionPolicy are enforced. If a validation evaluates to false it is always enforced according to these actions.\n\nFailures defined by the ValidatingAdmissionPolicy's FailurePolicy are enforced according to these actions only if the FailurePolicy is set to Fail, otherwise the failures are ignored. This includes compilation errors, runtime errors and misconfigurations of the policy.\n\nvalidationActions is declared as a set of action values. Order does not matter. validationActions may not contain duplicates of the same action.\n\nThe supported actions values are:\n\n\"Deny\" specifies that a validation failure results in a denied request.\n\n\"Warn\" specifies that a validation failure is reported to the request client in HTTP Warning headers, with a warning code of 299. Warnings can be sent both for allowed or denied admission responses.\n\n\"Audit\" specifies that a validation failure is included in the published audit event for the request. The audit event will contain a `validation.policy.admission.k8s.io/validation_failure` audit annotation with a value containing the details of the validation failures, formatted as a JSON list of objects, each with the following fields: - message: The validation failure message string - policy: The resource name of the ValidatingAdmissionPolicy - binding: The resource name of the ValidatingAdmissionPolicyBinding - expressionIndex: The index of the failed validations in the ValidatingAdmissionPolicy - validationActions: The enforcement actions enacted for the validation failure Example audit annotation: `\"validation.policy.admission.k8s.io/validation_failure\": \"[{\"message\": \"Invalid value\", {\"policy\": \"policy.example.com\", {\"binding\": \"policybinding.example.com\", {\"expressionIndex\": \"1\", {\"validationActions\": [\"Audit\"]}]\"`\n\nClients should expect to handle additional values by ignoring any values not recognized.\n\n\"Deny\" and \"Warn\" may not be used together since this combination needlessly duplicates the validation failure both in the API response body and the HTTP warning headers.\n\nRequired.",
            "type": "array",
            "items": {
              "type": "string",
              "default": "",
              "enum": ["Audit", "Deny", "Warn"]
            },
            "x-kubernetes-list-type": "set"
          }
        }
      },
      "io.k8s.api.admissionregistration.v1alpha1.ValidatingAdmissionPolicyList": {
        "description": "ValidatingAdmissionPolicyList is a list of ValidatingAdmissionPolicy.",
        "type": "object",
        "required": ["items"],
        "properties": {
          "apiVersion": {
            "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
            "type": "string"
          },
          "items": {
            "description": "List of ValidatingAdmissionPolicy.",
            "type": "array",
            "items": {
              "default": {},
              "allOf": [
                {
                  "$ref": "#/components/schemas/io.k8s.api.admissionregistration.v1alpha1.ValidatingAdmissionPolicy"
                }
              ]
            }
          },
          "kind": {
            "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
            "type": "string"
          },
          "metadata": {
            "description": "Standard list metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
            "default": {},
            "allOf": [
              {
                "$ref": "#/components/schemas/io.k8s.apimachinery.pkg.apis.meta.v1.ListMeta"
              }
            ]
          }
        },
        "x-kubernetes-group-version-kind": [
          {
            "group": "admissionregistration.k8s.io",
            "kind": "ValidatingAdmissionPolicyList",
            "version": "v1alpha1"
          }
        ]
      },
      "io.k8s.api.admissionregistration.v1alpha1.ValidatingAdmissionPolicySpec": {
        "description": "ValidatingAdmissionPolicySpec is the specification of the desired behavior of the AdmissionPolicy.",
        "type": "object",
        "properties": {
          "auditAnnotations": {
            "description": "auditAnnotations contains CEL expressions which are used to produce audit annotations for the audit event of the API request. validations and auditAnnotations may not both be empty; a least one of validations or auditAnnotations is required.",
            "type": "array",
            "items": {
              "default": {},
              "allOf": [
                {
                  "$ref": "#/components/schemas/io.k8s.api.admissionregistration.v1alpha1.AuditAnnotation"
                }
              ]
            },
            "x-kubernetes-list-type": "atomic"
          },
          "failurePolicy": {
            "description": "failurePolicy defines how to handle failures for the admission policy. Failures can occur from CEL expression parse errors, type check errors, runtime errors and invalid or mis-configured policy definitions or bindings.\n\nA policy is invalid if spec.paramKind refers to a non-existent Kind. A binding is invalid if spec.paramRef.name refers to a non-existent resource.\n\nfailurePolicy does not define how validations that evaluate to false are handled.\n\nWhen failurePolicy is set to Fail, ValidatingAdmissionPolicyBinding validationActions define how failures are enforced.\n\nAllowed values are Ignore or Fail. Defaults to Fail.\n\nPossible enum values:\n - `\"Fail\"` means that an error calling the webhook causes the admission to fail.\n - `\"Ignore\"` means that an error calling the webhook is ignored.",
            "type": "string",
            "enum": ["Fail", "Ignore"]
          },
          "matchConditions": {
            "description": "MatchConditions is a list of conditions that must be met for a request to be validated. Match conditions filter requests that have already been matched by the rules, namespaceSelector, and objectSelector. An empty list of matchConditions matches all requests. There are a maximum of 64 match conditions allowed.\n\nIf a parameter object is provided, it can be accessed via the `params` handle in the same manner as validation expressions.\n\nThe exact matching logic is (in order):\n  1. If ANY matchCondition evaluates to FALSE, the policy is skipped.\n  2. If ALL matchConditions evaluate to TRUE, the policy is evaluated.\n  3. If any matchCondition evaluates to an error (but none are FALSE):\n     - If failurePolicy=Fail, reject the request\n     - If failurePolicy=Ignore, the policy is skipped",
            "type": "array",
            "items": {
              "default": {},
              "allOf": [
                {
                  "$ref": "#/components/schemas/io.k8s.api.admissionregistration.v1alpha1.MatchCondition"
                }
              ]
            },
            "x-kubernetes-list-map-keys": ["name"],
            "x-kubernetes-list-type": "map",
            "x-kubernetes-patch-merge-key": "name",
            "x-kubernetes-patch-strategy": "merge"
          },
          "matchConstraints": {
            "description": "MatchConstraints specifies what resources this policy is designed to validate. The AdmissionPolicy cares about a request if it matches _all_ Constraints. However, in order to prevent clusters from being put into an unstable state that cannot be recovered from via the API ValidatingAdmissionPolicy cannot match ValidatingAdmissionPolicy and ValidatingAdmissionPolicyBinding. Required.",
            "allOf": [
              {
                "$ref": "#/components/schemas/io.k8s.api.admissionregistration.v1alpha1.MatchResources"
              }
            ]
          },
          "paramKind": {
            "description": "ParamKind specifies the kind of resources used to parameterize this policy. If absent, there are no parameters for this policy and the param CEL variable will not be provided to validation expressions. If ParamKind refers to a non-existent kind, this policy definition is mis-configured and the FailurePolicy is applied. If paramKind is specified but paramRef is unset in ValidatingAdmissionPolicyBinding, the params variable will be null.",
            "allOf": [
              {
                "$ref": "#/components/schemas/io.k8s.api.admissionregistration.v1alpha1.ParamKind"
              }
            ]
          },
          "validations": {
            "description": "Validations contain CEL expressions which is used to apply the validation. Validations and AuditAnnotations may not both be empty; a minimum of one Validations or AuditAnnotations is required.",
            "type": "array",
            "items": {
              "default": {},
              "allOf": [
                {
                  "$ref": "#/components/schemas/io.k8s.api.admissionregistration.v1alpha1.Validation"
                }
              ]
            },
            "x-kubernetes-list-type": "atomic"
          },
          "variables": {
            "description": "Variables contain definitions of variables that can be used in composition of other expressions. Each variable is defined as a named CEL expression. The variables defined here will be available under `variables` in other expressions of the policy except MatchConditions because MatchConditions are evaluated before the rest of the policy.\n\nThe expression of a variable can refer to other variables defined earlier in the list but not those after. Thus, Variables must be sorted by the order of first appearance and acyclic.",
            "type": "array",
            "items": {
              "default": {},
              "allOf": [
                {
                  "$ref": "#/components/schemas/io.k8s.api.admissionregistration.v1alpha1.Variable"
                }
              ]
            },
            "x-kubernetes-list-map-keys": ["name"],
            "x-kubernetes-list-type": "map",
            "x-kubernetes-patch-merge-key": "name",
            "x-kubernetes-patch-strategy": "merge"
          }
        }
      },
      "io.k8s.api.admissionregistration.v1alpha1.ValidatingAdmissionPolicyStatus": {
        "description": "ValidatingAdmissionPolicyStatus represents the status of a ValidatingAdmissionPolicy.",
        "type": "object",
        "properties": {
          "conditions": {
            "description": "The conditions represent the latest available observations of a policy's current state.",
            "type": "array",
            "items": {
              "default": {},
              "allOf": [
                {
                  "$ref": "#/components/schemas/io.k8s.apimachinery.pkg.apis.meta.v1.Condition"
                }
              ]
            },
            "x-kubernetes-list-map-keys": ["type"],
            "x-kubernetes-list-type": "map"
          },
          "observedGeneration": {
            "description": "The generation observed by the controller.",
            "type": "integer",
            "format": "int64"
          },
          "typeChecking": {
            "description": "The results of type checking for each expression. Presence of this field indicates the completion of the type checking.",
            "allOf": [
              {
                "$ref": "#/components/schemas/io.k8s.api.admissionregistration.v1alpha1.TypeChecking"
              }
            ]
          }
        }
      },
      "io.k8s.api.admissionregistration.v1alpha1.Validation": {
        "description": "Validation specifies the CEL expression which is used to apply the validation.",
        "type": "object",
        "required": ["expression"],
        "properties": {
          "expression": {
            "description": "Expression represents the expression which will be evaluated by CEL. ref: https://github.com/google/cel-spec CEL expressions have access to the contents of the API request/response, organized into CEL variables as well as some other useful variables:\n\n- 'object' - The object from the incoming request. The value is null for DELETE requests. - 'oldObject' - The existing object. The value is null for CREATE requests. - 'request' - Attributes of the API request([ref](/pkg/apis/admission/types.go#AdmissionRequest)). - 'params' - Parameter resource referred to by the policy binding being evaluated. Only populated if the policy has a ParamKind. - 'namespaceObject' - The namespace object that the incoming object belongs to. The value is null for cluster-scoped resources. - 'variables' - Map of composited variables, from its name to its lazily evaluated value.\n  For example, a variable named 'foo' can be accessed as 'variables.foo'.\n- 'authorizer' - A CEL Authorizer. May be used to perform authorization checks for the principal (user or service account) of the request.\n  See https://pkg.go.dev/k8s.io/apiserver/pkg/cel/library#Authz\n- 'authorizer.requestResource' - A CEL ResourceCheck constructed from the 'authorizer' and configured with the\n  request resource.\n\nThe `apiVersion`, `kind`, `metadata.name` and `metadata.generateName` are always accessible from the root of the object. No other metadata properties are accessible.\n\nOnly property names of the form `[a-zA-Z_.-/][a-zA-Z0-9_.-/]*` are accessible. Accessible property names are escaped according to the following rules when accessed in the expression: - '__' escapes to '__underscores__' - '.' escapes to '__dot__' - '-' escapes to '__dash__' - '/' escapes to '__slash__' - Property names that exactly match a CEL RESERVED keyword escape to '__{keyword}__'. The keywords are:\n\t  \"true\", \"false\", \"null\", \"in\", \"as\", \"break\", \"const\", \"continue\", \"else\", \"for\", \"function\", \"if\",\n\t  \"import\", \"let\", \"loop\", \"package\", \"namespace\", \"return\".\nExamples:\n  - Expression accessing a property named \"namespace\": {\"Expression\": \"object.__namespace__ \u003e 0\"}\n  - Expression accessing a property named \"x-prop\": {\"Expression\": \"object.x__dash__prop \u003e 0\"}\n  - Expression accessing a property named \"redact__d\": {\"Expression\": \"object.redact__underscores__d \u003e 0\"}\n\nEquality on arrays with list type of 'set' or 'map' ignores element order, i.e. [1, 2] == [2, 1]. Concatenation on arrays with x-kubernetes-list-type use the semantics of the list type:\n  - 'set': `X + Y` performs a union where the array positions of all elements in `X` are preserved and\n    non-intersecting elements in `Y` are appended, retaining their partial order.\n  - 'map': `X + Y` performs a merge where the array positions of all keys in `X` are preserved but the values\n    are overwritten by values in `Y` when the key sets of `X` and `Y` intersect. Elements in `Y` with\n    non-intersecting keys are appended, retaining their partial order.\nRequired.",
            "type": "string",
            "default": ""
          },
          "message": {
            "description": "Message represents the message displayed when validation fails. The message is required if the Expression contains line breaks. The message must not contain line breaks. If unset, the message is \"failed rule: {Rule}\". e.g. \"must be a URL with the host matching spec.host\" If the Expression contains line breaks. Message is required. The message must not contain line breaks. If unset, the message is \"failed Expression: {Expression}\".",
            "type": "string"
          },
          "messageExpression": {
            "description": "messageExpression declares a CEL expression that evaluates to the validation failure message that is returned when this rule fails. Since messageExpression is used as a failure message, it must evaluate to a string. If both message and messageExpression are present on a validation, then messageExpression will be used if validation fails. If messageExpression results in a runtime error, the runtime error is logged, and the validation failure message is produced as if the messageExpression field were unset. If messageExpression evaluates to an empty string, a string with only spaces, or a string that contains line breaks, then the validation failure message will also be produced as if the messageExpression field were unset, and the fact that messageExpression produced an empty string/string with only spaces/string with line breaks will be logged. messageExpression has access to all the same variables as the `expression` except for 'authorizer' and 'authorizer.requestResource'. Example: \"object.x must be less than max (\"+string(params.max)+\")\"",
            "type": "string"
          },
          "reason": {
            "description": "Reason represents a machine-readable description of why this validation failed. If this is the first validation in the list to fail, this reason, as well as the corresponding HTTP response code, are used in the HTTP response to the client. The currently supported reasons are: \"Unauthorized\", \"Forbidden\", \"Invalid\", \"RequestEntityTooLarge\". If not set, StatusReasonInvalid is used in the response to the client.",
            "type": "string"
          }
        }
      },
      "io.k8s.api.admissionregistration.v1alpha1.Variable": {
        "description": "Variable is the definition of a variable that is used for composition.",
        "type": "object",
        "required": ["name", "expression"],
        "properties": {
          "expression": {
            "description": "Expression is the expression that will be evaluated as the value of the variable. The CEL expression has access to the same identifiers as the CEL expressions in Validation.",
            "type": "string",
            "default": ""
          },
          "name": {
            "description": "Name is the name of the variable. The name must be a valid CEL identifier and unique among all variables. The variable can be accessed in other expressions through `variables` For example, if name is \"foo\", the variable will be available as `variables.foo`",
            "type": "string",
            "default": ""
          }
        }
      },
      "io.k8s.api.authentication.v1.BoundObjectReference": {
        "description": "BoundObjectReference is a reference to an object that a token is bound to.",
        "type": "object",
        "properties": {
          "apiVersion": {
            "description": "API version of the referent.",
            "type": "string"
          },
          "kind": {
            "description": "Kind of the referent. Valid kinds are 'Pod' and 'Secret'.",
            "type": "string"
          },
          "name": { "description": "Name of the referent.", "type": "string" },
          "uid": { "description": "UID of the referent.", "type": "string" }
        }
      },
      "io.k8s.api.authentication.v1.SelfSubjectReview": {
        "description": "SelfSubjectReview contains the user information that the kube-apiserver has about the user making this request. When using impersonation, users will receive the user info of the user being impersonated.  If impersonation or request header authentication is used, any extra keys will have their case ignored and returned as lowercase.",
        "type": "object",
        "properties": {
          "apiVersion": {
            "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
            "type": "string"
          },
          "kind": {
            "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
            "type": "string"
          },
          "metadata": {
            "description": "Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata",
            "default": {},
            "allOf": [
              {
                "$ref": "#/components/schemas/io.k8s.apimachinery.pkg.apis.meta.v1.ObjectMeta"
              }
            ]
          },
          "status": {
            "description": "Status is filled in by the server with the user attributes.",
            "default": {},
            "allOf": [
              {
                "$ref": "#/components/schemas/io.k8s.api.authentication.v1.SelfSubjectReviewStatus"
              }
            ]
          }
        },
        "x-kubernetes-group-version-kind": [
          {
            "group": "authentication.k8s.io",
            "kind": "SelfSubjectReview",
            "version": "v1"
          }
        ]
      },
      "io.k8s.api.authentication.v1.SelfSubjectReviewStatus": {
        "description": "SelfSubjectReviewStatus is filled by the kube-apiserver and sent back to a user.",
        "type": "object",
        "properties": {
          "userInfo": {
            "description": "User attributes of the user making this request.",
            "default": {},
            "allOf": [
              {
                "$ref": "#/components/schemas/io.k8s.api.authentication.v1.UserInfo"
              }
            ]
          }
        }
      },
      "io.k8s.api.authentication.v1.TokenRequest": {
        "description": "TokenRequest requests a token for a given service account.",
        "type": "object",
        "required": ["spec"],
        "properties": {
          "apiVersion": {
            "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
            "type": "string"
          },
          "kind": {
            "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
            "type": "string"
          },
          "metadata": {
            "description": "Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata",
            "default": {},
            "allOf": [
              {
                "$ref": "#/components/schemas/io.k8s.apimachinery.pkg.apis.meta.v1.ObjectMeta"
              }
            ]
          },
          "spec": {
            "description": "Spec holds information about the request being evaluated",
            "default": {},
            "allOf": [
              {
                "$ref": "#/components/schemas/io.k8s.api.authentication.v1.TokenRequestSpec"
              }
            ]
          },
          "status": {
            "description": "Status is filled in by the server and indicates whether the token can be authenticated.",
            "default": {},
            "allOf": [
              {
                "$ref": "#/components/schemas/io.k8s.api.authentication.v1.TokenRequestStatus"
              }
            ]
          }
        },
        "x-kubernetes-group-version-kind": [
          {
            "group": "authentication.k8s.io",
            "kind": "TokenRequest",
            "version": "v1"
          }
        ]
      },
      "io.k8s.api.authentication.v1.TokenRequestSpec": {
        "description": "TokenRequestSpec contains client provided parameters of a token request.",
        "type": "object",
        "required": ["audiences"],
        "properties": {
          "audiences": {
            "description": "Audiences are the intendend audiences of the token. A recipient of a token must identify themself with an identifier in the list of audiences of the token, and otherwise should reject the token. A token issued for multiple audiences may be used to authenticate against any of the audiences listed but implies a high degree of trust between the target audiences.",
            "type": "array",
            "items": { "type": "string", "default": "" },
            "x-kubernetes-list-type": "atomic"
          },
          "boundObjectRef": {
            "description": "BoundObjectRef is a reference to an object that the token will be bound to. The token will only be valid for as long as the bound object exists. NOTE: The API server's TokenReview endpoint will validate the BoundObjectRef, but other audiences may not. Keep ExpirationSeconds small if you want prompt revocation.",
            "allOf": [
              {
                "$ref": "#/components/schemas/io.k8s.api.authentication.v1.BoundObjectReference"
              }
            ]
          },
          "expirationSeconds": {
            "description": "ExpirationSeconds is the requested duration of validity of the request. The token issuer may return a token with a different validity duration so a client needs to check the 'expiration' field in a response.",
            "type": "integer",
            "format": "int64"
          }
        }
      },
      "io.k8s.api.authentication.v1.TokenRequestStatus": {
        "description": "TokenRequestStatus is the result of a token request.",
        "type": "object",
        "required": ["token", "expirationTimestamp"],
        "properties": {
          "expirationTimestamp": {
            "description": "ExpirationTimestamp is the time of expiration of the returned token.",
            "allOf": [
              {
                "$ref": "#/components/schemas/io.k8s.apimachinery.pkg.apis.meta.v1.Time"
              }
            ]
          },
          "token": {
            "description": "Token is the opaque bearer token.",
            "type": "string",
            "default": ""
          }
        }
      },
      "io.k8s.api.authentication.v1.TokenReview": {
        "description": "TokenReview attempts to authenticate a token to a known user. Note: TokenReview requests may be cached by the webhook token authenticator plugin in the kube-apiserver.",
        "type": "object",
        "required": ["spec"],
        "properties": {
          "apiVersion": {
            "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
            "type": "string"
          },
          "kind": {
            "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
            "type": "string"
          },
          "metadata": {
            "description": "Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata",
            "default": {},
            "allOf": [
              {
                "$ref": "#/components/schemas/io.k8s.apimachinery.pkg.apis.meta.v1.ObjectMeta"
              }
            ]
          },
          "spec": {
            "description": "Spec holds information about the request being evaluated",
            "default": {},
            "allOf": [
              {
                "$ref": "#/components/schemas/io.k8s.api.authentication.v1.TokenReviewSpec"
              }
            ]
          },
          "status": {
            "description": "Status is filled in by the server and indicates whether the request can be authenticated.",
            "default": {},
            "allOf": [
              {
                "$ref": "#/components/schemas/io.k8s.api.authentication.v1.TokenReviewStatus"
              }
            ]
          }
        },
        "x-kubernetes-group-version-kind": [
          {
            "group": "authentication.k8s.io",
            "kind": "TokenReview",
            "version": "v1"
          }
        ]
      },
      "io.k8s.api.authentication.v1.TokenReviewSpec": {
        "description": "TokenReviewSpec is a description of the token authentication request.",
        "type": "object",
        "properties": {
          "audiences": {
            "description": "Audiences is a list of the identifiers that the resource server presented with the token identifies as. Audience-aware token authenticators will verify that the token was intended for at least one of the audiences in this list. If no audiences are provided, the audience will default to the audience of the Kubernetes apiserver.",
            "type": "array",
            "items": { "type": "string", "default": "" },
            "x-kubernetes-list-type": "atomic"
          },
          "token": {
            "description": "Token is the opaque bearer token.",
            "type": "string"
          }
        }
      },
      "io.k8s.api.authentication.v1.TokenReviewStatus": {
        "description": "TokenReviewStatus is the result of the token authentication request.",
        "type": "object",
        "properties": {
          "audiences": {
            "description": "Audiences are audience identifiers chosen by the authenticator that are compatible with both the TokenReview and token. An identifier is any identifier in the intersection of the TokenReviewSpec audiences and the token's audiences. A client of the TokenReview API that sets the spec.audiences field should validate that a compatible audience identifier is returned in the status.audiences field to ensure that the TokenReview server is audience aware. If a TokenReview returns an empty status.audience field where status.authenticated is \"true\", the token is valid against the audience of the Kubernetes API server.",
            "type": "array",
            "items": { "type": "string", "default": "" },
            "x-kubernetes-list-type": "atomic"
          },
          "authenticated": {
            "description": "Authenticated indicates that the token was associated with a known user.",
            "type": "boolean"
          },
          "error": {
            "description": "Error indicates that the token couldn't be checked",
            "type": "string"
          },
          "user": {
            "description": "User is the UserInfo associated with the provided token.",
            "default": {},
            "allOf": [
              {
                "$ref": "#/components/schemas/io.k8s.api.authentication.v1.UserInfo"
              }
            ]
          }
        }
      },
      "io.k8s.api.authentication.v1.UserInfo": {
        "description": "UserInfo holds the information about the user needed to implement the user.Info interface.",
        "type": "object",
        "properties": {
          "extra": {
            "description": "Any additional information provided by the authenticator.",
            "type": "object",
            "additionalProperties": {
              "type": "array",
              "items": { "type": "string", "default": "" }
            }
          },
          "groups": {
            "description": "The names of groups this user is a part of.",
            "type": "array",
            "items": { "type": "string", "default": "" },
            "x-kubernetes-list-type": "atomic"
          },
          "uid": {
            "description": "A unique value that identifies this user across time. If this user is deleted and another user by the same name is added, they will have different UIDs.",
            "type": "string"
          },
          "username": {
            "description": "The name that uniquely identifies this user among all active users.",
            "type": "string"
          }
        }
      },
      "io.k8s.api.authorization.v1.FieldSelectorAttributes": {
        "description": "FieldSelectorAttributes indicates a field limited access. Webhook authors are encouraged to * ensure rawSelector and requirements are not both set * consider the requirements field if set * not try to parse or consider the rawSelector field if set. This is to avoid another CVE-2022-2880 (i.e. getting different systems to agree on how exactly to parse a query is not something we want), see https://www.oxeye.io/resources/golang-parameter-smuggling-attack for more details. For the *SubjectAccessReview endpoints of the kube-apiserver: * If rawSelector is empty and requirements are empty, the request is not limited. * If rawSelector is present and requirements are empty, the rawSelector will be parsed and limited if the parsing succeeds. * If rawSelector is empty and requirements are present, the requirements should be honored * If rawSelector is present and requirements are present, the request is invalid.",
        "type": "object",
        "properties": {
          "rawSelector": {
            "description": "rawSelector is the serialization of a field selector that would be included in a query parameter. Webhook implementations are encouraged to ignore rawSelector. The kube-apiserver's *SubjectAccessReview will parse the rawSelector as long as the requirements are not present.",
            "type": "string"
          },
          "requirements": {
            "description": "requirements is the parsed interpretation of a field selector. All requirements must be met for a resource instance to match the selector. Webhook implementations should handle requirements, but how to handle them is up to the webhook. Since requirements can only limit the request, it is safe to authorize as unlimited request if the requirements are not understood.",
            "type": "array",
            "items": {
              "default": {},
              "allOf": [
                {
                  "$ref": "#/components/schemas/io.k8s.apimachinery.pkg.apis.meta.v1.FieldSelectorRequirement"
                }
              ]
            },
            "x-kubernetes-list-type": "atomic"
          }
        }
      },
      "io.k8s.api.authorization.v1.LabelSelectorAttributes": {
        "description": "LabelSelectorAttributes indicates a label limited access. Webhook authors are encouraged to * ensure rawSelector and requirements are not both set * consider the requirements field if set * not try to parse or consider the rawSelector field if set. This is to avoid another CVE-2022-2880 (i.e. getting different systems to agree on how exactly to parse a query is not something we want), see https://www.oxeye.io/resources/golang-parameter-smuggling-attack for more details. For the *SubjectAccessReview endpoints of the kube-apiserver: * If rawSelector is empty and requirements are empty, the request is not limited. * If rawSelector is present and requirements are empty, the rawSelector will be parsed and limited if the parsing succeeds. * If rawSelector is empty and requirements are present, the requirements should be honored * If rawSelector is present and requirements are present, the request is invalid.",
        "type": "object",
        "properties": {
          "rawSelector": {
            "description": "rawSelector is the serialization of a field selector that would be included in a query parameter. Webhook implementations are encouraged to ignore rawSelector. The kube-apiserver's *SubjectAccessReview will parse the rawSelector as long as the requirements are not present.",
            "type": "string"
          },
          "requirements": {
            "description": "requirements is the parsed interpretation of a label selector. All requirements must be met for a resource instance to match the selector. Webhook implementations should handle requirements, but how to handle them is up to the webhook. Since requirements can only limit the request, it is safe to authorize as unlimited request if the requirements are not understood.",
            "type": "array",
            "items": {
              "default": {},
              "allOf": [
                {
                  "$ref": "#/components/schemas/io.k8s.apimachinery.pkg.apis.meta.v1.LabelSelectorRequirement"
                }
              ]
            },
            "x-kubernetes-list-type": "atomic"
          }
        }
      },
      "io.k8s.api.authorization.v1.LocalSubjectAccessReview": {
        "description": "LocalSubjectAccessReview checks whether or not a user or group can perform an action in a given namespace. Having a namespace scoped resource makes it much easier to grant namespace scoped policy that includes permissions checking.",
        "type": "object",
        "required": ["spec"],
        "properties": {
          "apiVersion": {
            "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
            "type": "string"
          },
          "kind": {
            "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
            "type": "string"
          },
          "metadata": {
            "description": "Standard list metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata",
            "default": {},
            "allOf": [
              {
                "$ref": "#/components/schemas/io.k8s.apimachinery.pkg.apis.meta.v1.ObjectMeta"
              }
            ]
          },
          "spec": {
            "description": "Spec holds information about the request being evaluated.  spec.namespace must be equal to the namespace you made the request against.  If empty, it is defaulted.",
            "default": {},
            "allOf": [
              {
                "$ref": "#/components/schemas/io.k8s.api.authorization.v1.SubjectAccessReviewSpec"
              }
            ]
          },
          "status": {
            "description": "Status is filled in by the server and indicates whether the request is allowed or not",
            "default": {},
            "allOf": [
              {
                "$ref": "#/components/schemas/io.k8s.api.authorization.v1.SubjectAccessReviewStatus"
              }
            ]
          }
        },
        "x-kubernetes-group-version-kind": [
          {
            "group": "authorization.k8s.io",
            "kind": "LocalSubjectAccessReview",
            "version": "v1"
          }
        ]
      },
      "io.k8s.api.authorization.v1.NonResourceAttributes": {
        "description": "NonResourceAttributes includes the authorization attributes available for non-resource requests to the Authorizer interface",
        "type": "object",
        "properties": {
          "path": {
            "description": "Path is the URL path of the request",
            "type": "string"
          },
          "verb": {
            "description": "Verb is the standard HTTP verb",
            "type": "string"
          }
        }
      },
      "io.k8s.api.authorization.v1.NonResourceRule": {
        "description": "NonResourceRule holds information that describes a rule for the non-resource",
        "type": "object",
        "required": ["verbs"],
        "properties": {
          "nonResourceURLs": {
            "description": "NonResourceURLs is a set of partial urls that a user should have access to.  *s are allowed, but only as the full, final step in the path.  \"*\" means all.",
            "type": "array",
            "items": { "type": "string", "default": "" },
            "x-kubernetes-list-type": "atomic"
          },
          "verbs": {
            "description": "Verb is a list of kubernetes non-resource API verbs, like: get, post, put, delete, patch, head, options.  \"*\" means all.",
            "type": "array",
            "items": { "type": "string", "default": "" },
            "x-kubernetes-list-type": "atomic"
          }
        }
      },
      "io.k8s.api.authorization.v1.ResourceAttributes": {
        "description": "ResourceAttributes includes the authorization attributes available for resource requests to the Authorizer interface",
        "type": "object",
        "properties": {
          "fieldSelector": {
            "description": "fieldSelector describes the limitation on access based on field.  It can only limit access, not broaden it.\n\nThis field  is alpha-level. To use this field, you must enable the `AuthorizeWithSelectors` feature gate (disabled by default).",
            "allOf": [
              {
                "$ref": "#/components/schemas/io.k8s.api.authorization.v1.FieldSelectorAttributes"
              }
            ]
          },
          "group": {
            "description": "Group is the API Group of the Resource.  \"*\" means all.",
            "type": "string"
          },
          "labelSelector": {
            "description": "labelSelector describes the limitation on access based on labels.  It can only limit access, not broaden it.\n\nThis field  is alpha-level. To use this field, you must enable the `AuthorizeWithSelectors` feature gate (disabled by default).",
            "allOf": [
              {
                "$ref": "#/components/schemas/io.k8s.api.authorization.v1.LabelSelectorAttributes"
              }
            ]
          },
          "name": {
            "description": "Name is the name of the resource being requested for a \"get\" or deleted for a \"delete\". \"\" (empty) means all.",
            "type": "string"
          },
          "namespace": {
            "description": "Namespace is the namespace of the action being requested.  Currently, there is no distinction between no namespace and all namespaces \"\" (empty) is defaulted for LocalSubjectAccessReviews \"\" (empty) is empty for cluster-scoped resources \"\" (empty) means \"all\" for namespace scoped resources from a SubjectAccessReview or SelfSubjectAccessReview",
            "type": "string"
          },
          "resource": {
            "description": "Resource is one of the existing resource types.  \"*\" means all.",
            "type": "string"
          },
          "subresource": {
            "description": "Subresource is one of the existing resource types.  \"\" means none.",
            "type": "string"
          },
          "verb": {
            "description": "Verb is a kubernetes resource API verb, like: get, list, watch, create, update, delete, proxy.  \"*\" means all.",
            "type": "string"
          },
          "version": {
            "description": "Version is the API Version of the Resource.  \"*\" means all.",
            "type": "string"
          }
        }
      },
      "io.k8s.api.authorization.v1.ResourceRule": {
        "description": "ResourceRule is the list of actions the subject is allowed to perform on resources. The list ordering isn't significant, may contain duplicates, and possibly be incomplete.",
        "type": "object",
        "required": ["verbs"],
        "properties": {
          "apiGroups": {
            "description": "APIGroups is the name of the APIGroup that contains the resources.  If multiple API groups are specified, any action requested against one of the enumerated resources in any API group will be allowed.  \"*\" means all.",
            "type": "array",
            "items": { "type": "string", "default": "" },
            "x-kubernetes-list-type": "atomic"
          },
          "resourceNames": {
            "description": "ResourceNames is an optional white list of names that the rule applies to.  An empty set means that everything is allowed.  \"*\" means all.",
            "type": "array",
            "items": { "type": "string", "default": "" },
            "x-kubernetes-list-type": "atomic"
          },
          "resources": {
            "description": "Resources is a list of resources this rule applies to.  \"*\" means all in the specified apiGroups.\n \"*/foo\" represents the subresource 'foo' for all resources in the specified apiGroups.",
            "type": "array",
            "items": { "type": "string", "default": "" },
            "x-kubernetes-list-type": "atomic"
          },
          "verbs": {
            "description": "Verb is a list of kubernetes resource API verbs, like: get, list, watch, create, update, delete, proxy.  \"*\" means all.",
            "type": "array",
            "items": { "type": "string", "default": "" },
            "x-kubernetes-list-type": "atomic"
          }
        }
      },
      "io.k8s.api.authorization.v1.SelfSubjectAccessReview": {
        "description": "SelfSubjectAccessReview checks whether or the current user can perform an action.  Not filling in a spec.namespace means \"in all namespaces\".  Self is a special case, because users should always be able to check whether they can perform an action",
        "type": "object",
        "required": ["spec"],
        "properties": {
          "apiVersion": {
            "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
            "type": "string"
          },
          "kind": {
            "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
            "type": "string"
          },
          "metadata": {
            "description": "Standard list metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata",
            "default": {},
            "allOf": [
              {
                "$ref": "#/components/schemas/io.k8s.apimachinery.pkg.apis.meta.v1.ObjectMeta"
              }
            ]
          },
          "spec": {
            "description": "Spec holds information about the request being evaluated.  user and groups must be empty",
            "default": {},
            "allOf": [
              {
                "$ref": "#/components/schemas/io.k8s.api.authorization.v1.SelfSubjectAccessReviewSpec"
              }
            ]
          },
          "status": {
            "description": "Status is filled in by the server and indicates whether the request is allowed or not",
            "default": {},
            "allOf": [
              {
                "$ref": "#/components/schemas/io.k8s.api.authorization.v1.SubjectAccessReviewStatus"
              }
            ]
          }
        },
        "x-kubernetes-group-version-kind": [
          {
            "group": "authorization.k8s.io",
            "kind": "SelfSubjectAccessReview",
            "version": "v1"
          }
        ]
      },
      "io.k8s.api.authorization.v1.SelfSubjectAccessReviewSpec": {
        "description": "SelfSubjectAccessReviewSpec is a description of the access request.  Exactly one of ResourceAuthorizationAttributes and NonResourceAuthorizationAttributes must be set",
        "type": "object",
        "properties": {
          "nonResourceAttributes": {
            "description": "NonResourceAttributes describes information for a non-resource access request",
            "allOf": [
              {
                "$ref": "#/components/schemas/io.k8s.api.authorization.v1.NonResourceAttributes"
              }
            ]
          },
          "resourceAttributes": {
            "description": "ResourceAuthorizationAttributes describes information for a resource access request",
            "allOf": [
              {
                "$ref": "#/components/schemas/io.k8s.api.authorization.v1.ResourceAttributes"
              }
            ]
          }
        }
      },
      "io.k8s.api.authorization.v1.SelfSubjectRulesReview": {
        "description": "SelfSubjectRulesReview enumerates the set of actions the current user can perform within a namespace. The returned list of actions may be incomplete depending on the server's authorization mode, and any errors experienced during the evaluation. SelfSubjectRulesReview should be used by UIs to show/hide actions, or to quickly let an end user reason about their permissions. It should NOT Be used by external systems to drive authorization decisions as this raises confused deputy, cache lifetime/revocation, and correctness concerns. SubjectAccessReview, and LocalAccessReview are the correct way to defer authorization decisions to the API server.",
        "type": "object",
        "required": ["spec"],
        "properties": {
          "apiVersion": {
            "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
            "type": "string"
          },
          "kind": {
            "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
            "type": "string"
          },
          "metadata": {
            "description": "Standard list metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata",
            "default": {},
            "allOf": [
              {
                "$ref": "#/components/schemas/io.k8s.apimachinery.pkg.apis.meta.v1.ObjectMeta"
              }
            ]
          },
          "spec": {
            "description": "Spec holds information about the request being evaluated.",
            "default": {},
            "allOf": [
              {
                "$ref": "#/components/schemas/io.k8s.api.authorization.v1.SelfSubjectRulesReviewSpec"
              }
            ]
          },
          "status": {
            "description": "Status is filled in by the server and indicates the set of actions a user can perform.",
            "default": {},
            "allOf": [
              {
                "$ref": "#/components/schemas/io.k8s.api.authorization.v1.SubjectRulesReviewStatus"
              }
            ]
          }
        },
        "x-kubernetes-group-version-kind": [
          {
            "group": "authorization.k8s.io",
            "kind": "SelfSubjectRulesReview",
            "version": "v1"
          }
        ]
      },
      "io.k8s.api.authorization.v1.SelfSubjectRulesReviewSpec": {
        "description": "SelfSubjectRulesReviewSpec defines the specification for SelfSubjectRulesReview.",
        "type": "object",
        "properties": {
          "namespace": {
            "description": "Namespace to evaluate rules for. Required.",
            "type": "string"
          }
        }
      },
      "io.k8s.api.authorization.v1.SubjectAccessReview": {
        "description": "SubjectAccessReview checks whether or not a user or group can perform an action.",
        "type": "object",
        "required": ["spec"],
        "properties": {
          "apiVersion": {
            "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
            "type": "string"
          },
          "kind": {
            "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
            "type": "string"
          },
          "metadata": {
            "description": "Standard list metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata",
            "default": {},
            "allOf": [
              {
                "$ref": "#/components/schemas/io.k8s.apimachinery.pkg.apis.meta.v1.ObjectMeta"
              }
            ]
          },
          "spec": {
            "description": "Spec holds information about the request being evaluated",
            "default": {},
            "allOf": [
              {
                "$ref": "#/components/schemas/io.k8s.api.authorization.v1.SubjectAccessReviewSpec"
              }
            ]
          },
          "status": {
            "description": "Status is filled in by the server and indicates whether the request is allowed or not",
            "default": {},
            "allOf": [
              {
                "$ref": "#/components/schemas/io.k8s.api.authorization.v1.SubjectAccessReviewStatus"
              }
            ]
          }
        },
        "x-kubernetes-group-version-kind": [
          {
            "group": "authorization.k8s.io",
            "kind": "SubjectAccessReview",
            "version": "v1"
          }
        ]
      },
      "io.k8s.api.authorization.v1.SubjectAccessReviewSpec": {
        "description": "SubjectAccessReviewSpec is a description of the access request.  Exactly one of ResourceAuthorizationAttributes and NonResourceAuthorizationAttributes must be set",
        "type": "object",
        "properties": {
          "extra": {
            "description": "Extra corresponds to the user.Info.GetExtra() method from the authenticator.  Since that is input to the authorizer it needs a reflection here.",
            "type": "object",
            "additionalProperties": {
              "type": "array",
              "items": { "type": "string", "default": "" }
            }
          },
          "groups": {
            "description": "Groups is the groups you're testing for.",
            "type": "array",
            "items": { "type": "string", "default": "" },
            "x-kubernetes-list-type": "atomic"
          },
          "nonResourceAttributes": {
            "description": "NonResourceAttributes describes information for a non-resource access request",
            "allOf": [
              {
                "$ref": "#/components/schemas/io.k8s.api.authorization.v1.NonResourceAttributes"
              }
            ]
          },
          "resourceAttributes": {
            "description": "ResourceAuthorizationAttributes describes information for a resource access request",
            "allOf": [
              {
                "$ref": "#/components/schemas/io.k8s.api.authorization.v1.ResourceAttributes"
              }
            ]
          },
          "uid": {
            "description": "UID information about the requesting user.",
            "type": "string"
          },
          "user": {
            "description": "User is the user you're testing for. If you specify \"User\" but not \"Groups\", then is it interpreted as \"What if User were not a member of any groups",
            "type": "string"
          }
        }
      },
      "io.k8s.api.authorization.v1.SubjectAccessReviewStatus": {
        "description": "SubjectAccessReviewStatus",
        "type": "object",
        "required": ["allowed"],
        "properties": {
          "allowed": {
            "description": "Allowed is required. True if the action would be allowed, false otherwise.",
            "type": "boolean",
            "default": false
          },
          "denied": {
            "description": "Denied is optional. True if the action would be denied, otherwise false. If both allowed is false and denied is false, then the authorizer has no opinion on whether to authorize the action. Denied may not be true if Allowed is true.",
            "type": "boolean"
          },
          "evaluationError": {
            "description": "EvaluationError is an indication that some error occurred during the authorization check. It is entirely possible to get an error and be able to continue determine authorization status in spite of it. For instance, RBAC can be missing a role, but enough roles are still present and bound to reason about the request.",
            "type": "string"
          },
          "reason": {
            "description": "Reason is optional.  It indicates why a request was allowed or denied.",
            "type": "string"
          }
        }
      },
      "io.k8s.api.authorization.v1.SubjectRulesReviewStatus": {
        "description": "SubjectRulesReviewStatus contains the result of a rules check. This check can be incomplete depending on the set of authorizers the server is configured with and any errors experienced during evaluation. Because authorization rules are additive, if a rule appears in a list it's safe to assume the subject has that permission, even if that list is incomplete.",
        "type": "object",
        "required": ["resourceRules", "nonResourceRules", "incomplete"],
        "properties": {
          "evaluationError": {
            "description": "EvaluationError can appear in combination with Rules. It indicates an error occurred during rule evaluation, such as an authorizer that doesn't support rule evaluation, and that ResourceRules and/or NonResourceRules may be incomplete.",
            "type": "string"
          },
          "incomplete": {
            "description": "Incomplete is true when the rules returned by this call are incomplete. This is most commonly encountered when an authorizer, such as an external authorizer, doesn't support rules evaluation.",
            "type": "boolean",
            "default": false
          },
          "nonResourceRules": {
            "description": "NonResourceRules is the list of actions the subject is allowed to perform on non-resources. The list ordering isn't significant, may contain duplicates, and possibly be incomplete.",
            "type": "array",
            "items": {
              "default": {},
              "allOf": [
                {
                  "$ref": "#/components/schemas/io.k8s.api.authorization.v1.NonResourceRule"
                }
              ]
            },
            "x-kubernetes-list-type": "atomic"
          },
          "resourceRules": {
            "description": "ResourceRules is the list of actions the subject is allowed to perform on resources. The list ordering isn't significant, may contain duplicates, and possibly be incomplete.",
            "type": "array",
            "items": {
              "default": {},
              "allOf": [
                {
                  "$ref": "#/components/schemas/io.k8s.api.authorization.v1.ResourceRule"
                }
              ]
            },
            "x-kubernetes-list-type": "atomic"
          }
        }
      },
      "io.k8s.api.certificates.v1.CertificateSigningRequest": {
        "description": "CertificateSigningRequest objects provide a mechanism to obtain x509 certificates by submitting a certificate signing request, and having it asynchronously approved and issued.\n\nKubelets use this API to obtain:\n 1. client certificates to authenticate to kube-apiserver (with the \"kubernetes.io/kube-apiserver-client-kubelet\" signerName).\n 2. serving certificates for TLS endpoints kube-apiserver can connect to securely (with the \"kubernetes.io/kubelet-serving\" signerName).\n\nThis API can be used to request client certificates to authenticate to kube-apiserver (with the \"kubernetes.io/kube-apiserver-client\" signerName), or to obtain certificates from custom non-Kubernetes signers.",
        "type": "object",
        "required": ["spec"],
        "properties": {
          "apiVersion": {
            "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
            "type": "string"
          },
          "kind": {
            "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
            "type": "string"
          },
          "metadata": {
            "default": {},
            "allOf": [
              {
                "$ref": "#/components/schemas/io.k8s.apimachinery.pkg.apis.meta.v1.ObjectMeta"
              }
            ]
          },
          "spec": {
            "description": "spec contains the certificate request, and is immutable after creation. Only the request, signerName, expirationSeconds, and usages fields can be set on creation. Other fields are derived by Kubernetes and cannot be modified by users.",
            "default": {},
            "allOf": [
              {
                "$ref": "#/components/schemas/io.k8s.api.certificates.v1.CertificateSigningRequestSpec"
              }
            ]
          },
          "status": {
            "description": "status contains information about whether the request is approved or denied, and the certificate issued by the signer, or the failure condition indicating signer failure.",
            "default": {},
            "allOf": [
              {
                "$ref": "#/components/schemas/io.k8s.api.certificates.v1.CertificateSigningRequestStatus"
              }
            ]
          }
        },
        "x-kubernetes-group-version-kind": [
          {
            "group": "certificates.k8s.io",
            "kind": "CertificateSigningRequest",
            "version": "v1"
          }
        ]
      },
      "io.k8s.api.certificates.v1.CertificateSigningRequestCondition": {
        "description": "CertificateSigningRequestCondition describes a condition of a CertificateSigningRequest object",
        "type": "object",
        "required": ["type", "status"],
        "properties": {
          "lastTransitionTime": {
            "description": "lastTransitionTime is the time the condition last transitioned from one status to another. If unset, when a new condition type is added or an existing condition's status is changed, the server defaults this to the current time.",
            "allOf": [
              {
                "$ref": "#/components/schemas/io.k8s.apimachinery.pkg.apis.meta.v1.Time"
              }
            ]
          },
          "lastUpdateTime": {
            "description": "lastUpdateTime is the time of the last update to this condition",
            "allOf": [
              {
                "$ref": "#/components/schemas/io.k8s.apimachinery.pkg.apis.meta.v1.Time"
              }
            ]
          },
          "message": {
            "description": "message contains a human readable message with details about the request state",
            "type": "string"
          },
          "reason": {
            "description": "reason indicates a brief reason for the request state",
            "type": "string"
          },
          "status": {
            "description": "status of the condition, one of True, False, Unknown. Approved, Denied, and Failed conditions may not be \"False\" or \"Unknown\".",
            "type": "string",
            "default": ""
          },
          "type": {
            "description": "type of the condition. Known conditions are \"Approved\", \"Denied\", and \"Failed\".\n\nAn \"Approved\" condition is added via the /approval subresource, indicating the request was approved and should be issued by the signer.\n\nA \"Denied\" condition is added via the /approval subresource, indicating the request was denied and should not be issued by the signer.\n\nA \"Failed\" condition is added via the /status subresource, indicating the signer failed to issue the certificate.\n\nApproved and Denied conditions are mutually exclusive. Approved, Denied, and Failed conditions cannot be removed once added.\n\nOnly one condition of a given type is allowed.",
            "type": "string",
            "default": ""
          }
        }
      },
      "io.k8s.api.certificates.v1.CertificateSigningRequestList": {
        "description": "CertificateSigningRequestList is a collection of CertificateSigningRequest objects",
        "type": "object",
        "required": ["items"],
        "properties": {
          "apiVersion": {
            "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
            "type": "string"
          },
          "items": {
            "description": "items is a collection of CertificateSigningRequest objects",
            "type": "array",
            "items": {
              "default": {},
              "allOf": [
                {
                  "$ref": "#/components/schemas/io.k8s.api.certificates.v1.CertificateSigningRequest"
                }
              ]
            }
          },
          "kind": {
            "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
            "type": "string"
          },
          "metadata": {
            "default": {},
            "allOf": [
              {
                "$ref": "#/components/schemas/io.k8s.apimachinery.pkg.apis.meta.v1.ListMeta"
              }
            ]
          }
        },
        "x-kubernetes-group-version-kind": [
          {
            "group": "certificates.k8s.io",
            "kind": "CertificateSigningRequestList",
            "version": "v1"
          }
        ]
      },
      "io.k8s.api.certificates.v1.CertificateSigningRequestSpec": {
        "description": "CertificateSigningRequestSpec contains the certificate request.",
        "type": "object",
        "required": ["request", "signerName"],
        "properties": {
          "expirationSeconds": {
            "description": "expirationSeconds is the requested duration of validity of the issued certificate. The certificate signer may issue a certificate with a different validity duration so a client must check the delta between the notBefore and and notAfter fields in the issued certificate to determine the actual duration.\n\nThe v1.22+ in-tree implementations of the well-known Kubernetes signers will honor this field as long as the requested duration is not greater than the maximum duration they will honor per the --cluster-signing-duration CLI flag to the Kubernetes controller manager.\n\nCertificate signers may not honor this field for various reasons:\n\n  1. Old signer that is unaware of the field (such as the in-tree\n     implementations prior to v1.22)\n  2. Signer whose configured maximum is shorter than the requested duration\n  3. Signer whose configured minimum is longer than the requested duration\n\nThe minimum valid value for expirationSeconds is 600, i.e. 10 minutes.",
            "type": "integer",
            "format": "int32"
          },
          "extra": {
            "description": "extra contains extra attributes of the user that created the CertificateSigningRequest. Populated by the API server on creation and immutable.",
            "type": "object",
            "additionalProperties": {
              "type": "array",
              "items": { "type": "string", "default": "" }
            }
          },
          "groups": {
            "description": "groups contains group membership of the user that created the CertificateSigningRequest. Populated by the API server on creation and immutable.",
            "type": "array",
            "items": { "type": "string", "default": "" },
            "x-kubernetes-list-type": "atomic"
          },
          "request": {
            "description": "request contains an x509 certificate signing request encoded in a \"CERTIFICATE REQUEST\" PEM block. When serialized as JSON or YAML, the data is additionally base64-encoded.",
            "type": "string",
            "format": "byte",
            "x-kubernetes-list-type": "atomic"
          },
          "signerName": {
            "description": "signerName indicates the requested signer, and is a qualified name.\n\nList/watch requests for CertificateSigningRequests can filter on this field using a \"spec.signerName=NAME\" fieldSelector.\n\nWell-known Kubernetes signers are:\n 1. \"kubernetes.io/kube-apiserver-client\": issues client certificates that can be used to authenticate to kube-apiserver.\n  Requests for this signer are never auto-approved by kube-controller-manager, can be issued by the \"csrsigning\" controller in kube-controller-manager.\n 2. \"kubernetes.io/kube-apiserver-client-kubelet\": issues client certificates that kubelets use to authenticate to kube-apiserver.\n  Requests for this signer can be auto-approved by the \"csrapproving\" controller in kube-controller-manager, and can be issued by the \"csrsigning\" controller in kube-controller-manager.\n 3. \"kubernetes.io/kubelet-serving\" issues serving certificates that kubelets use to serve TLS endpoints, which kube-apiserver can connect to securely.\n  Requests for this signer are never auto-approved by kube-controller-manager, and can be issued by the \"csrsigning\" controller in kube-controller-manager.\n\nMore details are available at https://k8s.io/docs/reference/access-authn-authz/certificate-signing-requests/#kubernetes-signers\n\nCustom signerNames can also be specified. The signer defines:\n 1. Trust distribution: how trust (CA bundles) are distributed.\n 2. Permitted subjects: and behavior when a disallowed subject is requested.\n 3. Required, permitted, or forbidden x509 extensions in the request (including whether subjectAltNames are allowed, which types, restrictions on allowed values) and behavior when a disallowed extension is requested.\n 4. Required, permitted, or forbidden key usages / extended key usages.\n 5. Expiration/certificate lifetime: whether it is fixed by the signer, configurable by the admin.\n 6. Whether or not requests for CA certificates are allowed.",
            "type": "string",
            "default": ""
          },
          "uid": {
            "description": "uid contains the uid of the user that created the CertificateSigningRequest. Populated by the API server on creation and immutable.",
            "type": "string"
          },
          "usages": {
            "description": "usages specifies a set of key usages requested in the issued certificate.\n\nRequests for TLS client certificates typically request: \"digital signature\", \"key encipherment\", \"client auth\".\n\nRequests for TLS serving certificates typically request: \"key encipherment\", \"digital signature\", \"server auth\".\n\nValid values are:\n \"signing\", \"digital signature\", \"content commitment\",\n \"key encipherment\", \"key agreement\", \"data encipherment\",\n \"cert sign\", \"crl sign\", \"encipher only\", \"decipher only\", \"any\",\n \"server auth\", \"client auth\",\n \"code signing\", \"email protection\", \"s/mime\",\n \"ipsec end system\", \"ipsec tunnel\", \"ipsec user\",\n \"timestamping\", \"ocsp signing\", \"microsoft sgc\", \"netscape sgc\"",
            "type": "array",
            "items": {
              "type": "string",
              "default": "",
              "enum": [
                "any",
                "cert sign",
                "client auth",
                "code signing",
                "content commitment",
                "crl sign",
                "data encipherment",
                "decipher only",
                "digital signature",
                "email protection",
                "encipher only",
                "ipsec end system",
                "ipsec tunnel",
                "ipsec user",
                "key agreement",
                "key encipherment",
                "microsoft sgc",
                "netscape sgc",
                "ocsp signing",
                "s/mime",
                "server auth",
                "signing",
                "timestamping"
              ]
            },
            "x-kubernetes-list-type": "atomic"
          },
          "username": {
            "description": "username contains the name of the user that created the CertificateSigningRequest. Populated by the API server on creation and immutable.",
            "type": "string"
          }
        }
      },
      "io.k8s.api.certificates.v1.CertificateSigningRequestStatus": {
        "description": "CertificateSigningRequestStatus contains conditions used to indicate approved/denied/failed status of the request, and the issued certificate.",
        "type": "object",
        "properties": {
          "certificate": {
            "description": "certificate is populated with an issued certificate by the signer after an Approved condition is present. This field is set via the /status subresource. Once populated, this field is immutable.\n\nIf the certificate signing request is denied, a condition of type \"Denied\" is added and this field remains empty. If the signer cannot issue the certificate, a condition of type \"Failed\" is added and this field remains empty.\n\nValidation requirements:\n 1. certificate must contain one or more PEM blocks.\n 2. All PEM blocks must have the \"CERTIFICATE\" label, contain no headers, and the encoded data\n  must be a BER-encoded ASN.1 Certificate structure as described in section 4 of RFC5280.\n 3. Non-PEM content may appear before or after the \"CERTIFICATE\" PEM blocks and is unvalidated,\n  to allow for explanatory text as described in section 5.2 of RFC7468.\n\nIf more than one PEM block is present, and the definition of the requested spec.signerName does not indicate otherwise, the first block is the issued certificate, and subsequent blocks should be treated as intermediate certificates and presented in TLS handshakes.\n\nThe certificate is encoded in PEM format.\n\nWhen serialized as JSON or YAML, the data is additionally base64-encoded, so it consists of:\n\n    base64(\n    -----BEGIN CERTIFICATE-----\n    ...\n    -----END CERTIFICATE-----\n    )",
            "type": "string",
            "format": "byte",
            "x-kubernetes-list-type": "atomic"
          },
          "conditions": {
            "description": "conditions applied to the request. Known conditions are \"Approved\", \"Denied\", and \"Failed\".",
            "type": "array",
            "items": {
              "default": {},
              "allOf": [
                {
                  "$ref": "#/components/schemas/io.k8s.api.certificates.v1.CertificateSigningRequestCondition"
                }
              ]
            },
            "x-kubernetes-list-map-keys": ["type"],
            "x-kubernetes-list-type": "map"
          }
        }
      },
      "io.k8s.api.coordination.v1.Lease": {
        "description": "Lease defines a lease concept.",
        "type": "object",
        "properties": {
          "apiVersion": {
            "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
            "type": "string"
          },
          "kind": {
            "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
            "type": "string"
          },
          "metadata": {
            "description": "More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata",
            "default": {},
            "allOf": [
              {
                "$ref": "#/components/schemas/io.k8s.apimachinery.pkg.apis.meta.v1.ObjectMeta"
              }
            ]
          },
          "spec": {
            "description": "spec contains the specification of the Lease. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status",
            "default": {},
            "allOf": [
              {
                "$ref": "#/components/schemas/io.k8s.api.coordination.v1.LeaseSpec"
              }
            ]
          }
        },
        "x-kubernetes-group-version-kind": [
          { "group": "coordination.k8s.io", "kind": "Lease", "version": "v1" }
        ]
      },
      "io.k8s.api.coordination.v1.LeaseList": {
        "description": "LeaseList is a list of Lease objects.",
        "type": "object",
        "required": ["items"],
        "properties": {
          "apiVersion": {
            "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
            "type": "string"
          },
          "items": {
            "description": "items is a list of schema objects.",
            "type": "array",
            "items": {
              "default": {},
              "allOf": [
                {
                  "$ref": "#/components/schemas/io.k8s.api.coordination.v1.Lease"
                }
              ]
            }
          },
          "kind": {
            "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
            "type": "string"
          },
          "metadata": {
            "description": "Standard list metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata",
            "default": {},
            "allOf": [
              {
                "$ref": "#/components/schemas/io.k8s.apimachinery.pkg.apis.meta.v1.ListMeta"
              }
            ]
          }
        },
        "x-kubernetes-group-version-kind": [
          {
            "group": "coordination.k8s.io",
            "kind": "LeaseList",
            "version": "v1"
          }
        ]
      },
      "io.k8s.api.coordination.v1.LeaseSpec": {
        "description": "LeaseSpec is a specification of a Lease.",
        "type": "object",
        "properties": {
          "acquireTime": {
            "description": "acquireTime is a time when the current lease was acquired.",
            "allOf": [
              {
                "$ref": "#/components/schemas/io.k8s.apimachinery.pkg.apis.meta.v1.MicroTime"
              }
            ]
          },
          "holderIdentity": {
            "description": "holderIdentity contains the identity of the holder of a current lease. If Coordinated Leader Election is used, the holder identity must be equal to the elected LeaseCandidate.metadata.name field.",
            "type": "string"
          },
          "leaseDurationSeconds": {
            "description": "leaseDurationSeconds is a duration that candidates for a lease need to wait to force acquire it. This is measured against the time of last observed renewTime.",
            "type": "integer",
            "format": "int32"
          },
          "leaseTransitions": {
            "description": "leaseTransitions is the number of transitions of a lease between holders.",
            "type": "integer",
            "format": "int32"
          },
          "preferredHolder": {
            "description": "PreferredHolder signals to a lease holder that the lease has a more optimal holder and should be given up. This field can only be set if Strategy is also set.",
            "type": "string"
          },
          "renewTime": {
            "description": "renewTime is a time when the current holder of a lease has last updated the lease.",
            "allOf": [
              {
                "$ref": "#/components/schemas/io.k8s.apimachinery.pkg.apis.meta.v1.MicroTime"
              }
            ]
          },
          "strategy": {
            "description": "Strategy indicates the strategy for picking the leader for coordinated leader election. If the field is not specified, there is no active coordination for this lease. (Alpha) Using this field requires the CoordinatedLeaderElection feature gate to be enabled.",
            "type": "string"
          }
        }
      },
      "io.k8s.api.core.v1.ConfigMap": {
        "description": "ConfigMap holds configuration data for pods to consume.",
        "type": "object",
        "properties": {
          "apiVersion": {
            "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
            "type": "string"
          },
          "binaryData": {
            "description": "BinaryData contains the binary data. Each key must consist of alphanumeric characters, '-', '_' or '.'. BinaryData can contain byte sequences that are not in the UTF-8 range. The keys stored in BinaryData must not overlap with the ones in the Data field, this is enforced during validation process. Using this field will require 1.10+ apiserver and kubelet.",
            "type": "object",
            "additionalProperties": { "type": "string", "format": "byte" }
          },
          "data": {
            "description": "Data contains the configuration data. Each key must consist of alphanumeric characters, '-', '_' or '.'. Values with non-UTF-8 byte sequences must use the BinaryData field. The keys stored in Data must not overlap with the keys in the BinaryData field, this is enforced during validation process.",
            "type": "object",
            "additionalProperties": { "type": "string", "default": "" }
          },
          "immutable": {
            "description": "Immutable, if set to true, ensures that data stored in the ConfigMap cannot be updated (only object metadata can be modified). If not set to true, the field can be modified at any time. Defaulted to nil.",
            "type": "boolean"
          },
          "kind": {
            "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
            "type": "string"
          },
          "metadata": {
            "description": "Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata",
            "default": {},
            "allOf": [
              {
                "$ref": "#/components/schemas/io.k8s.apimachinery.pkg.apis.meta.v1.ObjectMeta"
              }
            ]
          }
        },
        "x-kubernetes-group-version-kind": [
          { "group": "", "kind": "ConfigMap", "version": "v1" }
        ]
      },
      "io.k8s.api.core.v1.ConfigMapList": {
        "description": "ConfigMapList is a resource containing a list of ConfigMap objects.",
        "type": "object",
        "required": ["items"],
        "properties": {
          "apiVersion": {
            "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
            "type": "string"
          },
          "items": {
            "description": "Items is the list of ConfigMaps.",
            "type": "array",
            "items": {
              "default": {},
              "allOf": [
                { "$ref": "#/components/schemas/io.k8s.api.core.v1.ConfigMap" }
              ]
            }
          },
          "kind": {
            "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
            "type": "string"
          },
          "metadata": {
            "description": "More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata",
            "default": {},
            "allOf": [
              {
                "$ref": "#/components/schemas/io.k8s.apimachinery.pkg.apis.meta.v1.ListMeta"
              }
            ]
          }
        },
        "x-kubernetes-group-version-kind": [
          { "group": "", "kind": "ConfigMapList", "version": "v1" }
        ]
      },
      "io.k8s.api.core.v1.Event": {
        "description": "Event is a report of an event somewhere in the cluster.  Events have a limited retention time and triggers and messages may evolve with time.  Event consumers should not rely on the timing of an event with a given Reason reflecting a consistent underlying trigger, or the continued existence of events with that Reason.  Events should be treated as informative, best-effort, supplemental data.",
        "type": "object",
        "required": ["metadata", "involvedObject"],
        "properties": {
          "action": {
            "description": "What action was taken/failed regarding to the Regarding object.",
            "type": "string"
          },
          "apiVersion": {
            "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
            "type": "string"
          },
          "count": {
            "description": "The number of times this event has occurred.",
            "type": "integer",
            "format": "int32"
          },
          "eventTime": {
            "description": "Time when this Event was first observed.",
            "allOf": [
              {
                "$ref": "#/components/schemas/io.k8s.apimachinery.pkg.apis.meta.v1.MicroTime"
              }
            ]
          },
          "firstTimestamp": {
            "description": "The time at which the event was first recorded. (Time of server receipt is in TypeMeta.)",
            "allOf": [
              {
                "$ref": "#/components/schemas/io.k8s.apimachinery.pkg.apis.meta.v1.Time"
              }
            ]
          },
          "involvedObject": {
            "description": "The object that this event is about.",
            "default": {},
            "allOf": [
              {
                "$ref": "#/components/schemas/io.k8s.api.core.v1.ObjectReference"
              }
            ]
          },
          "kind": {
            "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
            "type": "string"
          },
          "lastTimestamp": {
            "description": "The time at which the most recent occurrence of this event was recorded.",
            "allOf": [
              {
                "$ref": "#/components/schemas/io.k8s.apimachinery.pkg.apis.meta.v1.Time"
              }
            ]
          },
          "message": {
            "description": "A human-readable description of the status of this operation.",
            "type": "string"
          },
          "metadata": {
            "description": "Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata",
            "default": {},
            "allOf": [
              {
                "$ref": "#/components/schemas/io.k8s.apimachinery.pkg.apis.meta.v1.ObjectMeta"
              }
            ]
          },
          "reason": {
            "description": "This should be a short, machine understandable string that gives the reason for the transition into the object's current status.",
            "type": "string"
          },
          "related": {
            "description": "Optional secondary object for more complex actions.",
            "allOf": [
              {
                "$ref": "#/components/schemas/io.k8s.api.core.v1.ObjectReference"
              }
            ]
          },
          "reportingComponent": {
            "description": "Name of the controller that emitted this Event, e.g. `kubernetes.io/kubelet`.",
            "type": "string",
            "default": ""
          },
          "reportingInstance": {
            "description": "ID of the controller instance, e.g. `kubelet-xyzf`.",
            "type": "string",
            "default": ""
          },
          "series": {
            "description": "Data about the Event series this event represents or nil if it's a singleton Event.",
            "allOf": [
              { "$ref": "#/components/schemas/io.k8s.api.core.v1.EventSeries" }
            ]
          },
          "source": {
            "description": "The component reporting this event. Should be a short machine understandable string.",
            "default": {},
            "allOf": [
              { "$ref": "#/components/schemas/io.k8s.api.core.v1.EventSource" }
            ]
          },
          "type": {
            "description": "Type of this event (Normal, Warning), new types could be added in the future",
            "type": "string"
          }
        },
        "x-kubernetes-group-version-kind": [
          { "group": "", "kind": "Event", "version": "v1" }
        ]
      },
      "io.k8s.api.core.v1.EventList": {
        "description": "EventList is a list of events.",
        "type": "object",
        "required": ["items"],
        "properties": {
          "apiVersion": {
            "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
            "type": "string"
          },
          "items": {
            "description": "List of events",
            "type": "array",
            "items": {
              "default": {},
              "allOf": [
                { "$ref": "#/components/schemas/io.k8s.api.core.v1.Event" }
              ]
            }
          },
          "kind": {
            "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
            "type": "string"
          },
          "metadata": {
            "description": "Standard list metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
            "default": {},
            "allOf": [
              {
                "$ref": "#/components/schemas/io.k8s.apimachinery.pkg.apis.meta.v1.ListMeta"
              }
            ]
          }
        },
        "x-kubernetes-group-version-kind": [
          { "group": "", "kind": "EventList", "version": "v1" }
        ]
      },
      "io.k8s.api.core.v1.EventSeries": {
        "description": "EventSeries contain information on series of events, i.e. thing that was/is happening continuously for some time.",
        "type": "object",
        "properties": {
          "count": {
            "description": "Number of occurrences in this series up to the last heartbeat time",
            "type": "integer",
            "format": "int32"
          },
          "lastObservedTime": {
            "description": "Time of the last occurrence observed",
            "allOf": [
              {
                "$ref": "#/components/schemas/io.k8s.apimachinery.pkg.apis.meta.v1.MicroTime"
              }
            ]
          }
        }
      },
      "io.k8s.api.core.v1.EventSource": {
        "description": "EventSource contains information for an event.",
        "type": "object",
        "properties": {
          "component": {
            "description": "Component from which the event is generated.",
            "type": "string"
          },
          "host": {
            "description": "Node name on which the event is generated.",
            "type": "string"
          }
        }
      },
      "io.k8s.api.core.v1.LocalObjectReference": {
        "description": "LocalObjectReference contains enough information to let you locate the referenced object inside the same namespace.",
        "type": "object",
        "properties": {
          "name": {
            "description": "Name of the referent. This field is effectively required, but due to backwards compatibility is allowed to be empty. Instances of this type with an empty value here are almost certainly wrong. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names",
            "type": "string",
            "default": ""
          }
        },
        "x-kubernetes-map-type": "atomic"
      },
      "io.k8s.api.core.v1.Namespace": {
        "description": "Namespace provides a scope for Names. Use of multiple namespaces is optional.",
        "type": "object",
        "properties": {
          "apiVersion": {
            "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
            "type": "string"
          },
          "kind": {
            "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
            "type": "string"
          },
          "metadata": {
            "description": "Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata",
            "default": {},
            "allOf": [
              {
                "$ref": "#/components/schemas/io.k8s.apimachinery.pkg.apis.meta.v1.ObjectMeta"
              }
            ]
          },
          "spec": {
            "description": "Spec defines the behavior of the Namespace. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status",
            "default": {},
            "allOf": [
              {
                "$ref": "#/components/schemas/io.k8s.api.core.v1.NamespaceSpec"
              }
            ]
          },
          "status": {
            "description": "Status describes the current status of a Namespace. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status",
            "default": {},
            "allOf": [
              {
                "$ref": "#/components/schemas/io.k8s.api.core.v1.NamespaceStatus"
              }
            ]
          }
        },
        "x-kubernetes-group-version-kind": [
          { "group": "", "kind": "Namespace", "version": "v1" }
        ]
      },
      "io.k8s.api.core.v1.NamespaceCondition": {
        "description": "NamespaceCondition contains details about state of namespace.",
        "type": "object",
        "required": ["type", "status"],
        "properties": {
          "lastTransitionTime": {
            "$ref": "#/components/schemas/io.k8s.apimachinery.pkg.apis.meta.v1.Time"
          },
          "message": { "type": "string" },
          "reason": { "type": "string" },
          "status": {
            "description": "Status of the condition, one of True, False, Unknown.",
            "type": "string",
            "default": ""
          },
          "type": {
            "description": "Type of namespace controller condition.",
            "type": "string",
            "default": ""
          }
        }
      },
      "io.k8s.api.core.v1.NamespaceList": {
        "description": "NamespaceList is a list of Namespaces.",
        "type": "object",
        "required": ["items"],
        "properties": {
          "apiVersion": {
            "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
            "type": "string"
          },
          "items": {
            "description": "Items is the list of Namespace objects in the list. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/",
            "type": "array",
            "items": {
              "default": {},
              "allOf": [
                { "$ref": "#/components/schemas/io.k8s.api.core.v1.Namespace" }
              ]
            }
          },
          "kind": {
            "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
            "type": "string"
          },
          "metadata": {
            "description": "Standard list metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
            "default": {},
            "allOf": [
              {
                "$ref": "#/components/schemas/io.k8s.apimachinery.pkg.apis.meta.v1.ListMeta"
              }
            ]
          }
        },
        "x-kubernetes-group-version-kind": [
          { "group": "", "kind": "NamespaceList", "version": "v1" }
        ]
      },
      "io.k8s.api.core.v1.NamespaceSpec": {
        "description": "NamespaceSpec describes the attributes on a Namespace.",
        "type": "object",
        "properties": {
          "finalizers": {
            "description": "Finalizers is an opaque list of values that must be empty to permanently remove object from storage. More info: https://kubernetes.io/docs/tasks/administer-cluster/namespaces/",
            "type": "array",
            "items": { "type": "string", "default": "" },
            "x-kubernetes-list-type": "atomic"
          }
        }
      },
      "io.k8s.api.core.v1.NamespaceStatus": {
        "description": "NamespaceStatus is information about the current status of a Namespace.",
        "type": "object",
        "properties": {
          "conditions": {
            "description": "Represents the latest available observations of a namespace's current state.",
            "type": "array",
            "items": {
              "default": {},
              "allOf": [
                {
                  "$ref": "#/components/schemas/io.k8s.api.core.v1.NamespaceCondition"
                }
              ]
            },
            "x-kubernetes-list-map-keys": ["type"],
            "x-kubernetes-list-type": "map",
            "x-kubernetes-patch-merge-key": "type",
            "x-kubernetes-patch-strategy": "merge"
          },
          "phase": {
            "description": "Phase is the current lifecycle phase of the namespace. More info: https://kubernetes.io/docs/tasks/administer-cluster/namespaces/\n\nPossible enum values:\n - `\"Active\"` means the namespace is available for use in the system\n - `\"Terminating\"` means the namespace is undergoing graceful termination",
            "type": "string",
            "enum": ["Active", "Terminating"]
          }
        }
      },
      "io.k8s.api.core.v1.ObjectReference": {
        "description": "ObjectReference contains enough information to let you inspect or modify the referred object.",
        "type": "object",
        "properties": {
          "apiVersion": {
            "description": "API version of the referent.",
            "type": "string"
          },
          "fieldPath": {
            "description": "If referring to a piece of an object instead of an entire object, this string should contain a valid JSON/Go field access statement, such as desiredState.manifest.containers[2]. For example, if the object reference is to a container within a pod, this would take on a value like: \"spec.containers{name}\" (where \"name\" refers to the name of the container that triggered the event) or if no container name is specified \"spec.containers[2]\" (container with index 2 in this pod). This syntax is chosen only to have some well-defined way of referencing a part of an object.",
            "type": "string"
          },
          "kind": {
            "description": "Kind of the referent. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
            "type": "string"
          },
          "name": {
            "description": "Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names",
            "type": "string"
          },
          "namespace": {
            "description": "Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/",
            "type": "string"
          },
          "resourceVersion": {
            "description": "Specific resourceVersion to which this reference is made, if any. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#concurrency-control-and-consistency",
            "type": "string"
          },
          "uid": {
            "description": "UID of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#uids",
            "type": "string"
          }
        },
        "x-kubernetes-map-type": "atomic"
      },
      "io.k8s.api.core.v1.ResourceQuota": {
        "description": "ResourceQuota sets aggregate quota restrictions enforced per namespace",
        "type": "object",
        "properties": {
          "apiVersion": {
            "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
            "type": "string"
          },
          "kind": {
            "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
            "type": "string"
          },
          "metadata": {
            "description": "Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata",
            "default": {},
            "allOf": [
              {
                "$ref": "#/components/schemas/io.k8s.apimachinery.pkg.apis.meta.v1.ObjectMeta"
              }
            ]
          },
          "spec": {
            "description": "Spec defines the desired quota. https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status",
            "default": {},
            "allOf": [
              {
                "$ref": "#/components/schemas/io.k8s.api.core.v1.ResourceQuotaSpec"
              }
            ]
          },
          "status": {
            "description": "Status defines the actual enforced quota and its current usage. https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status",
            "default": {},
            "allOf": [
              {
                "$ref": "#/components/schemas/io.k8s.api.core.v1.ResourceQuotaStatus"
              }
            ]
          }
        },
        "x-kubernetes-group-version-kind": [
          { "group": "", "kind": "ResourceQuota", "version": "v1" }
        ]
      },
      "io.k8s.api.core.v1.ResourceQuotaList": {
        "description": "ResourceQuotaList is a list of ResourceQuota items.",
        "type": "object",
        "required": ["items"],
        "properties": {
          "apiVersion": {
            "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
            "type": "string"
          },
          "items": {
            "description": "Items is a list of ResourceQuota objects. More info: https://kubernetes.io/docs/concepts/policy/resource-quotas/",
            "type": "array",
            "items": {
              "default": {},
              "allOf": [
                {
                  "$ref": "#/components/schemas/io.k8s.api.core.v1.ResourceQuota"
                }
              ]
            }
          },
          "kind": {
            "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
            "type": "string"
          },
          "metadata": {
            "description": "Standard list metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
            "default": {},
            "allOf": [
              {
                "$ref": "#/components/schemas/io.k8s.apimachinery.pkg.apis.meta.v1.ListMeta"
              }
            ]
          }
        },
        "x-kubernetes-group-version-kind": [
          { "group": "", "kind": "ResourceQuotaList", "version": "v1" }
        ]
      },
      "io.k8s.api.core.v1.ResourceQuotaSpec": {
        "description": "ResourceQuotaSpec defines the desired hard limits to enforce for Quota.",
        "type": "object",
        "properties": {
          "hard": {
            "description": "hard is the set of desired hard limits for each named resource. More info: https://kubernetes.io/docs/concepts/policy/resource-quotas/",
            "type": "object",
            "additionalProperties": {
              "$ref": "#/components/schemas/io.k8s.apimachinery.pkg.api.resource.Quantity"
            }
          },
          "scopeSelector": {
            "description": "scopeSelector is also a collection of filters like scopes that must match each object tracked by a quota but expressed using ScopeSelectorOperator in combination with possible values. For a resource to match, both scopes AND scopeSelector (if specified in spec), must be matched.",
            "allOf": [
              {
                "$ref": "#/components/schemas/io.k8s.api.core.v1.ScopeSelector"
              }
            ]
          },
          "scopes": {
            "description": "A collection of filters that must match each object tracked by a quota. If not specified, the quota matches all objects.",
            "type": "array",
            "items": {
              "type": "string",
              "default": "",
              "enum": [
                "BestEffort",
                "CrossNamespacePodAffinity",
                "NotBestEffort",
                "NotTerminating",
                "PriorityClass",
                "Terminating"
              ]
            },
            "x-kubernetes-list-type": "atomic"
          }
        }
      },
      "io.k8s.api.core.v1.ResourceQuotaStatus": {
        "description": "ResourceQuotaStatus defines the enforced hard limits and observed use.",
        "type": "object",
        "properties": {
          "hard": {
            "description": "Hard is the set of enforced hard limits for each named resource. More info: https://kubernetes.io/docs/concepts/policy/resource-quotas/",
            "type": "object",
            "additionalProperties": {
              "$ref": "#/components/schemas/io.k8s.apimachinery.pkg.api.resource.Quantity"
            }
          },
          "used": {
            "description": "Used is the current observed total usage of the resource in the namespace.",
            "type": "object",
            "additionalProperties": {
              "$ref": "#/components/schemas/io.k8s.apimachinery.pkg.api.resource.Quantity"
            }
          }
        }
      },
      "io.k8s.api.core.v1.ScopeSelector": {
        "description": "A scope selector represents the AND of the selectors represented by the scoped-resource selector requirements.",
        "type": "object",
        "properties": {
          "matchExpressions": {
            "description": "A list of scope selector requirements by scope of the resources.",
            "type": "array",
            "items": {
              "default": {},
              "allOf": [
                {
                  "$ref": "#/components/schemas/io.k8s.api.core.v1.ScopedResourceSelectorRequirement"
                }
              ]
            },
            "x-kubernetes-list-type": "atomic"
          }
        },
        "x-kubernetes-map-type": "atomic"
      },
      "io.k8s.api.core.v1.ScopedResourceSelectorRequirement": {
        "description": "A scoped-resource selector requirement is a selector that contains values, a scope name, and an operator that relates the scope name and values.",
        "type": "object",
        "required": ["scopeName", "operator"],
        "properties": {
          "operator": {
            "description": "Represents a scope's relationship to a set of values. Valid operators are In, NotIn, Exists, DoesNotExist.\n\nPossible enum values:\n - `\"DoesNotExist\"`\n - `\"Exists\"`\n - `\"In\"`\n - `\"NotIn\"`",
            "type": "string",
            "default": "",
            "enum": ["DoesNotExist", "Exists", "In", "NotIn"]
          },
          "scopeName": {
            "description": "The name of the scope that the selector applies to.\n\nPossible enum values:\n - `\"BestEffort\"` Match all pod objects that have best effort quality of service\n - `\"CrossNamespacePodAffinity\"` Match all pod objects that have cross-namespace pod (anti)affinity mentioned.\n - `\"NotBestEffort\"` Match all pod objects that do not have best effort quality of service\n - `\"NotTerminating\"` Match all pod objects where spec.activeDeadlineSeconds is nil\n - `\"PriorityClass\"` Match all pod objects that have priority class mentioned\n - `\"Terminating\"` Match all pod objects where spec.activeDeadlineSeconds \u003e=0",
            "type": "string",
            "default": "",
            "enum": [
              "BestEffort",
              "CrossNamespacePodAffinity",
              "NotBestEffort",
              "NotTerminating",
              "PriorityClass",
              "Terminating"
            ]
          },
          "values": {
            "description": "An array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.",
            "type": "array",
            "items": { "type": "string", "default": "" },
            "x-kubernetes-list-type": "atomic"
          }
        }
      },
      "io.k8s.api.core.v1.Secret": {
        "description": "Secret holds secret data of a certain type. The total bytes of the values in the Data field must be less than MaxSecretSize bytes.",
        "type": "object",
        "properties": {
          "apiVersion": {
            "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
            "type": "string"
          },
          "data": {
            "description": "Data contains the secret data. Each key must consist of alphanumeric characters, '-', '_' or '.'. The serialized form of the secret data is a base64 encoded string, representing the arbitrary (possibly non-string) data value here. Described in https://tools.ietf.org/html/rfc4648#section-4",
            "type": "object",
            "additionalProperties": { "type": "string", "format": "byte" }
          },
          "immutable": {
            "description": "Immutable, if set to true, ensures that data stored in the Secret cannot be updated (only object metadata can be modified). If not set to true, the field can be modified at any time. Defaulted to nil.",
            "type": "boolean"
          },
          "kind": {
            "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
            "type": "string"
          },
          "metadata": {
            "description": "Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata",
            "default": {},
            "allOf": [
              {
                "$ref": "#/components/schemas/io.k8s.apimachinery.pkg.apis.meta.v1.ObjectMeta"
              }
            ]
          },
          "stringData": {
            "description": "stringData allows specifying non-binary secret data in string form. It is provided as a write-only input field for convenience. All keys and values are merged into the data field on write, overwriting any existing values. The stringData field is never output when reading from the API.",
            "type": "object",
            "additionalProperties": { "type": "string", "default": "" }
          },
          "type": {
            "description": "Used to facilitate programmatic handling of secret data. More info: https://kubernetes.io/docs/concepts/configuration/secret/#secret-types",
            "type": "string"
          }
        },
        "x-kubernetes-group-version-kind": [
          { "group": "", "kind": "Secret", "version": "v1" }
        ]
      },
      "io.k8s.api.core.v1.SecretList": {
        "description": "SecretList is a list of Secret.",
        "type": "object",
        "required": ["items"],
        "properties": {
          "apiVersion": {
            "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
            "type": "string"
          },
          "items": {
            "description": "Items is a list of secret objects. More info: https://kubernetes.io/docs/concepts/configuration/secret",
            "type": "array",
            "items": {
              "default": {},
              "allOf": [
                { "$ref": "#/components/schemas/io.k8s.api.core.v1.Secret" }
              ]
            }
          },
          "kind": {
            "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
            "type": "string"
          },
          "metadata": {
            "description": "Standard list metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
            "default": {},
            "allOf": [
              {
                "$ref": "#/components/schemas/io.k8s.apimachinery.pkg.apis.meta.v1.ListMeta"
              }
            ]
          }
        },
        "x-kubernetes-group-version-kind": [
          { "group": "", "kind": "SecretList", "version": "v1" }
        ]
      },
      "io.k8s.api.core.v1.ServiceAccount": {
        "description": "ServiceAccount binds together: * a name, understood by users, and perhaps by peripheral systems, for an identity * a principal that can be authenticated and authorized * a set of secrets",
        "type": "object",
        "properties": {
          "apiVersion": {
            "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
            "type": "string"
          },
          "automountServiceAccountToken": {
            "description": "AutomountServiceAccountToken indicates whether pods running as this service account should have an API token automatically mounted. Can be overridden at the pod level.",
            "type": "boolean"
          },
          "imagePullSecrets": {
            "description": "ImagePullSecrets is a list of references to secrets in the same namespace to use for pulling any images in pods that reference this ServiceAccount. ImagePullSecrets are distinct from Secrets because Secrets can be mounted in the pod, but ImagePullSecrets are only accessed by the kubelet. More info: https://kubernetes.io/docs/concepts/containers/images/#specifying-imagepullsecrets-on-a-pod",
            "type": "array",
            "items": {
              "default": {},
              "allOf": [
                {
                  "$ref": "#/components/schemas/io.k8s.api.core.v1.LocalObjectReference"
                }
              ]
            },
            "x-kubernetes-list-type": "atomic"
          },
          "kind": {
            "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
            "type": "string"
          },
          "metadata": {
            "description": "Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata",
            "default": {},
            "allOf": [
              {
                "$ref": "#/components/schemas/io.k8s.apimachinery.pkg.apis.meta.v1.ObjectMeta"
              }
            ]
          },
          "secrets": {
            "description": "Secrets is a list of the secrets in the same namespace that pods running using this ServiceAccount are allowed to use. Pods are only limited to this list if this service account has a \"kubernetes.io/enforce-mountable-secrets\" annotation set to \"true\". This field should not be used to find auto-generated service account token secrets for use outside of pods. Instead, tokens can be requested directly using the TokenRequest API, or service account token secrets can be manually created. More info: https://kubernetes.io/docs/concepts/configuration/secret",
            "type": "array",
            "items": {
              "default": {},
              "allOf": [
                {
                  "$ref": "#/components/schemas/io.k8s.api.core.v1.ObjectReference"
                }
              ]
            },
            "x-kubernetes-list-map-keys": ["name"],
            "x-kubernetes-list-type": "map",
            "x-kubernetes-patch-merge-key": "name",
            "x-kubernetes-patch-strategy": "merge"
          }
        },
        "x-kubernetes-group-version-kind": [
          { "group": "", "kind": "ServiceAccount", "version": "v1" }
        ]
      },
      "io.k8s.api.core.v1.ServiceAccountList": {
        "description": "ServiceAccountList is a list of ServiceAccount objects",
        "type": "object",
        "required": ["items"],
        "properties": {
          "apiVersion": {
            "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
            "type": "string"
          },
          "items": {
            "description": "List of ServiceAccounts. More info: https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/",
            "type": "array",
            "items": {
              "default": {},
              "allOf": [
                {
                  "$ref": "#/components/schemas/io.k8s.api.core.v1.ServiceAccount"
                }
              ]
            }
          },
          "kind": {
            "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
            "type": "string"
          },
          "metadata": {
            "description": "Standard list metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
            "default": {},
            "allOf": [
              {
                "$ref": "#/components/schemas/io.k8s.apimachinery.pkg.apis.meta.v1.ListMeta"
              }
            ]
          }
        },
        "x-kubernetes-group-version-kind": [
          { "group": "", "kind": "ServiceAccountList", "version": "v1" }
        ]
      },
      "io.k8s.api.events.v1.Event": {
        "description": "Event is a report of an event somewhere in the cluster. It generally denotes some state change in the system. Events have a limited retention time and triggers and messages may evolve with time.  Event consumers should not rely on the timing of an event with a given Reason reflecting a consistent underlying trigger, or the continued existence of events with that Reason.  Events should be treated as informative, best-effort, supplemental data.",
        "type": "object",
        "required": ["eventTime"],
        "properties": {
          "action": {
            "description": "action is what action was taken/failed regarding to the regarding object. It is machine-readable. This field cannot be empty for new Events and it can have at most 128 characters.",
            "type": "string"
          },
          "apiVersion": {
            "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
            "type": "string"
          },
          "deprecatedCount": {
            "description": "deprecatedCount is the deprecated field assuring backward compatibility with core.v1 Event type.",
            "type": "integer",
            "format": "int32"
          },
          "deprecatedFirstTimestamp": {
            "description": "deprecatedFirstTimestamp is the deprecated field assuring backward compatibility with core.v1 Event type.",
            "allOf": [
              {
                "$ref": "#/components/schemas/io.k8s.apimachinery.pkg.apis.meta.v1.Time"
              }
            ]
          },
          "deprecatedLastTimestamp": {
            "description": "deprecatedLastTimestamp is the deprecated field assuring backward compatibility with core.v1 Event type.",
            "allOf": [
              {
                "$ref": "#/components/schemas/io.k8s.apimachinery.pkg.apis.meta.v1.Time"
              }
            ]
          },
          "deprecatedSource": {
            "description": "deprecatedSource is the deprecated field assuring backward compatibility with core.v1 Event type.",
            "default": {},
            "allOf": [
              { "$ref": "#/components/schemas/io.k8s.api.core.v1.EventSource" }
            ]
          },
          "eventTime": {
            "description": "eventTime is the time when this Event was first observed. It is required.",
            "allOf": [
              {
                "$ref": "#/components/schemas/io.k8s.apimachinery.pkg.apis.meta.v1.MicroTime"
              }
            ]
          },
          "kind": {
            "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
            "type": "string"
          },
          "metadata": {
            "description": "Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata",
            "default": {},
            "allOf": [
              {
                "$ref": "#/components/schemas/io.k8s.apimachinery.pkg.apis.meta.v1.ObjectMeta"
              }
            ]
          },
          "note": {
            "description": "note is a human-readable description of the status of this operation. Maximal length of the note is 1kB, but libraries should be prepared to handle values up to 64kB.",
            "type": "string"
          },
          "reason": {
            "description": "reason is why the action was taken. It is human-readable. This field cannot be empty for new Events and it can have at most 128 characters.",
            "type": "string"
          },
          "regarding": {
            "description": "regarding contains the object this Event is about. In most cases it's an Object reporting controller implements, e.g. ReplicaSetController implements ReplicaSets and this event is emitted because it acts on some changes in a ReplicaSet object.",
            "default": {},
            "allOf": [
              {
                "$ref": "#/components/schemas/io.k8s.api.core.v1.ObjectReference"
              }
            ]
          },
          "related": {
            "description": "related is the optional secondary object for more complex actions. E.g. when regarding object triggers a creation or deletion of related object.",
            "allOf": [
              {
                "$ref": "#/components/schemas/io.k8s.api.core.v1.ObjectReference"
              }
            ]
          },
          "reportingController": {
            "description": "reportingController is the name of the controller that emitted this Event, e.g. `kubernetes.io/kubelet`. This field cannot be empty for new Events.",
            "type": "string"
          },
          "reportingInstance": {
            "description": "reportingInstance is the ID of the controller instance, e.g. `kubelet-xyzf`. This field cannot be empty for new Events and it can have at most 128 characters.",
            "type": "string"
          },
          "series": {
            "description": "series is data about the Event series this event represents or nil if it's a singleton Event.",
            "allOf": [
              {
                "$ref": "#/components/schemas/io.k8s.api.events.v1.EventSeries"
              }
            ]
          },
          "type": {
            "description": "type is the type of this event (Normal, Warning), new types could be added in the future. It is machine-readable. This field cannot be empty for new Events.",
            "type": "string"
          }
        },
        "x-kubernetes-group-version-kind": [
          { "group": "events.k8s.io", "kind": "Event", "version": "v1" }
        ]
      },
      "io.k8s.api.events.v1.EventList": {
        "description": "EventList is a list of Event objects.",
        "type": "object",
        "required": ["items"],
        "properties": {
          "apiVersion": {
            "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
            "type": "string"
          },
          "items": {
            "description": "items is a list of schema objects.",
            "type": "array",
            "items": {
              "default": {},
              "allOf": [
                { "$ref": "#/components/schemas/io.k8s.api.events.v1.Event" }
              ]
            }
          },
          "kind": {
            "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
            "type": "string"
          },
          "metadata": {
            "description": "Standard list metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata",
            "default": {},
            "allOf": [
              {
                "$ref": "#/components/schemas/io.k8s.apimachinery.pkg.apis.meta.v1.ListMeta"
              }
            ]
          }
        },
        "x-kubernetes-group-version-kind": [
          { "group": "events.k8s.io", "kind": "EventList", "version": "v1" }
        ]
      },
      "io.k8s.api.events.v1.EventSeries": {
        "description": "EventSeries contain information on series of events, i.e. thing that was/is happening continuously for some time. How often to update the EventSeries is up to the event reporters. The default event reporter in \"k8s.io/client-go/tools/events/event_broadcaster.go\" shows how this struct is updated on heartbeats and can guide customized reporter implementations.",
        "type": "object",
        "required": ["count", "lastObservedTime"],
        "properties": {
          "count": {
            "description": "count is the number of occurrences in this series up to the last heartbeat time.",
            "type": "integer",
            "format": "int32",
            "default": 0
          },
          "lastObservedTime": {
            "description": "lastObservedTime is the time when last Event from the series was seen before last heartbeat.",
            "allOf": [
              {
                "$ref": "#/components/schemas/io.k8s.apimachinery.pkg.apis.meta.v1.MicroTime"
              }
            ]
          }
        }
      },
      "io.k8s.api.rbac.v1.AggregationRule": {
        "description": "AggregationRule describes how to locate ClusterRoles to aggregate into the ClusterRole",
        "type": "object",
        "properties": {
          "clusterRoleSelectors": {
            "description": "ClusterRoleSelectors holds a list of selectors which will be used to find ClusterRoles and create the rules. If any of the selectors match, then the ClusterRole's permissions will be added",
            "type": "array",
            "items": {
              "default": {},
              "allOf": [
                {
                  "$ref": "#/components/schemas/io.k8s.apimachinery.pkg.apis.meta.v1.LabelSelector"
                }
              ]
            },
            "x-kubernetes-list-type": "atomic"
          }
        }
      },
      "io.k8s.api.rbac.v1.ClusterRole": {
        "description": "ClusterRole is a cluster level, logical grouping of PolicyRules that can be referenced as a unit by a RoleBinding or ClusterRoleBinding.",
        "type": "object",
        "properties": {
          "aggregationRule": {
            "description": "AggregationRule is an optional field that describes how to build the Rules for this ClusterRole. If AggregationRule is set, then the Rules are controller managed and direct changes to Rules will be stomped by the controller.",
            "allOf": [
              {
                "$ref": "#/components/schemas/io.k8s.api.rbac.v1.AggregationRule"
              }
            ]
          },
          "apiVersion": {
            "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
            "type": "string"
          },
          "kind": {
            "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
            "type": "string"
          },
          "metadata": {
            "description": "Standard object's metadata.",
            "default": {},
            "allOf": [
              {
                "$ref": "#/components/schemas/io.k8s.apimachinery.pkg.apis.meta.v1.ObjectMeta"
              }
            ]
          },
          "rules": {
            "description": "Rules holds all the PolicyRules for this ClusterRole",
            "type": "array",
            "items": {
              "default": {},
              "allOf": [
                { "$ref": "#/components/schemas/io.k8s.api.rbac.v1.PolicyRule" }
              ]
            },
            "x-kubernetes-list-type": "atomic"
          }
        },
        "x-kubernetes-group-version-kind": [
          {
            "group": "rbac.authorization.k8s.io",
            "kind": "ClusterRole",
            "version": "v1"
          }
        ]
      },
      "io.k8s.api.rbac.v1.ClusterRoleBinding": {
        "description": "ClusterRoleBinding references a ClusterRole, but not contain it.  It can reference a ClusterRole in the global namespace, and adds who information via Subject.",
        "type": "object",
        "required": ["roleRef"],
        "properties": {
          "apiVersion": {
            "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
            "type": "string"
          },
          "kind": {
            "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
            "type": "string"
          },
          "metadata": {
            "description": "Standard object's metadata.",
            "default": {},
            "allOf": [
              {
                "$ref": "#/components/schemas/io.k8s.apimachinery.pkg.apis.meta.v1.ObjectMeta"
              }
            ]
          },
          "roleRef": {
            "description": "RoleRef can only reference a ClusterRole in the global namespace. If the RoleRef cannot be resolved, the Authorizer must return an error. This field is immutable.",
            "default": {},
            "allOf": [
              { "$ref": "#/components/schemas/io.k8s.api.rbac.v1.RoleRef" }
            ]
          },
          "subjects": {
            "description": "Subjects holds references to the objects the role applies to.",
            "type": "array",
            "items": {
              "default": {},
              "allOf": [
                { "$ref": "#/components/schemas/io.k8s.api.rbac.v1.Subject" }
              ]
            },
            "x-kubernetes-list-type": "atomic"
          }
        },
        "x-kubernetes-group-version-kind": [
          {
            "group": "rbac.authorization.k8s.io",
            "kind": "ClusterRoleBinding",
            "version": "v1"
          }
        ]
      },
      "io.k8s.api.rbac.v1.ClusterRoleBindingList": {
        "description": "ClusterRoleBindingList is a collection of ClusterRoleBindings",
        "type": "object",
        "required": ["items"],
        "properties": {
          "apiVersion": {
            "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
            "type": "string"
          },
          "items": {
            "description": "Items is a list of ClusterRoleBindings",
            "type": "array",
            "items": {
              "default": {},
              "allOf": [
                {
                  "$ref": "#/components/schemas/io.k8s.api.rbac.v1.ClusterRoleBinding"
                }
              ]
            }
          },
          "kind": {
            "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
            "type": "string"
          },
          "metadata": {
            "description": "Standard object's metadata.",
            "default": {},
            "allOf": [
              {
                "$ref": "#/components/schemas/io.k8s.apimachinery.pkg.apis.meta.v1.ListMeta"
              }
            ]
          }
        },
        "x-kubernetes-group-version-kind": [
          {
            "group": "rbac.authorization.k8s.io",
            "kind": "ClusterRoleBindingList",
            "version": "v1"
          }
        ]
      },
      "io.k8s.api.rbac.v1.ClusterRoleList": {
        "description": "ClusterRoleList is a collection of ClusterRoles",
        "type": "object",
        "required": ["items"],
        "properties": {
          "apiVersion": {
            "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
            "type": "string"
          },
          "items": {
            "description": "Items is a list of ClusterRoles",
            "type": "array",
            "items": {
              "default": {},
              "allOf": [
                {
                  "$ref": "#/components/schemas/io.k8s.api.rbac.v1.ClusterRole"
                }
              ]
            }
          },
          "kind": {
            "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
            "type": "string"
          },
          "metadata": {
            "description": "Standard object's metadata.",
            "default": {},
            "allOf": [
              {
                "$ref": "#/components/schemas/io.k8s.apimachinery.pkg.apis.meta.v1.ListMeta"
              }
            ]
          }
        },
        "x-kubernetes-group-version-kind": [
          {
            "group": "rbac.authorization.k8s.io",
            "kind": "ClusterRoleList",
            "version": "v1"
          }
        ]
      },
      "io.k8s.api.rbac.v1.PolicyRule": {
        "description": "PolicyRule holds information that describes a policy rule, but does not contain information about who the rule applies to or which namespace the rule applies to.",
        "type": "object",
        "required": ["verbs"],
        "properties": {
          "apiGroups": {
            "description": "APIGroups is the name of the APIGroup that contains the resources.  If multiple API groups are specified, any action requested against one of the enumerated resources in any API group will be allowed. \"\" represents the core API group and \"*\" represents all API groups.",
            "type": "array",
            "items": { "type": "string", "default": "" },
            "x-kubernetes-list-type": "atomic"
          },
          "nonResourceURLs": {
            "description": "NonResourceURLs is a set of partial urls that a user should have access to.  *s are allowed, but only as the full, final step in the path Since non-resource URLs are not namespaced, this field is only applicable for ClusterRoles referenced from a ClusterRoleBinding. Rules can either apply to API resources (such as \"pods\" or \"secrets\") or non-resource URL paths (such as \"/api\"),  but not both.",
            "type": "array",
            "items": { "type": "string", "default": "" },
            "x-kubernetes-list-type": "atomic"
          },
          "resourceNames": {
            "description": "ResourceNames is an optional white list of names that the rule applies to.  An empty set means that everything is allowed.",
            "type": "array",
            "items": { "type": "string", "default": "" },
            "x-kubernetes-list-type": "atomic"
          },
          "resources": {
            "description": "Resources is a list of resources this rule applies to. '*' represents all resources.",
            "type": "array",
            "items": { "type": "string", "default": "" },
            "x-kubernetes-list-type": "atomic"
          },
          "verbs": {
            "description": "Verbs is a list of Verbs that apply to ALL the ResourceKinds contained in this rule. '*' represents all verbs.",
            "type": "array",
            "items": { "type": "string", "default": "" },
            "x-kubernetes-list-type": "atomic"
          }
        }
      },
      "io.k8s.api.rbac.v1.Role": {
        "description": "Role is a namespaced, logical grouping of PolicyRules that can be referenced as a unit by a RoleBinding.",
        "type": "object",
        "properties": {
          "apiVersion": {
            "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
            "type": "string"
          },
          "kind": {
            "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
            "type": "string"
          },
          "metadata": {
            "description": "Standard object's metadata.",
            "default": {},
            "allOf": [
              {
                "$ref": "#/components/schemas/io.k8s.apimachinery.pkg.apis.meta.v1.ObjectMeta"
              }
            ]
          },
          "rules": {
            "description": "Rules holds all the PolicyRules for this Role",
            "type": "array",
            "items": {
              "default": {},
              "allOf": [
                { "$ref": "#/components/schemas/io.k8s.api.rbac.v1.PolicyRule" }
              ]
            },
            "x-kubernetes-list-type": "atomic"
          }
        },
        "x-kubernetes-group-version-kind": [
          {
            "group": "rbac.authorization.k8s.io",
            "kind": "Role",
            "version": "v1"
          }
        ]
      },
      "io.k8s.api.rbac.v1.RoleBinding": {
        "description": "RoleBinding references a role, but does not contain it.  It can reference a Role in the same namespace or a ClusterRole in the global namespace. It adds who information via Subjects and namespace information by which namespace it exists in.  RoleBindings in a given namespace only have effect in that namespace.",
        "type": "object",
        "required": ["roleRef"],
        "properties": {
          "apiVersion": {
            "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
            "type": "string"
          },
          "kind": {
            "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
            "type": "string"
          },
          "metadata": {
            "description": "Standard object's metadata.",
            "default": {},
            "allOf": [
              {
                "$ref": "#/components/schemas/io.k8s.apimachinery.pkg.apis.meta.v1.ObjectMeta"
              }
            ]
          },
          "roleRef": {
            "description": "RoleRef can reference a Role in the current namespace or a ClusterRole in the global namespace. If the RoleRef cannot be resolved, the Authorizer must return an error. This field is immutable.",
            "default": {},
            "allOf": [
              { "$ref": "#/components/schemas/io.k8s.api.rbac.v1.RoleRef" }
            ]
          },
          "subjects": {
            "description": "Subjects holds references to the objects the role applies to.",
            "type": "array",
            "items": {
              "default": {},
              "allOf": [
                { "$ref": "#/components/schemas/io.k8s.api.rbac.v1.Subject" }
              ]
            },
            "x-kubernetes-list-type": "atomic"
          }
        },
        "x-kubernetes-group-version-kind": [
          {
            "group": "rbac.authorization.k8s.io",
            "kind": "RoleBinding",
            "version": "v1"
          }
        ]
      },
      "io.k8s.api.rbac.v1.RoleBindingList": {
        "description": "RoleBindingList is a collection of RoleBindings",
        "type": "object",
        "required": ["items"],
        "properties": {
          "apiVersion": {
            "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
            "type": "string"
          },
          "items": {
            "description": "Items is a list of RoleBindings",
            "type": "array",
            "items": {
              "default": {},
              "allOf": [
                {
                  "$ref": "#/components/schemas/io.k8s.api.rbac.v1.RoleBinding"
                }
              ]
            }
          },
          "kind": {
            "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
            "type": "string"
          },
          "metadata": {
            "description": "Standard object's metadata.",
            "default": {},
            "allOf": [
              {
                "$ref": "#/components/schemas/io.k8s.apimachinery.pkg.apis.meta.v1.ListMeta"
              }
            ]
          }
        },
        "x-kubernetes-group-version-kind": [
          {
            "group": "rbac.authorization.k8s.io",
            "kind": "RoleBindingList",
            "version": "v1"
          }
        ]
      },
      "io.k8s.api.rbac.v1.RoleList": {
        "description": "RoleList is a collection of Roles",
        "type": "object",
        "required": ["items"],
        "properties": {
          "apiVersion": {
            "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
            "type": "string"
          },
          "items": {
            "description": "Items is a list of Roles",
            "type": "array",
            "items": {
              "default": {},
              "allOf": [
                { "$ref": "#/components/schemas/io.k8s.api.rbac.v1.Role" }
              ]
            }
          },
          "kind": {
            "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
            "type": "string"
          },
          "metadata": {
            "description": "Standard object's metadata.",
            "default": {},
            "allOf": [
              {
                "$ref": "#/components/schemas/io.k8s.apimachinery.pkg.apis.meta.v1.ListMeta"
              }
            ]
          }
        },
        "x-kubernetes-group-version-kind": [
          {
            "group": "rbac.authorization.k8s.io",
            "kind": "RoleList",
            "version": "v1"
          }
        ]
      },
      "io.k8s.api.rbac.v1.RoleRef": {
        "description": "RoleRef contains information that points to the role being used",
        "type": "object",
        "required": ["apiGroup", "kind", "name"],
        "properties": {
          "apiGroup": {
            "description": "APIGroup is the group for the resource being referenced",
            "type": "string",
            "default": ""
          },
          "kind": {
            "description": "Kind is the type of resource being referenced",
            "type": "string",
            "default": ""
          },
          "name": {
            "description": "Name is the name of resource being referenced",
            "type": "string",
            "default": ""
          }
        },
        "x-kubernetes-map-type": "atomic"
      },
      "io.k8s.api.rbac.v1.Subject": {
        "description": "Subject contains a reference to the object or user identities a role binding applies to.  This can either hold a direct API object reference, or a value for non-objects such as user and group names.",
        "type": "object",
        "required": ["kind", "name"],
        "properties": {
          "apiGroup": {
            "description": "APIGroup holds the API group of the referenced subject. Defaults to \"\" for ServiceAccount subjects. Defaults to \"rbac.authorization.k8s.io\" for User and Group subjects.",
            "type": "string"
          },
          "kind": {
            "description": "Kind of object being referenced. Values defined by this API group are \"User\", \"Group\", and \"ServiceAccount\". If the Authorizer does not recognized the kind value, the Authorizer should report an error.",
            "type": "string",
            "default": ""
          },
          "name": {
            "description": "Name of the object being referenced.",
            "type": "string",
            "default": ""
          },
          "namespace": {
            "description": "Namespace of the referenced object.  If the object kind is non-namespace, such as \"User\" or \"Group\", and this value is not empty the Authorizer should report an error.",
            "type": "string"
          }
        },
        "x-kubernetes-map-type": "atomic"
      },
      "io.k8s.apimachinery.pkg.api.resource.Quantity": {
        "description": "Quantity is a fixed-point representation of a number. It provides convenient marshaling/unmarshaling in JSON and YAML, in addition to String() and AsInt64() accessors.\n\nThe serialization format is:\n\n``` \u003cquantity\u003e        ::= \u003csignedNumber\u003e\u003csuffix\u003e\n\n\t(Note that \u003csuffix\u003e may be empty, from the \"\" case in \u003cdecimalSI\u003e.)\n\n\u003cdigit\u003e           ::= 0 | 1 | ... | 9 \u003cdigits\u003e          ::= \u003cdigit\u003e | \u003cdigit\u003e\u003cdigits\u003e \u003cnumber\u003e          ::= \u003cdigits\u003e | \u003cdigits\u003e.\u003cdigits\u003e | \u003cdigits\u003e. | .\u003cdigits\u003e \u003csign\u003e            ::= \"+\" | \"-\" \u003csignedNumber\u003e    ::= \u003cnumber\u003e | \u003csign\u003e\u003cnumber\u003e \u003csuffix\u003e          ::= \u003cbinarySI\u003e | \u003cdecimalExponent\u003e | \u003cdecimalSI\u003e \u003cbinarySI\u003e        ::= Ki | Mi | Gi | Ti | Pi | Ei\n\n\t(International System of units; See: http://physics.nist.gov/cuu/Units/binary.html)\n\n\u003cdecimalSI\u003e       ::= m | \"\" | k | M | G | T | P | E\n\n\t(Note that 1024 = 1Ki but 1000 = 1k; I didn't choose the capitalization.)\n\n\u003cdecimalExponent\u003e ::= \"e\" \u003csignedNumber\u003e | \"E\" \u003csignedNumber\u003e ```\n\nNo matter which of the three exponent forms is used, no quantity may represent a number greater than 2^63-1 in magnitude, nor may it have more than 3 decimal places. Numbers larger or more precise will be capped or rounded up. (E.g.: 0.1m will rounded up to 1m.) This may be extended in the future if we require larger or smaller quantities.\n\nWhen a Quantity is parsed from a string, it will remember the type of suffix it had, and will use the same type again when it is serialized.\n\nBefore serializing, Quantity will be put in \"canonical form\". This means that Exponent/suffix will be adjusted up or down (with a corresponding increase or decrease in Mantissa) such that:\n\n- No precision is lost - No fractional digits will be emitted - The exponent (or suffix) is as large as possible.\n\nThe sign will be omitted unless the number is negative.\n\nExamples:\n\n- 1.5 will be serialized as \"1500m\" - 1.5Gi will be serialized as \"1536Mi\"\n\nNote that the quantity will NEVER be internally represented by a floating point number. That is the whole point of this exercise.\n\nNon-canonical values will still parse as long as they are well formed, but will be re-emitted in their canonical form. (So always use canonical form, or don't diff.)\n\nThis format is intended to make it difficult to use these numbers without writing some sort of special handling code in the hopes that that will cause implementors to also use a fixed point implementation.",
        "oneOf": [{ "type": "string" }, { "type": "number" }]
      },
      "io.k8s.apimachinery.pkg.apis.meta.v1.APIResource": {
        "description": "APIResource specifies the name of a resource and whether it is namespaced.",
        "type": "object",
        "required": ["name", "singularName", "namespaced", "kind", "verbs"],
        "properties": {
          "categories": {
            "description": "categories is a list of the grouped resources this resource belongs to (e.g. 'all')",
            "type": "array",
            "items": { "type": "string", "default": "" },
            "x-kubernetes-list-type": "atomic"
          },
          "group": {
            "description": "group is the preferred group of the resource.  Empty implies the group of the containing resource list. For subresources, this may have a different value, for example: Scale\".",
            "type": "string"
          },
          "kind": {
            "description": "kind is the kind for the resource (e.g. 'Foo' is the kind for a resource 'foo')",
            "type": "string",
            "default": ""
          },
          "name": {
            "description": "name is the plural name of the resource.",
            "type": "string",
            "default": ""
          },
          "namespaced": {
            "description": "namespaced indicates if a resource is namespaced or not.",
            "type": "boolean",
            "default": false
          },
          "shortNames": {
            "description": "shortNames is a list of suggested short names of the resource.",
            "type": "array",
            "items": { "type": "string", "default": "" },
            "x-kubernetes-list-type": "atomic"
          },
          "singularName": {
            "description": "singularName is the singular name of the resource.  This allows clients to handle plural and singular opaquely. The singularName is more correct for reporting status on a single item and both singular and plural are allowed from the kubectl CLI interface.",
            "type": "string",
            "default": ""
          },
          "storageVersionHash": {
            "description": "The hash value of the storage version, the version this resource is converted to when written to the data store. Value must be treated as opaque by clients. Only equality comparison on the value is valid. This is an alpha feature and may change or be removed in the future. The field is populated by the apiserver only if the StorageVersionHash feature gate is enabled. This field will remain optional even if it graduates.",
            "type": "string"
          },
          "verbs": {
            "description": "verbs is a list of supported kube verbs (this includes get, list, watch, create, update, patch, delete, deletecollection, and proxy)",
            "type": "array",
            "items": { "type": "string", "default": "" }
          },
          "version": {
            "description": "version is the preferred version of the resource.  Empty implies the version of the containing resource list For subresources, this may have a different value, for example: v1 (while inside a v1beta1 version of the core resource's group)\".",
            "type": "string"
          }
        }
      },
      "io.k8s.apimachinery.pkg.apis.meta.v1.APIResourceList": {
        "description": "APIResourceList is a list of APIResource, it is used to expose the name of the resources supported in a specific group and version, and if the resource is namespaced.",
        "type": "object",
        "required": ["groupVersion", "resources"],
        "properties": {
          "apiVersion": {
            "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
            "type": "string"
          },
          "groupVersion": {
            "description": "groupVersion is the group and version this APIResourceList is for.",
            "type": "string",
            "default": ""
          },
          "kind": {
            "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
            "type": "string"
          },
          "resources": {
            "description": "resources contains the name of the resources and if they are namespaced.",
            "type": "array",
            "items": {
              "default": {},
              "allOf": [
                {
                  "$ref": "#/components/schemas/io.k8s.apimachinery.pkg.apis.meta.v1.APIResource"
                }
              ]
            },
            "x-kubernetes-list-type": "atomic"
          }
        },
        "x-kubernetes-group-version-kind": [
          { "group": "", "kind": "APIResourceList", "version": "v1" }
        ]
      },
      "io.k8s.apimachinery.pkg.apis.meta.v1.Condition": {
        "description": "Condition contains details for one aspect of the current state of this API Resource.",
        "type": "object",
        "required": [
          "type",
          "status",
          "lastTransitionTime",
          "reason",
          "message"
        ],
        "properties": {
          "lastTransitionTime": {
            "description": "lastTransitionTime is the last time the condition transitioned from one status to another. This should be when the underlying condition changed.  If that is not known, then using the time when the API field changed is acceptable.",
            "allOf": [
              {
                "$ref": "#/components/schemas/io.k8s.apimachinery.pkg.apis.meta.v1.Time"
              }
            ]
          },
          "message": {
            "description": "message is a human readable message indicating details about the transition. This may be an empty string.",
            "type": "string",
            "default": ""
          },
          "observedGeneration": {
            "description": "observedGeneration represents the .metadata.generation that the condition was set based upon. For instance, if .metadata.generation is currently 12, but the .status.conditions[x].observedGeneration is 9, the condition is out of date with respect to the current state of the instance.",
            "type": "integer",
            "format": "int64"
          },
          "reason": {
            "description": "reason contains a programmatic identifier indicating the reason for the condition's last transition. Producers of specific condition types may define expected values and meanings for this field, and whether the values are considered a guaranteed API. The value should be a CamelCase string. This field may not be empty.",
            "type": "string",
            "default": ""
          },
          "status": {
            "description": "status of the condition, one of True, False, Unknown.",
            "type": "string",
            "default": ""
          },
          "type": {
            "description": "type of condition in CamelCase or in foo.example.com/CamelCase.",
            "type": "string",
            "default": ""
          }
        }
      },
      "io.k8s.apimachinery.pkg.apis.meta.v1.DeleteOptions": {
        "description": "DeleteOptions may be provided when deleting an API object.",
        "type": "object",
        "properties": {
          "apiVersion": {
            "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
            "type": "string"
          },
          "dryRun": {
            "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed",
            "type": "array",
            "items": { "type": "string", "default": "" },
            "x-kubernetes-list-type": "atomic"
          },
          "gracePeriodSeconds": {
            "description": "The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.",
            "type": "integer",
            "format": "int64"
          },
          "kind": {
            "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
            "type": "string"
          },
          "orphanDependents": {
            "description": "Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \"orphan\" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both.",
            "type": "boolean"
          },
          "preconditions": {
            "description": "Must be fulfilled before a deletion is carried out. If not possible, a 409 Conflict status will be returned.",
            "allOf": [
              {
                "$ref": "#/components/schemas/io.k8s.apimachinery.pkg.apis.meta.v1.Preconditions"
              }
            ]
          },
          "propagationPolicy": {
            "description": "Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground.",
            "type": "string"
          }
        },
        "x-kubernetes-group-version-kind": [
          { "group": "", "kind": "DeleteOptions", "version": "v1" },
          {
            "group": "admissionregistration.k8s.io",
            "kind": "DeleteOptions",
            "version": "v1"
          },
          {
            "group": "admissionregistration.k8s.io",
            "kind": "DeleteOptions",
            "version": "v1alpha1"
          },
          {
            "group": "admissionregistration.k8s.io",
            "kind": "DeleteOptions",
            "version": "v1beta1"
          },
          { "group": "apps", "kind": "DeleteOptions", "version": "v1" },
          { "group": "apps", "kind": "DeleteOptions", "version": "v1beta1" },
          { "group": "apps", "kind": "DeleteOptions", "version": "v1beta2" },
          {
            "group": "authentication.k8s.io",
            "kind": "DeleteOptions",
            "version": "v1"
          },
          {
            "group": "authentication.k8s.io",
            "kind": "DeleteOptions",
            "version": "v1alpha1"
          },
          {
            "group": "authentication.k8s.io",
            "kind": "DeleteOptions",
            "version": "v1beta1"
          },
          {
            "group": "authorization.k8s.io",
            "kind": "DeleteOptions",
            "version": "v1"
          },
          {
            "group": "authorization.k8s.io",
            "kind": "DeleteOptions",
            "version": "v1beta1"
          },
          { "group": "autoscaling", "kind": "DeleteOptions", "version": "v1" },
          { "group": "autoscaling", "kind": "DeleteOptions", "version": "v2" },
          {
            "group": "autoscaling",
            "kind": "DeleteOptions",
            "version": "v2beta1"
          },
          {
            "group": "autoscaling",
            "kind": "DeleteOptions",
            "version": "v2beta2"
          },
          { "group": "batch", "kind": "DeleteOptions", "version": "v1" },
          { "group": "batch", "kind": "DeleteOptions", "version": "v1beta1" },
          {
            "group": "certificates.k8s.io",
            "kind": "DeleteOptions",
            "version": "v1"
          },
          {
            "group": "certificates.k8s.io",
            "kind": "DeleteOptions",
            "version": "v1alpha1"
          },
          {
            "group": "certificates.k8s.io",
            "kind": "DeleteOptions",
            "version": "v1beta1"
          },
          {
            "group": "coordination.k8s.io",
            "kind": "DeleteOptions",
            "version": "v1"
          },
          {
            "group": "coordination.k8s.io",
            "kind": "DeleteOptions",
            "version": "v1alpha1"
          },
          {
            "group": "coordination.k8s.io",
            "kind": "DeleteOptions",
            "version": "v1beta1"
          },
          {
            "group": "discovery.k8s.io",
            "kind": "DeleteOptions",
            "version": "v1"
          },
          {
            "group": "discovery.k8s.io",
            "kind": "DeleteOptions",
            "version": "v1beta1"
          },
          {
            "group": "events.k8s.io",
            "kind": "DeleteOptions",
            "version": "v1"
          },
          {
            "group": "events.k8s.io",
            "kind": "DeleteOptions",
            "version": "v1beta1"
          },
          {
            "group": "extensions",
            "kind": "DeleteOptions",
            "version": "v1beta1"
          },
          {
            "group": "flowcontrol.apiserver.k8s.io",
            "kind": "DeleteOptions",
            "version": "v1"
          },
          {
            "group": "flowcontrol.apiserver.k8s.io",
            "kind": "DeleteOptions",
            "version": "v1beta1"
          },
          {
            "group": "flowcontrol.apiserver.k8s.io",
            "kind": "DeleteOptions",
            "version": "v1beta2"
          },
          {
            "group": "flowcontrol.apiserver.k8s.io",
            "kind": "DeleteOptions",
            "version": "v1beta3"
          },
          {
            "group": "internal.apiserver.k8s.io",
            "kind": "DeleteOptions",
            "version": "v1alpha1"
          },
          {
            "group": "networking.k8s.io",
            "kind": "DeleteOptions",
            "version": "v1"
          },
          {
            "group": "networking.k8s.io",
            "kind": "DeleteOptions",
            "version": "v1alpha1"
          },
          {
            "group": "networking.k8s.io",
            "kind": "DeleteOptions",
            "version": "v1beta1"
          },
          { "group": "node.k8s.io", "kind": "DeleteOptions", "version": "v1" },
          {
            "group": "node.k8s.io",
            "kind": "DeleteOptions",
            "version": "v1alpha1"
          },
          {
            "group": "node.k8s.io",
            "kind": "DeleteOptions",
            "version": "v1beta1"
          },
          { "group": "policy", "kind": "DeleteOptions", "version": "v1" },
          { "group": "policy", "kind": "DeleteOptions", "version": "v1beta1" },
          {
            "group": "rbac.authorization.k8s.io",
            "kind": "DeleteOptions",
            "version": "v1"
          },
          {
            "group": "rbac.authorization.k8s.io",
            "kind": "DeleteOptions",
            "version": "v1alpha1"
          },
          {
            "group": "rbac.authorization.k8s.io",
            "kind": "DeleteOptions",
            "version": "v1beta1"
          },
          {
            "group": "resource.k8s.io",
            "kind": "DeleteOptions",
            "version": "v1alpha3"
          },
          {
            "group": "scheduling.k8s.io",
            "kind": "DeleteOptions",
            "version": "v1"
          },
          {
            "group": "scheduling.k8s.io",
            "kind": "DeleteOptions",
            "version": "v1alpha1"
          },
          {
            "group": "scheduling.k8s.io",
            "kind": "DeleteOptions",
            "version": "v1beta1"
          },
          {
            "group": "storage.k8s.io",
            "kind": "DeleteOptions",
            "version": "v1"
          },
          {
            "group": "storage.k8s.io",
            "kind": "DeleteOptions",
            "version": "v1alpha1"
          },
          {
            "group": "storage.k8s.io",
            "kind": "DeleteOptions",
            "version": "v1beta1"
          },
          {
            "group": "storagemigration.k8s.io",
            "kind": "DeleteOptions",
            "version": "v1alpha1"
          }
        ]
      },
      "io.k8s.apimachinery.pkg.apis.meta.v1.FieldSelectorRequirement": {
        "description": "FieldSelectorRequirement is a selector that contains values, a key, and an operator that relates the key and values.",
        "type": "object",
        "required": ["key", "operator"],
        "properties": {
          "key": {
            "description": "key is the field selector key that the requirement applies to.",
            "type": "string",
            "default": ""
          },
          "operator": {
            "description": "operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists, DoesNotExist. The list of operators may grow in the future.",
            "type": "string",
            "default": ""
          },
          "values": {
            "description": "values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty.",
            "type": "array",
            "items": { "type": "string", "default": "" },
            "x-kubernetes-list-type": "atomic"
          }
        }
      },
      "io.k8s.apimachinery.pkg.apis.meta.v1.FieldsV1": {
        "description": "FieldsV1 stores a set of fields in a data structure like a Trie, in JSON format.\n\nEach key is either a '.' representing the field itself, and will always map to an empty set, or a string representing a sub-field or item. The string will follow one of these four formats: 'f:\u003cname\u003e', where \u003cname\u003e is the name of a field in a struct, or key in a map 'v:\u003cvalue\u003e', where \u003cvalue\u003e is the exact json formatted value of a list item 'i:\u003cindex\u003e', where \u003cindex\u003e is position of a item in a list 'k:\u003ckeys\u003e', where \u003ckeys\u003e is a map of  a list item's key fields to their unique values If a key maps to an empty Fields value, the field that key represents is part of the set.\n\nThe exact format is defined in sigs.k8s.io/structured-merge-diff",
        "type": "object"
      },
      "io.k8s.apimachinery.pkg.apis.meta.v1.LabelSelector": {
        "description": "A label selector is a label query over a set of resources. The result of matchLabels and matchExpressions are ANDed. An empty label selector matches all objects. A null label selector matches no objects.",
        "type": "object",
        "properties": {
          "matchExpressions": {
            "description": "matchExpressions is a list of label selector requirements. The requirements are ANDed.",
            "type": "array",
            "items": {
              "default": {},
              "allOf": [
                {
                  "$ref": "#/components/schemas/io.k8s.apimachinery.pkg.apis.meta.v1.LabelSelectorRequirement"
                }
              ]
            },
            "x-kubernetes-list-type": "atomic"
          },
          "matchLabels": {
            "description": "matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is \"key\", the operator is \"In\", and the values array contains only \"value\". The requirements are ANDed.",
            "type": "object",
            "additionalProperties": { "type": "string", "default": "" }
          }
        },
        "x-kubernetes-map-type": "atomic"
      },
      "io.k8s.apimachinery.pkg.apis.meta.v1.LabelSelectorRequirement": {
        "description": "A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.",
        "type": "object",
        "required": ["key", "operator"],
        "properties": {
          "key": {
            "description": "key is the label key that the selector applies to.",
            "type": "string",
            "default": ""
          },
          "operator": {
            "description": "operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.",
            "type": "string",
            "default": ""
          },
          "values": {
            "description": "values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.",
            "type": "array",
            "items": { "type": "string", "default": "" },
            "x-kubernetes-list-type": "atomic"
          }
        }
      },
      "io.k8s.apimachinery.pkg.apis.meta.v1.ListMeta": {
        "description": "ListMeta describes metadata that synthetic resources must have, including lists and various status objects. A resource may have only one of {ObjectMeta, ListMeta}.",
        "type": "object",
        "properties": {
          "continue": {
            "description": "continue may be set if the user set a limit on the number of items returned, and indicates that the server has more data available. The value is opaque and may be used to issue another request to the endpoint that served this list to retrieve the next set of available objects. Continuing a consistent list may not be possible if the server configuration has changed or more than a few minutes have passed. The resourceVersion field returned when using this continue value will be identical to the value in the first response, unless you have received this token from an error message.",
            "type": "string"
          },
          "remainingItemCount": {
            "description": "remainingItemCount is the number of subsequent items in the list which are not included in this list response. If the list request contained label or field selectors, then the number of remaining items is unknown and the field will be left unset and omitted during serialization. If the list is complete (either because it is not chunking or because this is the last chunk), then there are no more remaining items and this field will be left unset and omitted during serialization. Servers older than v1.15 do not set this field. The intended use of the remainingItemCount is *estimating* the size of a collection. Clients should not rely on the remainingItemCount to be set or to be exact.",
            "type": "integer",
            "format": "int64"
          },
          "resourceVersion": {
            "description": "String that identifies the server's internal version of this object that can be used by clients to determine when objects have changed. Value must be treated as opaque by clients and passed unmodified back to the server. Populated by the system. Read-only. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#concurrency-control-and-consistency",
            "type": "string"
          },
          "selfLink": {
            "description": "Deprecated: selfLink is a legacy read-only field that is no longer populated by the system.",
            "type": "string"
          }
        }
      },
      "io.k8s.apimachinery.pkg.apis.meta.v1.ManagedFieldsEntry": {
        "description": "ManagedFieldsEntry is a workflow-id, a FieldSet and the group version of the resource that the fieldset applies to.",
        "type": "object",
        "properties": {
          "apiVersion": {
            "description": "APIVersion defines the version of this resource that this field set applies to. The format is \"group/version\" just like the top-level APIVersion field. It is necessary to track the version of a field set because it cannot be automatically converted.",
            "type": "string"
          },
          "fieldsType": {
            "description": "FieldsType is the discriminator for the different fields format and version. There is currently only one possible value: \"FieldsV1\"",
            "type": "string"
          },
          "fieldsV1": {
            "description": "FieldsV1 holds the first JSON version format as described in the \"FieldsV1\" type.",
            "allOf": [
              {
                "$ref": "#/components/schemas/io.k8s.apimachinery.pkg.apis.meta.v1.FieldsV1"
              }
            ]
          },
          "manager": {
            "description": "Manager is an identifier of the workflow managing these fields.",
            "type": "string"
          },
          "operation": {
            "description": "Operation is the type of operation which lead to this ManagedFieldsEntry being created. The only valid values for this field are 'Apply' and 'Update'.",
            "type": "string"
          },
          "subresource": {
            "description": "Subresource is the name of the subresource used to update that object, or empty string if the object was updated through the main resource. The value of this field is used to distinguish between managers, even if they share the same name. For example, a status update will be distinct from a regular update using the same manager name. Note that the APIVersion field is not related to the Subresource field and it always corresponds to the version of the main resource.",
            "type": "string"
          },
          "time": {
            "description": "Time is the timestamp of when the ManagedFields entry was added. The timestamp will also be updated if a field is added, the manager changes any of the owned fields value or removes a field. The timestamp does not update when a field is removed from the entry because another manager took it over.",
            "allOf": [
              {
                "$ref": "#/components/schemas/io.k8s.apimachinery.pkg.apis.meta.v1.Time"
              }
            ]
          }
        }
      },
      "io.k8s.apimachinery.pkg.apis.meta.v1.MicroTime": {
        "description": "MicroTime is version of Time with microsecond level precision.",
        "type": "string",
        "format": "date-time"
      },
      "io.k8s.apimachinery.pkg.apis.meta.v1.ObjectMeta": {
        "description": "ObjectMeta is metadata that all persisted resources must have, which includes all objects users must create.",
        "type": "object",
        "properties": {
          "annotations": {
            "description": "Annotations is an unstructured key value map stored with a resource that may be set by external tools to store and retrieve arbitrary metadata. They are not queryable and should be preserved when modifying objects. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/annotations",
            "type": "object",
            "additionalProperties": { "type": "string", "default": "" }
          },
          "creationTimestamp": {
            "description": "CreationTimestamp is a timestamp representing the server time when this object was created. It is not guaranteed to be set in happens-before order across separate operations. Clients may not set this value. It is represented in RFC3339 form and is in UTC.\n\nPopulated by the system. Read-only. Null for lists. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata",
            "allOf": [
              {
                "$ref": "#/components/schemas/io.k8s.apimachinery.pkg.apis.meta.v1.Time"
              }
            ]
          },
          "deletionGracePeriodSeconds": {
            "description": "Number of seconds allowed for this object to gracefully terminate before it will be removed from the system. Only set when deletionTimestamp is also set. May only be shortened. Read-only.",
            "type": "integer",
            "format": "int64"
          },
          "deletionTimestamp": {
            "description": "DeletionTimestamp is RFC 3339 date and time at which this resource will be deleted. This field is set by the server when a graceful deletion is requested by the user, and is not directly settable by a client. The resource is expected to be deleted (no longer visible from resource lists, and not reachable by name) after the time in this field, once the finalizers list is empty. As long as the finalizers list contains items, deletion is blocked. Once the deletionTimestamp is set, this value may not be unset or be set further into the future, although it may be shortened or the resource may be deleted prior to this time. For example, a user may request that a pod is deleted in 30 seconds. The Kubelet will react by sending a graceful termination signal to the containers in the pod. After that 30 seconds, the Kubelet will send a hard termination signal (SIGKILL) to the container and after cleanup, remove the pod from the API. In the presence of network partitions, this object may still exist after this timestamp, until an administrator or automated process can determine the resource is fully terminated. If not set, graceful deletion of the object has not been requested.\n\nPopulated by the system when a graceful deletion is requested. Read-only. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata",
            "allOf": [
              {
                "$ref": "#/components/schemas/io.k8s.apimachinery.pkg.apis.meta.v1.Time"
              }
            ]
          },
          "finalizers": {
            "description": "Must be empty before the object is deleted from the registry. Each entry is an identifier for the responsible component that will remove the entry from the list. If the deletionTimestamp of the object is non-nil, entries in this list can only be removed. Finalizers may be processed and removed in any order.  Order is NOT enforced because it introduces significant risk of stuck finalizers. finalizers is a shared field, any actor with permission can reorder it. If the finalizer list is processed in order, then this can lead to a situation in which the component responsible for the first finalizer in the list is waiting for a signal (field value, external system, or other) produced by a component responsible for a finalizer later in the list, resulting in a deadlock. Without enforced ordering finalizers are free to order amongst themselves and are not vulnerable to ordering changes in the list.",
            "type": "array",
            "items": { "type": "string", "default": "" },
            "x-kubernetes-list-type": "set",
            "x-kubernetes-patch-strategy": "merge"
          },
          "generateName": {
            "description": "GenerateName is an optional prefix, used by the server, to generate a unique name ONLY IF the Name field has not been provided. If this field is used, the name returned to the client will be different than the name passed. This value will also be combined with a unique suffix. The provided value has the same validation rules as the Name field, and may be truncated by the length of the suffix required to make the value unique on the server.\n\nIf this field is specified and the generated name exists, the server will return a 409.\n\nApplied only if Name is not specified. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#idempotency",
            "type": "string"
          },
          "generation": {
            "description": "A sequence number representing a specific generation of the desired state. Populated by the system. Read-only.",
            "type": "integer",
            "format": "int64"
          },
          "labels": {
            "description": "Map of string keys and values that can be used to organize and categorize (scope and select) objects. May match selectors of replication controllers and services. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/labels",
            "type": "object",
            "additionalProperties": { "type": "string", "default": "" }
          },
          "managedFields": {
            "description": "ManagedFields maps workflow-id and version to the set of fields that are managed by that workflow. This is mostly for internal housekeeping, and users typically shouldn't need to set or understand this field. A workflow can be the user's name, a controller's name, or the name of a specific apply path like \"ci-cd\". The set of fields is always in the version that the workflow used when modifying the object.",
            "type": "array",
            "items": {
              "default": {},
              "allOf": [
                {
                  "$ref": "#/components/schemas/io.k8s.apimachinery.pkg.apis.meta.v1.ManagedFieldsEntry"
                }
              ]
            },
            "x-kubernetes-list-type": "atomic"
          },
          "name": {
            "description": "Name must be unique within a namespace. Is required when creating resources, although some resources may allow a client to request the generation of an appropriate name automatically. Name is primarily intended for creation idempotence and configuration definition. Cannot be updated. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names#names",
            "type": "string"
          },
          "namespace": {
            "description": "Namespace defines the space within which each name must be unique. An empty namespace is equivalent to the \"default\" namespace, but \"default\" is the canonical representation. Not all objects are required to be scoped to a namespace - the value of this field for those objects will be empty.\n\nMust be a DNS_LABEL. Cannot be updated. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces",
            "type": "string"
          },
          "ownerReferences": {
            "description": "List of objects depended by this object. If ALL objects in the list have been deleted, this object will be garbage collected. If this object is managed by a controller, then an entry in this list will point to this controller, with the controller field set to true. There cannot be more than one managing controller.",
            "type": "array",
            "items": {
              "default": {},
              "allOf": [
                {
                  "$ref": "#/components/schemas/io.k8s.apimachinery.pkg.apis.meta.v1.OwnerReference"
                }
              ]
            },
            "x-kubernetes-list-map-keys": ["uid"],
            "x-kubernetes-list-type": "map",
            "x-kubernetes-patch-merge-key": "uid",
            "x-kubernetes-patch-strategy": "merge"
          },
          "resourceVersion": {
            "description": "An opaque value that represents the internal version of this object that can be used by clients to determine when objects have changed. May be used for optimistic concurrency, change detection, and the watch operation on a resource or set of resources. Clients must treat these values as opaque and passed unmodified back to the server. They may only be valid for a particular resource or set of resources.\n\nPopulated by the system. Read-only. Value must be treated as opaque by clients and . More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#concurrency-control-and-consistency",
            "type": "string"
          },
          "selfLink": {
            "description": "Deprecated: selfLink is a legacy read-only field that is no longer populated by the system.",
            "type": "string"
          },
          "uid": {
            "description": "UID is the unique in time and space value for this object. It is typically generated by the server on successful creation of a resource and is not allowed to change on PUT operations.\n\nPopulated by the system. Read-only. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names#uids",
            "type": "string"
          }
        }
      },
      "io.k8s.apimachinery.pkg.apis.meta.v1.OwnerReference": {
        "description": "OwnerReference contains enough information to let you identify an owning object. An owning object must be in the same namespace as the dependent, or be cluster-scoped, so there is no namespace field.",
        "type": "object",
        "required": ["apiVersion", "kind", "name", "uid"],
        "properties": {
          "apiVersion": {
            "description": "API version of the referent.",
            "type": "string",
            "default": ""
          },
          "blockOwnerDeletion": {
            "description": "If true, AND if the owner has the \"foregroundDeletion\" finalizer, then the owner cannot be deleted from the key-value store until this reference is removed. See https://kubernetes.io/docs/concepts/architecture/garbage-collection/#foreground-deletion for how the garbage collector interacts with this field and enforces the foreground deletion. Defaults to false. To set this field, a user needs \"delete\" permission of the owner, otherwise 422 (Unprocessable Entity) will be returned.",
            "type": "boolean"
          },
          "controller": {
            "description": "If true, this reference points to the managing controller.",
            "type": "boolean"
          },
          "kind": {
            "description": "Kind of the referent. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
            "type": "string",
            "default": ""
          },
          "name": {
            "description": "Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names#names",
            "type": "string",
            "default": ""
          },
          "uid": {
            "description": "UID of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names#uids",
            "type": "string",
            "default": ""
          }
        },
        "x-kubernetes-map-type": "atomic"
      },
      "io.k8s.apimachinery.pkg.apis.meta.v1.Patch": {
        "description": "Patch is provided to give a concrete name and type to the Kubernetes PATCH request body.",
        "type": "object"
      },
      "io.k8s.apimachinery.pkg.apis.meta.v1.Preconditions": {
        "description": "Preconditions must be fulfilled before an operation (update, delete, etc.) is carried out.",
        "type": "object",
        "properties": {
          "resourceVersion": {
            "description": "Specifies the target ResourceVersion",
            "type": "string"
          },
          "uid": {
            "description": "Specifies the target UID.",
            "type": "string"
          }
        }
      },
      "io.k8s.apimachinery.pkg.apis.meta.v1.Status": {
        "description": "Status is a return value for calls that don't return other objects.",
        "type": "object",
        "properties": {
          "apiVersion": {
            "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
            "type": "string"
          },
          "code": {
            "description": "Suggested HTTP return code for this status, 0 if not set.",
            "type": "integer",
            "format": "int32"
          },
          "details": {
            "description": "Extended data associated with the reason.  Each reason may define its own extended details. This field is optional and the data returned is not guaranteed to conform to any schema except that defined by the reason type.",
            "allOf": [
              {
                "$ref": "#/components/schemas/io.k8s.apimachinery.pkg.apis.meta.v1.StatusDetails"
              }
            ],
            "x-kubernetes-list-type": "atomic"
          },
          "kind": {
            "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
            "type": "string"
          },
          "message": {
            "description": "A human-readable description of the status of this operation.",
            "type": "string"
          },
          "metadata": {
            "description": "Standard list metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
            "default": {},
            "allOf": [
              {
                "$ref": "#/components/schemas/io.k8s.apimachinery.pkg.apis.meta.v1.ListMeta"
              }
            ]
          },
          "reason": {
            "description": "A machine-readable description of why this operation is in the \"Failure\" status. If this value is empty there is no information available. A Reason clarifies an HTTP status code but does not override it.",
            "type": "string"
          },
          "status": {
            "description": "Status of the operation. One of: \"Success\" or \"Failure\". More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status",
            "type": "string"
          }
        },
        "x-kubernetes-group-version-kind": [
          { "group": "", "kind": "Status", "version": "v1" }
        ]
      },
      "io.k8s.apimachinery.pkg.apis.meta.v1.StatusCause": {
        "description": "StatusCause provides more information about an api.Status failure, including cases when multiple errors are encountered.",
        "type": "object",
        "properties": {
          "field": {
            "description": "The field of the resource that has caused this error, as named by its JSON serialization. May include dot and postfix notation for nested attributes. Arrays are zero-indexed.  Fields may appear more than once in an array of causes due to fields having multiple errors. Optional.\n\nExamples:\n  \"name\" - the field \"name\" on the current resource\n  \"items[0].name\" - the field \"name\" on the first array entry in \"items\"",
            "type": "string"
          },
          "message": {
            "description": "A human-readable description of the cause of the error.  This field may be presented as-is to a reader.",
            "type": "string"
          },
          "reason": {
            "description": "A machine-readable description of the cause of the error. If this value is empty there is no information available.",
            "type": "string"
          }
        }
      },
      "io.k8s.apimachinery.pkg.apis.meta.v1.StatusDetails": {
        "description": "StatusDetails is a set of additional properties that MAY be set by the server to provide additional information about a response. The Reason field of a Status object defines what attributes will be set. Clients must ignore fields that do not match the defined type of each attribute, and should assume that any attribute may be empty, invalid, or under defined.",
        "type": "object",
        "properties": {
          "causes": {
            "description": "The Causes array includes more details associated with the StatusReason failure. Not all StatusReasons may provide detailed causes.",
            "type": "array",
            "items": {
              "default": {},
              "allOf": [
                {
                  "$ref": "#/components/schemas/io.k8s.apimachinery.pkg.apis.meta.v1.StatusCause"
                }
              ]
            },
            "x-kubernetes-list-type": "atomic"
          },
          "group": {
            "description": "The group attribute of the resource associated with the status StatusReason.",
            "type": "string"
          },
          "kind": {
            "description": "The kind attribute of the resource associated with the status StatusReason. On some operations may differ from the requested resource Kind. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
            "type": "string"
          },
          "name": {
            "description": "The name attribute of the resource associated with the status StatusReason (when there is a single name which can be described).",
            "type": "string"
          },
          "retryAfterSeconds": {
            "description": "If specified, the time in seconds before the operation should be retried. Some errors may indicate the client must take an alternate action - for those errors this field may indicate how long to wait before taking the alternate action.",
            "type": "integer",
            "format": "int32"
          },
          "uid": {
            "description": "UID of the resource. (when there is a single resource which can be described). More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names#uids",
            "type": "string"
          }
        }
      },
      "io.k8s.apimachinery.pkg.apis.meta.v1.Time": {
        "description": "Time is a wrapper around time.Time which supports correct marshaling to YAML and JSON.  Wrappers are provided for many of the factory methods that the time package offers.",
        "type": "string",
        "format": "date-time"
      },
      "io.k8s.apimachinery.pkg.apis.meta.v1.WatchEvent": {
        "description": "Event represents a single event to a watched resource.",
        "type": "object",
        "required": ["type", "object"],
        "properties": {
          "object": {
            "description": "Object is:\n * If Type is Added or Modified: the new state of the object.\n * If Type is Deleted: the state of the object immediately before deletion.\n * If Type is Error: *Status is recommended; other types may make sense\n   depending on context.",
            "allOf": [
              {
                "$ref": "#/components/schemas/io.k8s.apimachinery.pkg.runtime.RawExtension"
              }
            ]
          },
          "type": { "type": "string", "default": "" }
        },
        "x-kubernetes-group-version-kind": [
          { "group": "", "kind": "WatchEvent", "version": "v1" },
          {
            "group": "admission.k8s.io",
            "kind": "WatchEvent",
            "version": "v1"
          },
          {
            "group": "admission.k8s.io",
            "kind": "WatchEvent",
            "version": "v1beta1"
          },
          {
            "group": "admissionregistration.k8s.io",
            "kind": "WatchEvent",
            "version": "v1"
          },
          {
            "group": "admissionregistration.k8s.io",
            "kind": "WatchEvent",
            "version": "v1alpha1"
          },
          {
            "group": "admissionregistration.k8s.io",
            "kind": "WatchEvent",
            "version": "v1beta1"
          },
          {
            "group": "apiextensions.k8s.io",
            "kind": "WatchEvent",
            "version": "v1"
          },
          {
            "group": "apiextensions.k8s.io",
            "kind": "WatchEvent",
            "version": "v1beta1"
          },
          { "group": "apps", "kind": "WatchEvent", "version": "v1" },
          { "group": "apps", "kind": "WatchEvent", "version": "v1beta1" },
          { "group": "apps", "kind": "WatchEvent", "version": "v1beta2" },
          {
            "group": "authentication.k8s.io",
            "kind": "WatchEvent",
            "version": "v1"
          },
          {
            "group": "authentication.k8s.io",
            "kind": "WatchEvent",
            "version": "v1alpha1"
          },
          {
            "group": "authentication.k8s.io",
            "kind": "WatchEvent",
            "version": "v1beta1"
          },
          {
            "group": "authorization.k8s.io",
            "kind": "WatchEvent",
            "version": "v1"
          },
          {
            "group": "authorization.k8s.io",
            "kind": "WatchEvent",
            "version": "v1beta1"
          },
          { "group": "autoscaling", "kind": "WatchEvent", "version": "v1" },
          { "group": "autoscaling", "kind": "WatchEvent", "version": "v2" },
          {
            "group": "autoscaling",
            "kind": "WatchEvent",
            "version": "v2beta1"
          },
          {
            "group": "autoscaling",
            "kind": "WatchEvent",
            "version": "v2beta2"
          },
          { "group": "batch", "kind": "WatchEvent", "version": "v1" },
          { "group": "batch", "kind": "WatchEvent", "version": "v1beta1" },
          {
            "group": "certificates.k8s.io",
            "kind": "WatchEvent",
            "version": "v1"
          },
          {
            "group": "certificates.k8s.io",
            "kind": "WatchEvent",
            "version": "v1alpha1"
          },
          {
            "group": "certificates.k8s.io",
            "kind": "WatchEvent",
            "version": "v1beta1"
          },
          {
            "group": "coordination.k8s.io",
            "kind": "WatchEvent",
            "version": "v1"
          },
          {
            "group": "coordination.k8s.io",
            "kind": "WatchEvent",
            "version": "v1alpha1"
          },
          {
            "group": "coordination.k8s.io",
            "kind": "WatchEvent",
            "version": "v1beta1"
          },
          {
            "group": "discovery.k8s.io",
            "kind": "WatchEvent",
            "version": "v1"
          },
          {
            "group": "discovery.k8s.io",
            "kind": "WatchEvent",
            "version": "v1beta1"
          },
          { "group": "events.k8s.io", "kind": "WatchEvent", "version": "v1" },
          {
            "group": "events.k8s.io",
            "kind": "WatchEvent",
            "version": "v1beta1"
          },
          { "group": "extensions", "kind": "WatchEvent", "version": "v1beta1" },
          {
            "group": "flowcontrol.apiserver.k8s.io",
            "kind": "WatchEvent",
            "version": "v1"
          },
          {
            "group": "flowcontrol.apiserver.k8s.io",
            "kind": "WatchEvent",
            "version": "v1beta1"
          },
          {
            "group": "flowcontrol.apiserver.k8s.io",
            "kind": "WatchEvent",
            "version": "v1beta2"
          },
          {
            "group": "flowcontrol.apiserver.k8s.io",
            "kind": "WatchEvent",
            "version": "v1beta3"
          },
          {
            "group": "imagepolicy.k8s.io",
            "kind": "WatchEvent",
            "version": "v1alpha1"
          },
          {
            "group": "internal.apiserver.k8s.io",
            "kind": "WatchEvent",
            "version": "v1alpha1"
          },
          {
            "group": "networking.k8s.io",
            "kind": "WatchEvent",
            "version": "v1"
          },
          {
            "group": "networking.k8s.io",
            "kind": "WatchEvent",
            "version": "v1alpha1"
          },
          {
            "group": "networking.k8s.io",
            "kind": "WatchEvent",
            "version": "v1beta1"
          },
          { "group": "node.k8s.io", "kind": "WatchEvent", "version": "v1" },
          {
            "group": "node.k8s.io",
            "kind": "WatchEvent",
            "version": "v1alpha1"
          },
          {
            "group": "node.k8s.io",
            "kind": "WatchEvent",
            "version": "v1beta1"
          },
          { "group": "policy", "kind": "WatchEvent", "version": "v1" },
          { "group": "policy", "kind": "WatchEvent", "version": "v1beta1" },
          {
            "group": "rbac.authorization.k8s.io",
            "kind": "WatchEvent",
            "version": "v1"
          },
          {
            "group": "rbac.authorization.k8s.io",
            "kind": "WatchEvent",
            "version": "v1alpha1"
          },
          {
            "group": "rbac.authorization.k8s.io",
            "kind": "WatchEvent",
            "version": "v1beta1"
          },
          {
            "group": "resource.k8s.io",
            "kind": "WatchEvent",
            "version": "v1alpha3"
          },
          {
            "group": "scheduling.k8s.io",
            "kind": "WatchEvent",
            "version": "v1"
          },
          {
            "group": "scheduling.k8s.io",
            "kind": "WatchEvent",
            "version": "v1alpha1"
          },
          {
            "group": "scheduling.k8s.io",
            "kind": "WatchEvent",
            "version": "v1beta1"
          },
          { "group": "storage.k8s.io", "kind": "WatchEvent", "version": "v1" },
          {
            "group": "storage.k8s.io",
            "kind": "WatchEvent",
            "version": "v1alpha1"
          },
          {
            "group": "storage.k8s.io",
            "kind": "WatchEvent",
            "version": "v1beta1"
          },
          {
            "group": "storagemigration.k8s.io",
            "kind": "WatchEvent",
            "version": "v1alpha1"
          }
        ]
      },
      "io.k8s.apimachinery.pkg.runtime.RawExtension": {
        "description": "RawExtension is used to hold extensions in external versions.\n\nTo use this, make a field which has RawExtension as its type in your external, versioned struct, and Object in your internal struct. You also need to register your various plugin types.\n\n// Internal package:\n\n\ttype MyAPIObject struct {\n\t\truntime.TypeMeta `json:\",inline\"`\n\t\tMyPlugin runtime.Object `json:\"myPlugin\"`\n\t}\n\n\ttype PluginA struct {\n\t\tAOption string `json:\"aOption\"`\n\t}\n\n// External package:\n\n\ttype MyAPIObject struct {\n\t\truntime.TypeMeta `json:\",inline\"`\n\t\tMyPlugin runtime.RawExtension `json:\"myPlugin\"`\n\t}\n\n\ttype PluginA struct {\n\t\tAOption string `json:\"aOption\"`\n\t}\n\n// On the wire, the JSON will look something like this:\n\n\t{\n\t\t\"kind\":\"MyAPIObject\",\n\t\t\"apiVersion\":\"v1\",\n\t\t\"myPlugin\": {\n\t\t\t\"kind\":\"PluginA\",\n\t\t\t\"aOption\":\"foo\",\n\t\t},\n\t}\n\nSo what happens? Decode first uses json or yaml to unmarshal the serialized data into your external MyAPIObject. That causes the raw JSON to be stored, but not unpacked. The next step is to copy (using pkg/conversion) into the internal struct. The runtime package's DefaultScheme has conversion functions installed which will unpack the JSON stored in RawExtension, turning it into the correct object type, and storing it in the Object. (TODO: In the case where the object is of an unknown type, a runtime.Unknown object will be created and stored.)",
        "type": "object"
      },
      "io.kcp.apis.v1alpha1.APIBinding": {
        "description": "APIBinding enables a set of resources and their behaviour through an external\nservice provider in this workspace.\n\nThe service provider uses an APIExport to expose the API.",
        "type": "object",
        "required": ["spec"],
        "properties": {
          "apiVersion": {
            "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
            "type": "string"
          },
          "kind": {
            "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
            "type": "string"
          },
          "metadata": {
            "description": "Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata",
            "allOf": [
              {
                "$ref": "#/components/schemas/io.k8s.apimachinery.pkg.apis.meta.v1.ObjectMeta"
              }
            ]
          },
          "spec": {
            "description": "Spec holds the desired state.",
            "type": "object",
            "required": ["reference"],
            "properties": {
              "permissionClaims": {
                "description": "permissionClaims records decisions about permission claims requested by the API service provider.\nIndividual claims can be accepted or rejected. If accepted, the API service provider gets the\nrequested access to the specified resources in this workspace. Access is granted per\nGroupResource, identity, and other properties.",
                "type": "array",
                "items": {
                  "description": "AcceptablePermissionClaim is a PermissionClaim that records if the user accepts or rejects it.",
                  "type": "object",
                  "required": ["resource", "state"],
                  "properties": {
                    "all": {
                      "description": "all claims all resources for the given group/resource.\nThis is mutually exclusive with resourceSelector.",
                      "type": "boolean"
                    },
                    "group": {
                      "description": "group is the name of an API group.\nFor core groups this is the empty string '\"\"'.",
                      "type": "string",
                      "pattern": "^(|[a-z0-9]([-a-z0-9]*[a-z0-9](\\.[a-z0-9]([-a-z0-9]*[a-z0-9])?)*)?)$"
                    },
                    "identityHash": {
                      "description": "This is the identity for a given APIExport that the APIResourceSchema belongs to.\nThe hash can be found on APIExport and APIResourceSchema's status.\nIt will be empty for core types.\nNote that one must look this up for a particular KCP instance.",
                      "type": "string"
                    },
                    "resource": {
                      "description": "resource is the name of the resource.\nNote: it is worth noting that you can not ask for permissions for resource provided by a CRD\nnot provided by an api export.",
                      "type": "string",
                      "pattern": "^[a-z][-a-z0-9]*[a-z0-9]$"
                    },
                    "resourceSelector": {
                      "description": "resourceSelector is a list of claimed resource selectors.",
                      "type": "array",
                      "items": {
                        "type": "object",
                        "properties": {
                          "name": {
                            "description": "name of an object within a claimed group/resource.\nIt matches the metadata.name field of the underlying object.\nIf namespace is unset, all objects matching that name will be claimed.",
                            "type": "string",
                            "maxLength": 253,
                            "minLength": 1,
                            "pattern": "^([a-z0-9][-a-z0-9_.]*)?[a-z0-9]$"
                          },
                          "namespace": {
                            "description": "namespace containing the named object. Matches metadata.namespace field.\nIf \"name\" is unset, all objects from the namespace are being claimed.",
                            "type": "string",
                            "minLength": 1
                          }
                        },
                        "x-kubernetes-validations": [
                          {
                            "message": "at least one field must be set",
                            "rule": "has(self.__namespace__) || has(self.name)"
                          }
                        ]
                      }
                    },
                    "state": {
                      "type": "string",
                      "enum": ["Accepted", "Rejected"]
                    }
                  },
                  "x-kubernetes-validations": [
                    {
                      "message": "either \"all\" or \"resourceSelector\" must be set",
                      "rule": "(has(self.all) \u0026\u0026 self.all) != (has(self.resourceSelector) \u0026\u0026 size(self.resourceSelector) \u003e 0)"
                    }
                  ]
                }
              },
              "reference": {
                "description": "reference uniquely identifies an API to bind to.",
                "type": "object",
                "oneOf": [{ "required": ["export"] }],
                "properties": {
                  "export": {
                    "description": "export is a reference to an APIExport by cluster name and export name.\nThe creator of the APIBinding needs to have access to the APIExport with the\nverb `bind` in order to bind to it.",
                    "type": "object",
                    "required": ["name"],
                    "properties": {
                      "name": {
                        "description": "name is the name of the APIExport that describes the API.",
                        "type": "string"
                      },
                      "path": {
                        "description": "path is a logical cluster path where the APIExport is defined.\nIf the path is unset, the logical cluster of the APIBinding is used.",
                        "type": "string",
                        "pattern": "^[a-z0-9]([-a-z0-9]*[a-z0-9])?(:[a-z0-9]([-a-z0-9]*[a-z0-9])?)*$"
                      }
                    }
                  }
                },
                "x-kubernetes-validations": [
                  {
                    "message": "APIExport reference must not be changed",
                    "rule": "self == oldSelf"
                  }
                ]
              }
            }
          },
          "status": {
            "description": "Status communicates the observed state.",
            "type": "object",
            "properties": {
              "apiExportClusterName": {
                "description": "APIExportClusterName records the name (not path) of the logical cluster that contains the APIExport.",
                "type": "string"
              },
              "appliedPermissionClaims": {
                "description": "appliedPermissionClaims is a list of the permission claims the system has seen and applied,\naccording to the requests of the API service provider in the APIExport and the acceptance\nstate in spec.permissionClaims.",
                "type": "array",
                "items": {
                  "description": "PermissionClaim identifies an object by GR and identity hash.\nIts purpose is to determine the added permissions that a service provider may\nrequest and that a consumer may accept and allow the service provider access to.",
                  "type": "object",
                  "required": ["resource"],
                  "properties": {
                    "all": {
                      "description": "all claims all resources for the given group/resource.\nThis is mutually exclusive with resourceSelector.",
                      "type": "boolean"
                    },
                    "group": {
                      "description": "group is the name of an API group.\nFor core groups this is the empty string '\"\"'.",
                      "type": "string",
                      "pattern": "^(|[a-z0-9]([-a-z0-9]*[a-z0-9](\\.[a-z0-9]([-a-z0-9]*[a-z0-9])?)*)?)$"
                    },
                    "identityHash": {
                      "description": "This is the identity for a given APIExport that the APIResourceSchema belongs to.\nThe hash can be found on APIExport and APIResourceSchema's status.\nIt will be empty for core types.\nNote that one must look this up for a particular KCP instance.",
                      "type": "string"
                    },
                    "resource": {
                      "description": "resource is the name of the resource.\nNote: it is worth noting that you can not ask for permissions for resource provided by a CRD\nnot provided by an api export.",
                      "type": "string",
                      "pattern": "^[a-z][-a-z0-9]*[a-z0-9]$"
                    },
                    "resourceSelector": {
                      "description": "resourceSelector is a list of claimed resource selectors.",
                      "type": "array",
                      "items": {
                        "type": "object",
                        "properties": {
                          "name": {
                            "description": "name of an object within a claimed group/resource.\nIt matches the metadata.name field of the underlying object.\nIf namespace is unset, all objects matching that name will be claimed.",
                            "type": "string",
                            "maxLength": 253,
                            "minLength": 1,
                            "pattern": "^([a-z0-9][-a-z0-9_.]*)?[a-z0-9]$"
                          },
                          "namespace": {
                            "description": "namespace containing the named object. Matches metadata.namespace field.\nIf \"name\" is unset, all objects from the namespace are being claimed.",
                            "type": "string",
                            "minLength": 1
                          }
                        },
                        "x-kubernetes-validations": [
                          {
                            "message": "at least one field must be set",
                            "rule": "has(self.__namespace__) || has(self.name)"
                          }
                        ]
                      }
                    }
                  },
                  "x-kubernetes-validations": [
                    {
                      "message": "either \"all\" or \"resourceSelector\" must be set",
                      "rule": "(has(self.all) \u0026\u0026 self.all) != (has(self.resourceSelector) \u0026\u0026 size(self.resourceSelector) \u003e 0)"
                    }
                  ]
                }
              },
              "boundResources": {
                "description": "boundResources records the state of bound APIs.",
                "type": "array",
                "items": {
                  "description": "BoundAPIResource describes a bound GroupVersionResource through an APIResourceSchema of an APIExport..",
                  "type": "object",
                  "required": ["group", "resource", "schema"],
                  "properties": {
                    "group": {
                      "description": "group is the group of the bound API. Empty string for the core API group.",
                      "type": "string"
                    },
                    "resource": {
                      "description": "resource is the resource of the bound API.\n\nkubebuilder:validation:MinLength=1",
                      "type": "string"
                    },
                    "schema": {
                      "description": "Schema references the APIResourceSchema that is bound to this API.",
                      "type": "object",
                      "required": ["UID", "identityHash", "name"],
                      "properties": {
                        "UID": {
                          "description": "UID is the UID of the APIResourceSchema that is bound to this API.",
                          "type": "string",
                          "minLength": 1
                        },
                        "identityHash": {
                          "description": "identityHash is the hash of the API identity that this schema is bound to.\nThe API identity determines the etcd prefix used to persist the object.\nDifferent identity means that the objects are effectively served and stored\nunder a distinct resource. A CRD of the same GroupVersionResource uses a\ndifferent identity and hence a separate etcd prefix.",
                          "type": "string",
                          "minLength": 1
                        },
                        "name": {
                          "description": "name is the bound APIResourceSchema name.",
                          "type": "string",
                          "minLength": 1
                        }
                      }
                    },
                    "storageVersions": {
                      "description": "storageVersions lists all versions of a resource that were ever persisted. Tracking these\nversions allows a migration path for stored versions in etcd. The field is mutable\nso a migration controller can finish a migration to another version (ensuring\nno old objects are left in storage), and then remove the rest of the\nversions from this list.\n\nVersions may not be removed while they exist in this list.",
                      "type": "array",
                      "items": { "type": "string" },
                      "x-kubernetes-list-type": "set",
                      "x-kubernetes-patch-strategy": "merge"
                    }
                  }
                },
                "x-kubernetes-list-map-keys": ["group", "resource"],
                "x-kubernetes-list-type": "map",
                "x-kubernetes-patch-merge-key": "group",
                "x-kubernetes-patch-strategy": "merge"
              },
              "conditions": {
                "description": "conditions is a list of conditions that apply to the APIBinding.",
                "type": "array",
                "items": {
                  "description": "Condition defines an observation of a object operational state.",
                  "type": "object",
                  "required": ["lastTransitionTime", "status", "type"],
                  "properties": {
                    "lastTransitionTime": {
                      "description": "Last time the condition transitioned from one status to another.\nThis should be when the underlying condition changed. If that is not known, then using the time when\nthe API field changed is acceptable.",
                      "type": "string",
                      "format": "date-time"
                    },
                    "message": {
                      "description": "A human readable message indicating details about the transition.\nThis field may be empty.",
                      "type": "string"
                    },
                    "reason": {
                      "description": "The reason for the condition's last transition in CamelCase.\nThe specific API may choose whether or not this field is considered a guaranteed API.\nThis field may not be empty.",
                      "type": "string"
                    },
                    "severity": {
                      "description": "Severity provides an explicit classification of Reason code, so the users or machines can immediately\nunderstand the current situation and act accordingly.\nThe Severity field MUST be set only when Status=False.",
                      "type": "string"
                    },
                    "status": {
                      "description": "Status of the condition, one of True, False, Unknown.",
                      "type": "string"
                    },
                    "type": {
                      "description": "Type of condition in CamelCase or in foo.example.com/CamelCase.\nMany .condition.type values are consistent across resources like Available, but because arbitrary conditions\ncan be useful (see .node.status.conditions), the ability to deconflict is important.",
                      "type": "string"
                    }
                  }
                }
              },
              "exportPermissionClaims": {
                "description": "exportPermissionClaims records the permissions that the export provider is asking for\nthe binding to grant.",
                "type": "array",
                "items": {
                  "description": "PermissionClaim identifies an object by GR and identity hash.\nIts purpose is to determine the added permissions that a service provider may\nrequest and that a consumer may accept and allow the service provider access to.",
                  "type": "object",
                  "required": ["resource"],
                  "properties": {
                    "all": {
                      "description": "all claims all resources for the given group/resource.\nThis is mutually exclusive with resourceSelector.",
                      "type": "boolean"
                    },
                    "group": {
                      "description": "group is the name of an API group.\nFor core groups this is the empty string '\"\"'.",
                      "type": "string",
                      "pattern": "^(|[a-z0-9]([-a-z0-9]*[a-z0-9](\\.[a-z0-9]([-a-z0-9]*[a-z0-9])?)*)?)$"
                    },
                    "identityHash": {
                      "description": "This is the identity for a given APIExport that the APIResourceSchema belongs to.\nThe hash can be found on APIExport and APIResourceSchema's status.\nIt will be empty for core types.\nNote that one must look this up for a particular KCP instance.",
                      "type": "string"
                    },
                    "resource": {
                      "description": "resource is the name of the resource.\nNote: it is worth noting that you can not ask for permissions for resource provided by a CRD\nnot provided by an api export.",
                      "type": "string",
                      "pattern": "^[a-z][-a-z0-9]*[a-z0-9]$"
                    },
                    "resourceSelector": {
                      "description": "resourceSelector is a list of claimed resource selectors.",
                      "type": "array",
                      "items": {
                        "type": "object",
                        "properties": {
                          "name": {
                            "description": "name of an object within a claimed group/resource.\nIt matches the metadata.name field of the underlying object.\nIf namespace is unset, all objects matching that name will be claimed.",
                            "type": "string",
                            "maxLength": 253,
                            "minLength": 1,
                            "pattern": "^([a-z0-9][-a-z0-9_.]*)?[a-z0-9]$"
                          },
                          "namespace": {
                            "description": "namespace containing the named object. Matches metadata.namespace field.\nIf \"name\" is unset, all objects from the namespace are being claimed.",
                            "type": "string",
                            "minLength": 1
                          }
                        },
                        "x-kubernetes-validations": [
                          {
                            "message": "at least one field must be set",
                            "rule": "has(self.__namespace__) || has(self.name)"
                          }
                        ]
                      }
                    }
                  },
                  "x-kubernetes-validations": [
                    {
                      "message": "either \"all\" or \"resourceSelector\" must be set",
                      "rule": "(has(self.all) \u0026\u0026 self.all) != (has(self.resourceSelector) \u0026\u0026 size(self.resourceSelector) \u003e 0)"
                    }
                  ]
                }
              },
              "phase": {
                "description": "phase is the current phase of the APIBinding:\n- \"\": the APIBinding has just been created, waiting to be bound.\n- Binding: the APIBinding is being bound.\n- Bound: the APIBinding is bound and the referenced APIs are available in the workspace.",
                "type": "string",
                "enum": ["", "Binding", "Bound"]
              }
            }
          }
        },
        "x-kubernetes-group-version-kind": [
          {
            "group": "apis.kcp.io",
            "kind": "APIBinding",
            "version": "v1alpha1"
          }
        ]
      },
      "io.kcp.apis.v1alpha1.APIBindingList": {
        "description": "APIBindingList is a list of APIBinding",
        "type": "object",
        "required": ["items"],
        "properties": {
          "apiVersion": {
            "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
            "type": "string"
          },
          "items": {
            "description": "List of apibindings. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md",
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/io.kcp.apis.v1alpha1.APIBinding"
            }
          },
          "kind": {
            "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
            "type": "string"
          },
          "metadata": {
            "description": "Standard list metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
            "allOf": [
              {
                "$ref": "#/components/schemas/io.k8s.apimachinery.pkg.apis.meta.v1.ListMeta"
              }
            ]
          }
        },
        "x-kubernetes-group-version-kind": [
          {
            "group": "apis.kcp.io",
            "kind": "APIBindingList",
            "version": "v1alpha1"
          }
        ]
      },
      "io.kcp.apis.v1alpha1.APIConversion": {
        "description": "APIConversion contains rules to convert between different API versions in an APIResourceSchema. The name must match\nthe name of the APIResourceSchema for the conversions to take effect.",
        "type": "object",
        "required": ["metadata", "spec"],
        "properties": {
          "apiVersion": {
            "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
            "type": "string"
          },
          "kind": {
            "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
            "type": "string"
          },
          "metadata": {
            "description": "Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata",
            "allOf": [
              {
                "$ref": "#/components/schemas/io.k8s.apimachinery.pkg.apis.meta.v1.ObjectMeta"
              }
            ]
          },
          "spec": {
            "description": "Spec holds the desired state.",
            "type": "object",
            "required": ["conversions"],
            "properties": {
              "conversions": {
                "description": "conversions specify rules to convert between different API versions in an APIResourceSchema.",
                "type": "array",
                "items": {
                  "description": "APIVersionConversion contains rules to convert between two specific API versions in an\nAPIResourceSchema. Additionally, to avoid data loss when round-tripping from a version that\ncontains a new field to one that doesn't and back again, you can specify a list of fields to\npreserve (these are stored in annotations).",
                  "type": "object",
                  "required": ["from", "rules", "to"],
                  "properties": {
                    "from": {
                      "description": "from is the source version.",
                      "type": "string",
                      "minLength": 1,
                      "pattern": "^v[1-9][0-9]*([a-z]+[1-9][0-9]*)?$"
                    },
                    "preserve": {
                      "description": "preserve contains a list of JSONPath expressions to fields to preserve in the originating version\nof the object, relative to its root, such as '.spec.name.first'.",
                      "type": "array",
                      "items": { "type": "string" }
                    },
                    "rules": {
                      "description": "rules contains field-specific conversion expressions.",
                      "type": "array",
                      "items": {
                        "description": "APIConversionRule specifies how to convert a single field.",
                        "type": "object",
                        "required": ["destination", "field"],
                        "properties": {
                          "destination": {
                            "description": "destination is a JSONPath expression to the field in the target version of the object, relative to\nits root, such as '.spec.name.first'.",
                            "type": "string",
                            "minLength": 1
                          },
                          "field": {
                            "description": "field is a JSONPath expression to the field in the originating version of the object, relative to its root, such\nas '.spec.name.first'.",
                            "type": "string",
                            "minLength": 1
                          },
                          "transformation": {
                            "description": "transformation is an optional CEL expression used to execute user-specified rules to transform the\noriginating field -- identified by 'self' -- to the destination field.",
                            "type": "string"
                          }
                        }
                      },
                      "x-kubernetes-list-map-keys": ["destination"],
                      "x-kubernetes-list-type": "map",
                      "x-kubernetes-patch-merge-key": "destination",
                      "x-kubernetes-patch-strategy": "merge"
                    },
                    "to": {
                      "description": "to is the target version.",
                      "type": "string",
                      "minLength": 1,
                      "pattern": "^v[1-9][0-9]*([a-z]+[1-9][0-9]*)?$"
                    }
                  }
                },
                "x-kubernetes-list-map-keys": ["from", "to"],
                "x-kubernetes-list-type": "map",
                "x-kubernetes-patch-merge-key": "from",
                "x-kubernetes-patch-strategy": "merge"
              }
            }
          }
        },
        "x-kubernetes-group-version-kind": [
          {
            "group": "apis.kcp.io",
            "kind": "APIConversion",
            "version": "v1alpha1"
          }
        ]
      },
      "io.kcp.apis.v1alpha1.APIConversionList": {
        "description": "APIConversionList is a list of APIConversion",
        "type": "object",
        "required": ["items"],
        "properties": {
          "apiVersion": {
            "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
            "type": "string"
          },
          "items": {
            "description": "List of apiconversions. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md",
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/io.kcp.apis.v1alpha1.APIConversion"
            }
          },
          "kind": {
            "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
            "type": "string"
          },
          "metadata": {
            "description": "Standard list metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
            "allOf": [
              {
                "$ref": "#/components/schemas/io.k8s.apimachinery.pkg.apis.meta.v1.ListMeta"
              }
            ]
          }
        },
        "x-kubernetes-group-version-kind": [
          {
            "group": "apis.kcp.io",
            "kind": "APIConversionList",
            "version": "v1alpha1"
          }
        ]
      },
      "io.kcp.apis.v1alpha1.APIExport": {
        "description": "APIExport registers an API and implementation to allow consumption by others\nthrough APIBindings.",
        "type": "object",
        "properties": {
          "apiVersion": {
            "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
            "type": "string"
          },
          "kind": {
            "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
            "type": "string"
          },
          "metadata": {
            "description": "Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata",
            "allOf": [
              {
                "$ref": "#/components/schemas/io.k8s.apimachinery.pkg.apis.meta.v1.ObjectMeta"
              }
            ]
          },
          "spec": {
            "description": "Spec holds the desired state.",
            "type": "object",
            "properties": {
              "identity": {
                "description": "identity points to a secret that contains the API identity in the 'key' file.\nThe API identity determines an unique etcd prefix for objects stored via this\nAPIExport.\n\nDifferent APIExport in a workspace can share a common identity, or have different\nones. The identity (the secret) can also be transferred to another workspace\nwhen the APIExport is moved.\n\nThe identity is a secret of the API provider. The APIBindings referencing this APIExport\nwill store a derived, non-sensitive value of this identity.\n\nThe identity of an APIExport cannot be changed. A derived, non-sensitive value of\nthe identity key is stored in the APIExport status and this value is immutable.\n\nThe identity is defaulted. A secret with the name of the APIExport is automatically\ncreated.",
                "type": "object",
                "properties": {
                  "secretRef": {
                    "description": "secretRef is a reference to a secret that contains the API identity in the 'key' file.",
                    "type": "object",
                    "properties": {
                      "name": {
                        "description": "name is unique within a namespace to reference a secret resource.",
                        "type": "string"
                      },
                      "namespace": {
                        "description": "namespace defines the space within which the secret name must be unique.",
                        "type": "string"
                      }
                    },
                    "x-kubernetes-map-type": "atomic",
                    "x-kubernetes-patch-strategy": "replace"
                  }
                }
              },
              "latestResourceSchemas": {
                "description": "latestResourceSchemas records the latest APIResourceSchemas that are exposed\nwith this APIExport.\n\nThe schemas can be changed in the life-cycle of the APIExport. These changes\nhave no effect on existing APIBindings, but only on newly bound ones.\n\nFor updating existing APIBindings, use an APIDeployment keeping bound\nworkspaces up-to-date.",
                "type": "array",
                "items": { "type": "string" },
                "x-kubernetes-list-type": "set",
                "x-kubernetes-patch-strategy": "merge"
              },
              "maximalPermissionPolicy": {
                "description": "maximalPermissionPolicy will allow for a service provider to set an upper bound on what is allowed\nfor a consumer of this API. If the policy is not set, no upper bound is applied,\ni.e the consuming users can do whatever the user workspace allows the user to do.\n\nThe policy consists of RBAC (Cluster)Roles and (Cluster)Bindings. A request of a user in\na workspace that binds to this APIExport via an APIBinding is additionally checked against\nthese rules, with the user name and the groups prefixed with `apis.kcp.io:binding:`.\n\nFor example: assume a user `adam` with groups `system:authenticated` and `a-team` binds to\nthis APIExport in another workspace root:org:ws. Then a request in that workspace\nagainst a resource of this APIExport is authorized as every other request in that workspace,\nbut in addition the RBAC policy here in the APIExport workspace has to grant access to the\nuser `apis.kcp.io:binding:adam` with the groups `apis.kcp.io:binding:system:authenticated`\nand `apis.kcp.io:binding:a-team`.",
                "type": "object",
                "oneOf": [{ "required": ["local"] }],
                "properties": {
                  "local": {
                    "description": "local is the policy that is defined in same workspace as the API Export.",
                    "type": "object"
                  }
                }
              },
              "permissionClaims": {
                "description": "permissionClaims make resources available in APIExport's virtual workspace that are not part\nof the actual APIExport resources.\n\nPermissionClaims are optional and should be the least access necessary to complete the functions\nthat the service provider needs. Access is asked for on a GroupResource + identity basis.\n\nPermissionClaims must be accepted by the user's explicit acknowledgement. Hence, when claims\nchange, the respecting objects are not visible immediately.\n\nPermissionClaims overlapping with the APIExport resources are ignored.",
                "type": "array",
                "items": {
                  "description": "PermissionClaim identifies an object by GR and identity hash.\nIts purpose is to determine the added permissions that a service provider may\nrequest and that a consumer may accept and allow the service provider access to.",
                  "type": "object",
                  "required": ["resource"],
                  "properties": {
                    "all": {
                      "description": "all claims all resources for the given group/resource.\nThis is mutually exclusive with resourceSelector.",
                      "type": "boolean"
                    },
                    "group": {
                      "description": "group is the name of an API group.\nFor core groups this is the empty string '\"\"'.",
                      "type": "string",
                      "default": "",
                      "pattern": "^(|[a-z0-9]([-a-z0-9]*[a-z0-9](\\.[a-z0-9]([-a-z0-9]*[a-z0-9])?)*)?)$"
                    },
                    "identityHash": {
                      "description": "This is the identity for a given APIExport that the APIResourceSchema belongs to.\nThe hash can be found on APIExport and APIResourceSchema's status.\nIt will be empty for core types.\nNote that one must look this up for a particular KCP instance.",
                      "type": "string"
                    },
                    "resource": {
                      "description": "resource is the name of the resource.\nNote: it is worth noting that you can not ask for permissions for resource provided by a CRD\nnot provided by an api export.",
                      "type": "string",
                      "pattern": "^[a-z][-a-z0-9]*[a-z0-9]$"
                    },
                    "resourceSelector": {
                      "description": "resourceSelector is a list of claimed resource selectors.",
                      "type": "array",
                      "items": {
                        "type": "object",
                        "properties": {
                          "name": {
                            "description": "name of an object within a claimed group/resource.\nIt matches the metadata.name field of the underlying object.\nIf namespace is unset, all objects matching that name will be claimed.",
                            "type": "string",
                            "maxLength": 253,
                            "minLength": 1,
                            "pattern": "^([a-z0-9][-a-z0-9_.]*)?[a-z0-9]$"
                          },
                          "namespace": {
                            "description": "namespace containing the named object. Matches metadata.namespace field.\nIf \"name\" is unset, all objects from the namespace are being claimed.",
                            "type": "string",
                            "minLength": 1
                          }
                        },
                        "x-kubernetes-validations": [
                          {
                            "message": "at least one field must be set",
                            "rule": "has(self.__namespace__) || has(self.name)"
                          }
                        ]
                      }
                    }
                  },
                  "x-kubernetes-validations": [
                    {
                      "message": "either \"all\" or \"resourceSelector\" must be set",
                      "rule": "(has(self.all) \u0026\u0026 self.all) != (has(self.resourceSelector) \u0026\u0026 size(self.resourceSelector) \u003e 0)"
                    }
                  ]
                },
                "x-kubernetes-list-map-keys": ["group", "resource"],
                "x-kubernetes-list-type": "map",
                "x-kubernetes-patch-merge-key": "group",
                "x-kubernetes-patch-strategy": "merge"
              }
            }
          },
          "status": {
            "description": "Status communicates the observed state.",
            "type": "object",
            "properties": {
              "conditions": {
                "description": "conditions is a list of conditions that apply to the APIExport.",
                "type": "array",
                "items": {
                  "description": "Condition defines an observation of a object operational state.",
                  "type": "object",
                  "required": ["lastTransitionTime", "status", "type"],
                  "properties": {
                    "lastTransitionTime": {
                      "description": "Last time the condition transitioned from one status to another.\nThis should be when the underlying condition changed. If that is not known, then using the time when\nthe API field changed is acceptable.",
                      "type": "string",
                      "format": "date-time"
                    },
                    "message": {
                      "description": "A human readable message indicating details about the transition.\nThis field may be empty.",
                      "type": "string"
                    },
                    "reason": {
                      "description": "The reason for the condition's last transition in CamelCase.\nThe specific API may choose whether or not this field is considered a guaranteed API.\nThis field may not be empty.",
                      "type": "string"
                    },
                    "severity": {
                      "description": "Severity provides an explicit classification of Reason code, so the users or machines can immediately\nunderstand the current situation and act accordingly.\nThe Severity field MUST be set only when Status=False.",
                      "type": "string"
                    },
                    "status": {
                      "description": "Status of the condition, one of True, False, Unknown.",
                      "type": "string"
                    },
                    "type": {
                      "description": "Type of condition in CamelCase or in foo.example.com/CamelCase.\nMany .condition.type values are consistent across resources like Available, but because arbitrary conditions\ncan be useful (see .node.status.conditions), the ability to deconflict is important.",
                      "type": "string"
                    }
                  }
                }
              },
              "identityHash": {
                "description": "identityHash is the hash of the API identity key of this APIExport. This value\nis immutable as soon as it is set.",
                "type": "string"
              },
              "virtualWorkspaces": {
                "description": "virtualWorkspaces contains all APIExport virtual workspace URLs.\n\nDeprecated: use APIExportEndpointSlice.status.endpoints instead",
                "type": "array",
                "items": {
                  "type": "object",
                  "required": ["url"],
                  "properties": {
                    "url": {
                      "description": "url is an APIExport virtual workspace URL.",
                      "type": "string",
                      "minLength": 1
                    }
                  }
                }
              }
            }
          }
        },
        "x-kubernetes-group-version-kind": [
          { "group": "apis.kcp.io", "kind": "APIExport", "version": "v1alpha1" }
        ]
      },
      "io.kcp.apis.v1alpha1.APIExportEndpointSlice": {
        "description": "APIExportEndpointSlice is a sink for the endpoints of an APIExport. These endpoints can be filtered by a Partition.\nThey get consumed by the managers to start controllers and informers for the respective APIExport services.",
        "type": "object",
        "properties": {
          "apiVersion": {
            "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
            "type": "string"
          },
          "kind": {
            "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
            "type": "string"
          },
          "metadata": {
            "description": "Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata",
            "allOf": [
              {
                "$ref": "#/components/schemas/io.k8s.apimachinery.pkg.apis.meta.v1.ObjectMeta"
              }
            ]
          },
          "spec": {
            "description": "spec holds the desired state:\n- the targeted APIExport\n- an optional partition for filtering",
            "type": "object",
            "required": ["export"],
            "properties": {
              "export": {
                "description": "export points to the API export.",
                "type": "object",
                "required": ["name"],
                "properties": {
                  "name": {
                    "description": "name is the name of the APIExport that describes the API.",
                    "type": "string"
                  },
                  "path": {
                    "description": "path is a logical cluster path where the APIExport is defined.\nIf the path is unset, the logical cluster of the APIBinding is used.",
                    "type": "string",
                    "pattern": "^[a-z0-9]([-a-z0-9]*[a-z0-9])?(:[a-z0-9]([-a-z0-9]*[a-z0-9])?)*$"
                  }
                },
                "x-kubernetes-validations": [
                  {
                    "message": "APIExport reference must not be changed",
                    "rule": "self == oldSelf"
                  }
                ]
              },
              "partition": {
                "description": "partition (optional) points to a partition that is used for filtering the endpoints\nof the APIExport part of the slice.",
                "type": "string"
              }
            }
          },
          "status": {
            "description": "status communicates the observed state:\nthe filtered list of endpoints for the APIExport service.",
            "type": "object",
            "properties": {
              "conditions": {
                "description": "conditions is a list of conditions that apply to the APIExportEndpointSlice.",
                "type": "array",
                "items": {
                  "description": "Condition defines an observation of a object operational state.",
                  "type": "object",
                  "required": ["lastTransitionTime", "status", "type"],
                  "properties": {
                    "lastTransitionTime": {
                      "description": "Last time the condition transitioned from one status to another.\nThis should be when the underlying condition changed. If that is not known, then using the time when\nthe API field changed is acceptable.",
                      "type": "string",
                      "format": "date-time"
                    },
                    "message": {
                      "description": "A human readable message indicating details about the transition.\nThis field may be empty.",
                      "type": "string"
                    },
                    "reason": {
                      "description": "The reason for the condition's last transition in CamelCase.\nThe specific API may choose whether or not this field is considered a guaranteed API.\nThis field may not be empty.",
                      "type": "string"
                    },
                    "severity": {
                      "description": "Severity provides an explicit classification of Reason code, so the users or machines can immediately\nunderstand the current situation and act accordingly.\nThe Severity field MUST be set only when Status=False.",
                      "type": "string"
                    },
                    "status": {
                      "description": "Status of the condition, one of True, False, Unknown.",
                      "type": "string"
                    },
                    "type": {
                      "description": "Type of condition in CamelCase or in foo.example.com/CamelCase.\nMany .condition.type values are consistent across resources like Available, but because arbitrary conditions\ncan be useful (see .node.status.conditions), the ability to deconflict is important.",
                      "type": "string"
                    }
                  }
                }
              },
              "endpoints": {
                "description": "endpoints contains all the URLs of the APIExport service.",
                "type": "array",
                "items": {
                  "description": "APIExportEndpoint contains the endpoint information of an APIExport service for a specific shard.",
                  "type": "object",
                  "required": ["url"],
                  "properties": {
                    "url": {
                      "description": "url is an APIExport virtual workspace URL.",
                      "type": "string",
                      "minLength": 1
                    }
                  }
                }
              }
            }
          }
        },
        "x-kubernetes-group-version-kind": [
          {
            "group": "apis.kcp.io",
            "kind": "APIExportEndpointSlice",
            "version": "v1alpha1"
          }
        ]
      },
      "io.kcp.apis.v1alpha1.APIExportEndpointSliceList": {
        "description": "APIExportEndpointSliceList is a list of APIExportEndpointSlice",
        "type": "object",
        "required": ["items"],
        "properties": {
          "apiVersion": {
            "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
            "type": "string"
          },
          "items": {
            "description": "List of apiexportendpointslices. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md",
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/io.kcp.apis.v1alpha1.APIExportEndpointSlice"
            }
          },
          "kind": {
            "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
            "type": "string"
          },
          "metadata": {
            "description": "Standard list metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
            "allOf": [
              {
                "$ref": "#/components/schemas/io.k8s.apimachinery.pkg.apis.meta.v1.ListMeta"
              }
            ]
          }
        },
        "x-kubernetes-group-version-kind": [
          {
            "group": "apis.kcp.io",
            "kind": "APIExportEndpointSliceList",
            "version": "v1alpha1"
          }
        ]
      },
      "io.kcp.apis.v1alpha1.APIExportList": {
        "description": "APIExportList is a list of APIExport",
        "type": "object",
        "required": ["items"],
        "properties": {
          "apiVersion": {
            "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
            "type": "string"
          },
          "items": {
            "description": "List of apiexports. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md",
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/io.kcp.apis.v1alpha1.APIExport"
            }
          },
          "kind": {
            "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
            "type": "string"
          },
          "metadata": {
            "description": "Standard list metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
            "allOf": [
              {
                "$ref": "#/components/schemas/io.k8s.apimachinery.pkg.apis.meta.v1.ListMeta"
              }
            ]
          }
        },
        "x-kubernetes-group-version-kind": [
          {
            "group": "apis.kcp.io",
            "kind": "APIExportList",
            "version": "v1alpha1"
          }
        ]
      },
      "io.kcp.apis.v1alpha1.APIResourceSchema": {
        "description": "APIResourceSchema describes a resource, identified by (group, version, resource, schema).\n\nAn APIResourceSchema is immutable and cannot be deleted if they are referenced by\nan APIExport in the same workspace.",
        "type": "object",
        "properties": {
          "apiVersion": {
            "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
            "type": "string"
          },
          "kind": {
            "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
            "type": "string"
          },
          "metadata": {
            "description": "Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata",
            "allOf": [
              {
                "$ref": "#/components/schemas/io.k8s.apimachinery.pkg.apis.meta.v1.ObjectMeta"
              }
            ]
          },
          "spec": {
            "description": "Spec holds the desired state.",
            "type": "object",
            "required": ["group", "names", "scope", "versions"],
            "properties": {
              "conversion": {
                "description": "conversion defines conversion settings for the defined custom resource.",
                "type": "object",
                "required": ["strategy"],
                "properties": {
                  "strategy": {
                    "description": "strategy specifies how custom resources are converted between versions. Allowed values are:\n- `\"None\"`: The converter only change the apiVersion and would not touch any other field in the custom resource.\n- `\"Webhook\"`: API Server will call to an external webhook to do the conversion. Additional information\n  is needed for this option. This requires spec.preserveUnknownFields to be false, and spec.conversion.webhook to be set.",
                    "type": "string",
                    "enum": ["None", "Webhook"]
                  },
                  "webhook": {
                    "description": "webhook describes how to call the conversion webhook. Required when `strategy` is set to `\"Webhook\"`.",
                    "type": "object",
                    "required": ["conversionReviewVersions"],
                    "properties": {
                      "clientConfig": {
                        "description": "clientConfig is the instructions for how to call the webhook if strategy is `Webhook`.",
                        "type": "object",
                        "properties": {
                          "caBundle": {
                            "description": "caBundle is a PEM encoded CA bundle which will be used to validate the webhook's server certificate.\nIf unspecified, system trust roots on the apiserver are used.",
                            "type": "string",
                            "format": "byte"
                          },
                          "url": {
                            "description": "url gives the location of the webhook, in standard URL form\n(`scheme://host:port/path`).\n\nPlease note that using `localhost` or `127.0.0.1` as a `host` is\nrisky unless you take great care to run this webhook on all hosts\nwhich run an apiserver which might need to make calls to this\nwebhook. Such installs are likely to be non-portable, i.e., not easy\nto turn up in a new cluster.\n\nThe scheme must be \"https\"; the URL must begin with \"https://\".\n\nA path is optional, and if present may be any string permissible in\na URL. You may use the path to pass an arbitrary string to the\nwebhook, for example, a cluster identifier.\n\nAttempting to use a user or basic auth e.g. \"user:password@\" is not\nallowed. Fragments (\"#...\") and query parameters (\"?...\") are not\nallowed, either.\n\nNote: kcp does not support provided service names like Kubernetes does.",
                            "type": "string",
                            "format": "uri"
                          }
                        }
                      },
                      "conversionReviewVersions": {
                        "description": "conversionReviewVersions is an ordered list of preferred `ConversionReview`\nversions the Webhook expects. The API server will use the first version in\nthe list which it supports. If none of the versions specified in this list\nare supported by API server, conversion will fail for the custom resource.\nIf a persisted Webhook configuration specifies allowed versions and does not\ninclude any versions known to the API Server, calls to the webhook will fail.",
                        "type": "array",
                        "items": { "type": "string" },
                        "x-kubernetes-list-type": "atomic",
                        "x-kubernetes-patch-strategy": "replace"
                      }
                    }
                  }
                },
                "x-kubernetes-validations": [
                  {
                    "message": "Webhook must be specified if strategy=Webhook",
                    "rule": "(self.strategy == 'None' \u0026\u0026 !has(self.webhook))  || (self.strategy == 'Webhook' \u0026\u0026 has(self.webhook))"
                  }
                ]
              },
              "group": {
                "description": "group is the API group of the defined custom resource. Empty string means the\ncore API group. \tThe resources are served under `/apis/\u003cgroup\u003e/...` or `/api` for the core group.",
                "type": "string"
              },
              "nameValidation": {
                "description": "nameValidation can be used to configure name validation for bound APIs.\nAllowed values are `DNS1123Subdomain` and `PathSegmentName`.\n- DNS1123Subdomain: a lowercase RFC 1123 subdomain must consist of lower case\n  alphanumeric characters, '-' or '.', and must start and end with an alphanumeric character.\n  Regex used is '[a-z0-9]([-a-z0-9]*[a-z0-9])?(\\\\.[a-z0-9]([-a-z0-9]*[a-z0-9])?)*'\n- PathSegmentName: validates the name can be safely encoded as a path segment.\n  The name may not be '.' or '..' and the name may not contain '/' or '%'.\n\nDefaults to `DNS1123Subdomain`, matching the behaviour of CRDs.",
                "type": "string",
                "default": "DNS1123Subdomain",
                "enum": ["DNS1123Subdomain", "PathSegmentName"]
              },
              "names": {
                "description": "names specify the resource and kind names for the custom resource.",
                "type": "object",
                "required": ["kind", "plural"],
                "properties": {
                  "categories": {
                    "description": "categories is a list of grouped resources this custom resource belongs to (e.g. 'all').\nThis is published in API discovery documents, and used by clients to support invocations like\n`kubectl get all`.",
                    "type": "array",
                    "items": { "type": "string" },
                    "x-kubernetes-list-type": "atomic",
                    "x-kubernetes-patch-strategy": "replace"
                  },
                  "kind": {
                    "description": "kind is the serialized kind of the resource. It is normally CamelCase and singular.\nCustom resource instances will use this value as the `kind` attribute in API calls.",
                    "type": "string"
                  },
                  "listKind": {
                    "description": "listKind is the serialized kind of the list for this resource. Defaults to \"`kind`List\".",
                    "type": "string"
                  },
                  "plural": {
                    "description": "plural is the plural name of the resource to serve.\nThe custom resources are served under `/apis/\u003cgroup\u003e/\u003cversion\u003e/.../\u003cplural\u003e`.\nMust match the name of the CustomResourceDefinition (in the form `\u003cnames.plural\u003e.\u003cgroup\u003e`).\nMust be all lowercase.",
                    "type": "string"
                  },
                  "shortNames": {
                    "description": "shortNames are short names for the resource, exposed in API discovery documents,\nand used by clients to support invocations like `kubectl get \u003cshortname\u003e`.\nIt must be all lowercase.",
                    "type": "array",
                    "items": { "type": "string" },
                    "x-kubernetes-list-type": "atomic",
                    "x-kubernetes-patch-strategy": "replace"
                  },
                  "singular": {
                    "description": "singular is the singular name of the resource. It must be all lowercase. Defaults to lowercased `kind`.",
                    "type": "string"
                  }
                }
              },
              "scope": {
                "description": "scope indicates whether the defined custom resource is cluster- or namespace-scoped.\nAllowed values are `Cluster` and `Namespaced`.",
                "type": "string",
                "enum": ["Cluster", "Namespaced"]
              },
              "versions": {
                "description": "versions is the API version of the defined custom resource.\n\nNote: the OpenAPI v3 schemas must be equal for all versions until CEL\n      version migration is supported.",
                "type": "array",
                "minItems": 1,
                "items": {
                  "description": "APIResourceVersion describes one API version of a resource.",
                  "type": "object",
                  "required": ["name", "schema", "served", "storage"],
                  "properties": {
                    "additionalPrinterColumns": {
                      "description": "additionalPrinterColumns specifies additional columns returned in Table output.\nSee https://kubernetes.io/docs/reference/using-api/api-concepts/#receiving-resources-as-tables for details.\nIf no columns are specified, a single column displaying the age of the custom resource is used.",
                      "type": "array",
                      "items": {
                        "description": "CustomResourceColumnDefinition specifies a column for server side printing.",
                        "type": "object",
                        "required": ["jsonPath", "name", "type"],
                        "properties": {
                          "description": {
                            "description": "description is a human readable description of this column.",
                            "type": "string"
                          },
                          "format": {
                            "description": "format is an optional OpenAPI type definition for this column. The 'name' format is applied\nto the primary identifier column to assist in clients identifying column is the resource name.\nSee https://github.com/OAI/OpenAPI-Specification/blob/master/versions/2.0.md#data-types for details.",
                            "type": "string"
                          },
                          "jsonPath": {
                            "description": "jsonPath is a simple JSON path (i.e. with array notation) which is evaluated against\neach custom resource to produce the value for this column.",
                            "type": "string"
                          },
                          "name": {
                            "description": "name is a human readable name for the column.",
                            "type": "string"
                          },
                          "priority": {
                            "description": "priority is an integer defining the relative importance of this column compared to others. Lower\nnumbers are considered higher priority. Columns that may be omitted in limited space scenarios\nshould be given a priority greater than 0.",
                            "type": "integer",
                            "format": "int32"
                          },
                          "type": {
                            "description": "type is an OpenAPI type definition for this column.\nSee https://github.com/OAI/OpenAPI-Specification/blob/master/versions/2.0.md#data-types for details.",
                            "type": "string"
                          }
                        }
                      },
                      "x-kubernetes-list-map-keys": ["name"],
                      "x-kubernetes-list-type": "map",
                      "x-kubernetes-patch-merge-key": "name",
                      "x-kubernetes-patch-strategy": "merge"
                    },
                    "deprecated": {
                      "description": "deprecated indicates this version of the custom resource API is deprecated.\nWhen set to true, API requests to this version receive a warning header in the server response.\nDefaults to false.",
                      "type": "boolean"
                    },
                    "deprecationWarning": {
                      "description": "deprecationWarning overrides the default warning returned to API clients.\nMay only be set when `deprecated` is true.\nThe default warning indicates this version is deprecated and recommends use\nof the newest served version of equal or greater stability, if one exists.",
                      "type": "string"
                    },
                    "name": {
                      "description": "name is the version name, e.g. “v1”, “v2beta1”, etc.\nThe custom resources are served under this version at `/apis/\u003cgroup\u003e/\u003cversion\u003e/...` if `served` is true.",
                      "type": "string",
                      "minLength": 1,
                      "pattern": "^v[1-9][0-9]*([a-z]+[1-9][0-9]*)?$"
                    },
                    "schema": {
                      "description": "schema describes the structural schema used for validation, pruning, and defaulting\nof this version of the custom resource.",
                      "type": "object",
                      "x-kubernetes-map-type": "atomic",
                      "x-kubernetes-patch-strategy": "replace",
                      "x-kubernetes-preserve-unknown-fields": true
                    },
                    "served": {
                      "description": "served is a flag enabling/disabling this version from being served via REST APIs",
                      "type": "boolean",
                      "default": true
                    },
                    "storage": {
                      "description": "storage indicates this version should be used when persisting custom resources to storage.\nThere must be exactly one version with storage=true.",
                      "type": "boolean"
                    },
                    "subresources": {
                      "description": "subresources specify what subresources this version of the defined custom resource have.",
                      "type": "object",
                      "properties": {
                        "scale": {
                          "description": "scale indicates the custom resource should serve a `/scale` subresource that returns an `autoscaling/v1` Scale object.",
                          "type": "object",
                          "required": [
                            "specReplicasPath",
                            "statusReplicasPath"
                          ],
                          "properties": {
                            "labelSelectorPath": {
                              "description": "labelSelectorPath defines the JSON path inside of a custom resource that corresponds to Scale `status.selector`.\nOnly JSON paths without the array notation are allowed.\nMust be a JSON Path under `.status` or `.spec`.\nMust be set to work with HorizontalPodAutoscaler.\nThe field pointed by this JSON path must be a string field (not a complex selector struct)\nwhich contains a serialized label selector in string form.\nMore info: https://kubernetes.io/docs/tasks/access-kubernetes-api/custom-resources/custom-resource-definitions#scale-subresource\nIf there is no value under the given path in the custom resource, the `status.selector` value in the `/scale`\nsubresource will default to the empty string.",
                              "type": "string"
                            },
                            "specReplicasPath": {
                              "description": "specReplicasPath defines the JSON path inside of a custom resource that corresponds to Scale `spec.replicas`.\nOnly JSON paths without the array notation are allowed.\nMust be a JSON Path under `.spec`.\nIf there is no value under the given path in the custom resource, the `/scale` subresource will return an error on GET.",
                              "type": "string"
                            },
                            "statusReplicasPath": {
                              "description": "statusReplicasPath defines the JSON path inside of a custom resource that corresponds to Scale `status.replicas`.\nOnly JSON paths without the array notation are allowed.\nMust be a JSON Path under `.status`.\nIf there is no value under the given path in the custom resource, the `status.replicas` value in the `/scale` subresource\nwill default to 0.",
                              "type": "string"
                            }
                          }
                        },
                        "status": {
                          "description": "status indicates the custom resource should serve a `/status` subresource.\nWhen enabled:\n1. requests to the custom resource primary endpoint ignore changes to the `status` stanza of the object.\n2. requests to the custom resource `/status` subresource ignore changes to anything other than the `status` stanza of the object.",
                          "type": "object"
                        }
                      }
                    }
                  }
                },
                "x-kubernetes-list-map-keys": ["name"],
                "x-kubernetes-list-type": "map",
                "x-kubernetes-patch-merge-key": "name",
                "x-kubernetes-patch-strategy": "merge"
              }
            },
            "x-kubernetes-validations": [
              {
                "message": "Conversion must be specified when multiple versions exist",
                "rule": "size(self.versions) == 1 || (size(self.versions) \u003e 1 \u0026\u0026 has(self.conversion))"
              }
            ]
          }
        },
        "x-kubernetes-group-version-kind": [
          {
            "group": "apis.kcp.io",
            "kind": "APIResourceSchema",
            "version": "v1alpha1"
          }
        ]
      },
      "io.kcp.apis.v1alpha1.APIResourceSchemaList": {
        "description": "APIResourceSchemaList is a list of APIResourceSchema",
        "type": "object",
        "required": ["items"],
        "properties": {
          "apiVersion": {
            "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
            "type": "string"
          },
          "items": {
            "description": "List of apiresourceschemas. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md",
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/io.kcp.apis.v1alpha1.APIResourceSchema"
            }
          },
          "kind": {
            "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
            "type": "string"
          },
          "metadata": {
            "description": "Standard list metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
            "allOf": [
              {
                "$ref": "#/components/schemas/io.k8s.apimachinery.pkg.apis.meta.v1.ListMeta"
              }
            ]
          }
        },
        "x-kubernetes-group-version-kind": [
          {
            "group": "apis.kcp.io",
            "kind": "APIResourceSchemaList",
            "version": "v1alpha1"
          }
        ]
      },
      "io.kcp.core.v1alpha1.LogicalCluster": {
        "description": "LogicalCluster describes the current logical cluster. It is used to authorize\nrequests to the logical cluster and to track state.\n\nA LogicalCluster is always named \"cluster\".",
        "type": "object",
        "properties": {
          "apiVersion": {
            "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
            "type": "string"
          },
          "kind": {
            "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
            "type": "string"
          },
          "metadata": {
            "description": "Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata",
            "allOf": [
              {
                "$ref": "#/components/schemas/io.k8s.apimachinery.pkg.apis.meta.v1.ObjectMeta"
              }
            ]
          },
          "spec": {
            "description": "LogicalClusterSpec is the specification of the LogicalCluster resource.",
            "type": "object",
            "default": {},
            "properties": {
              "directlyDeletable": {
                "description": "DirectlyDeletable indicates that this logical cluster can be directly deleted by the user\nfrom within by deleting the LogicalCluster object.",
                "type": "boolean",
                "default": false
              },
              "initializers": {
                "description": "initializers are set on creation by the system and copied to status when\ninitialization starts.",
                "type": "array",
                "items": {
                  "description": "LogicalClusterInitializer is a unique string corresponding to a logical cluster\ninitialization controller.",
                  "type": "string",
                  "pattern": "^([a-z0-9]([-a-z0-9]*[a-z0-9])?(:[a-z0-9]([-a-z0-9]*[a-z0-9])?)*(:[a-z0-9][a-z0-9]([-a-z0-9]*[a-z0-9])?))|(system:.+)$"
                }
              },
              "owner": {
                "description": "owner is a reference to a resource controlling the life-cycle of this logical cluster.\nOn deletion of the LogicalCluster, the finalizer core.kcp.io/logicalcluster is\nremoved from the owner.\n\nWhen this object is deleted, but the owner is not deleted, the owner is deleted\ntoo.",
                "type": "object",
                "required": [
                  "apiVersion",
                  "cluster",
                  "name",
                  "resource",
                  "uid"
                ],
                "properties": {
                  "apiVersion": {
                    "description": "apiVersion is the group and API version of the owner.",
                    "type": "string",
                    "pattern": "^([^/]+/)?[^/]+$"
                  },
                  "cluster": {
                    "description": "cluster is the logical cluster in which the owner is located.",
                    "type": "string",
                    "minLength": 1
                  },
                  "name": {
                    "description": "name is the name of the owner.",
                    "type": "string",
                    "minLength": 1
                  },
                  "namespace": {
                    "description": "namespace is the optional namespace of the owner.",
                    "type": "string"
                  },
                  "resource": {
                    "description": "resource is API resource to access the owner.",
                    "type": "string",
                    "minLength": 1
                  },
                  "uid": {
                    "description": "UID is the UID of the owner.",
                    "type": "string"
                  }
                }
              }
            }
          },
          "status": {
            "description": "LogicalClusterStatus communicates the observed state of the Workspace.",
            "type": "object",
            "default": {},
            "properties": {
              "URL": {
                "description": "url is the address under which the Kubernetes-cluster-like endpoint\ncan be found. This URL can be used to access the logical cluster with standard Kubernetes\nclient libraries and command line tools.",
                "type": "string"
              },
              "conditions": {
                "description": "Current processing state of the LogicalCluster.",
                "type": "array",
                "items": {
                  "description": "Condition defines an observation of a object operational state.",
                  "type": "object",
                  "required": ["lastTransitionTime", "status", "type"],
                  "properties": {
                    "lastTransitionTime": {
                      "description": "Last time the condition transitioned from one status to another.\nThis should be when the underlying condition changed. If that is not known, then using the time when\nthe API field changed is acceptable.",
                      "type": "string",
                      "format": "date-time"
                    },
                    "message": {
                      "description": "A human readable message indicating details about the transition.\nThis field may be empty.",
                      "type": "string"
                    },
                    "reason": {
                      "description": "The reason for the condition's last transition in CamelCase.\nThe specific API may choose whether or not this field is considered a guaranteed API.\nThis field may not be empty.",
                      "type": "string"
                    },
                    "severity": {
                      "description": "Severity provides an explicit classification of Reason code, so the users or machines can immediately\nunderstand the current situation and act accordingly.\nThe Severity field MUST be set only when Status=False.",
                      "type": "string"
                    },
                    "status": {
                      "description": "Status of the condition, one of True, False, Unknown.",
                      "type": "string"
                    },
                    "type": {
                      "description": "Type of condition in CamelCase or in foo.example.com/CamelCase.\nMany .condition.type values are consistent across resources like Available, but because arbitrary conditions\ncan be useful (see .node.status.conditions), the ability to deconflict is important.",
                      "type": "string"
                    }
                  }
                }
              },
              "initializers": {
                "description": "initializers are set on creation by the system and must be cleared\nby a controller before the logical cluster can be used. The LogicalCluster object\nwill stay in the phase \"Initializing\" state until all initializers are cleared.",
                "type": "array",
                "items": {
                  "description": "LogicalClusterInitializer is a unique string corresponding to a logical cluster\ninitialization controller.",
                  "type": "string",
                  "pattern": "^([a-z0-9]([-a-z0-9]*[a-z0-9])?(:[a-z0-9]([-a-z0-9]*[a-z0-9])?)*(:[a-z0-9][a-z0-9]([-a-z0-9]*[a-z0-9])?))|(system:.+)$"
                }
              },
              "phase": {
                "description": "Phase of the logical cluster (Initializing, Ready).",
                "type": "string",
                "default": "Scheduling",
                "enum": ["Scheduling", "Initializing", "Ready"]
              }
            }
          }
        },
        "x-kubernetes-group-version-kind": [
          {
            "group": "core.kcp.io",
            "kind": "LogicalCluster",
            "version": "v1alpha1"
          }
        ]
      },
      "io.kcp.core.v1alpha1.LogicalClusterList": {
        "description": "LogicalClusterList is a list of LogicalCluster",
        "type": "object",
        "required": ["items"],
        "properties": {
          "apiVersion": {
            "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
            "type": "string"
          },
          "items": {
            "description": "List of logicalclusters. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md",
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/io.kcp.core.v1alpha1.LogicalCluster"
            }
          },
          "kind": {
            "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
            "type": "string"
          },
          "metadata": {
            "description": "Standard list metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
            "allOf": [
              {
                "$ref": "#/components/schemas/io.k8s.apimachinery.pkg.apis.meta.v1.ListMeta"
              }
            ]
          }
        },
        "x-kubernetes-group-version-kind": [
          {
            "group": "core.kcp.io",
            "kind": "LogicalClusterList",
            "version": "v1alpha1"
          }
        ]
      },
      "io.kcp.core.v1alpha1.Shard": {
        "description": "Shard describes a kcp instance on which a number of logical clusters will live",
        "type": "object",
        "properties": {
          "apiVersion": {
            "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
            "type": "string"
          },
          "kind": {
            "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
            "type": "string"
          },
          "metadata": {
            "description": "Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata",
            "allOf": [
              {
                "$ref": "#/components/schemas/io.k8s.apimachinery.pkg.apis.meta.v1.ObjectMeta"
              }
            ]
          },
          "spec": {
            "description": "ShardSpec holds the desired state of the Shard.",
            "type": "object",
            "required": ["baseURL"],
            "properties": {
              "baseURL": {
                "description": "baseURL is the address of the KCP shard for direct connections, e.g. by some\nfront-proxy doing the fan-out to the shards.",
                "type": "string",
                "format": "uri",
                "minLength": 1
              },
              "externalURL": {
                "description": "externalURL is the externally visible address presented to users in Workspace URLs.\nChanging this will break all existing logical clusters on that shard, i.e. existing\nkubeconfigs of clients will be invalid. Hence, when changing this value, the old\nURL used by clients must keep working.\n\nThe external address will not be unique if a front-proxy does a fan-out to\nshards, but all logical cluster clients will talk to the front-proxy. In that case,\nput the address of the front-proxy here.\n\nNote that movement of shards is only possible (in the future) between shards\nthat share a common external URL.\n\nThis will be defaulted to the value of the baseURL.",
                "type": "string",
                "format": "uri",
                "minLength": 1
              },
              "virtualWorkspaceURL": {
                "description": "virtualWorkspaceURL is the address of the virtual workspace apiserver associated with this shard.\nIt can be a direct address, an address of a front-proxy or even an address of an LB.\nAs of today this address is assigned to APIExports.\n\nThis will be defaulted to the value of the baseURL.",
                "type": "string",
                "format": "uri",
                "minLength": 1
              }
            }
          },
          "status": {
            "description": "ShardStatus communicates the observed state of the Shard.",
            "type": "object",
            "properties": {
              "capacity": {
                "description": "Set of integer resources that logical clusters can be scheduled into",
                "type": "object",
                "additionalProperties": {
                  "pattern": "^(\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))(([KMGTPE]i)|[numkMGTPE]|([eE](\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))))?$",
                  "anyOf": [{ "type": "integer" }, { "type": "string" }],
                  "x-kubernetes-int-or-string": true
                }
              },
              "conditions": {
                "description": "Current processing state of the Shard.",
                "type": "array",
                "items": {
                  "description": "Condition defines an observation of a object operational state.",
                  "type": "object",
                  "required": ["lastTransitionTime", "status", "type"],
                  "properties": {
                    "lastTransitionTime": {
                      "description": "Last time the condition transitioned from one status to another.\nThis should be when the underlying condition changed. If that is not known, then using the time when\nthe API field changed is acceptable.",
                      "type": "string",
                      "format": "date-time"
                    },
                    "message": {
                      "description": "A human readable message indicating details about the transition.\nThis field may be empty.",
                      "type": "string"
                    },
                    "reason": {
                      "description": "The reason for the condition's last transition in CamelCase.\nThe specific API may choose whether or not this field is considered a guaranteed API.\nThis field may not be empty.",
                      "type": "string"
                    },
                    "severity": {
                      "description": "Severity provides an explicit classification of Reason code, so the users or machines can immediately\nunderstand the current situation and act accordingly.\nThe Severity field MUST be set only when Status=False.",
                      "type": "string"
                    },
                    "status": {
                      "description": "Status of the condition, one of True, False, Unknown.",
                      "type": "string"
                    },
                    "type": {
                      "description": "Type of condition in CamelCase or in foo.example.com/CamelCase.\nMany .condition.type values are consistent across resources like Available, but because arbitrary conditions\ncan be useful (see .node.status.conditions), the ability to deconflict is important.",
                      "type": "string"
                    }
                  }
                }
              }
            }
          }
        },
        "x-kubernetes-group-version-kind": [
          { "group": "core.kcp.io", "kind": "Shard", "version": "v1alpha1" }
        ]
      },
      "io.kcp.core.v1alpha1.ShardList": {
        "description": "ShardList is a list of Shard",
        "type": "object",
        "required": ["items"],
        "properties": {
          "apiVersion": {
            "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
            "type": "string"
          },
          "items": {
            "description": "List of shards. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md",
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/io.kcp.core.v1alpha1.Shard"
            }
          },
          "kind": {
            "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
            "type": "string"
          },
          "metadata": {
            "description": "Standard list metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
            "allOf": [
              {
                "$ref": "#/components/schemas/io.k8s.apimachinery.pkg.apis.meta.v1.ListMeta"
              }
            ]
          }
        },
        "x-kubernetes-group-version-kind": [
          { "group": "core.kcp.io", "kind": "ShardList", "version": "v1alpha1" }
        ]
      },
      "io.kcp.tenancy.v1alpha1.Workspace": {
        "description": "Workspace defines a generic Kubernetes-cluster-like endpoint, with standard Kubernetes\ndiscovery APIs, OpenAPI and resource API endpoints.\n\nA workspace can be backed by different concrete types of workspace implementation,\ndepending on access pattern. All workspace implementations share the characteristic\nthat the URL that serves a given workspace can be used with standard Kubernetes\nAPI machinery and client libraries and command line tools.",
        "type": "object",
        "required": ["spec"],
        "properties": {
          "apiVersion": {
            "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
            "type": "string"
          },
          "kind": {
            "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
            "type": "string"
          },
          "metadata": {
            "description": "Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata",
            "allOf": [
              {
                "$ref": "#/components/schemas/io.k8s.apimachinery.pkg.apis.meta.v1.ObjectMeta"
              }
            ]
          },
          "spec": {
            "description": "WorkspaceSpec holds the desired state of the Workspace.",
            "type": "object",
            "default": {},
            "properties": {
              "URL": {
                "description": "URL is the address under which the Kubernetes-cluster-like endpoint\ncan be found. This URL can be used to access the workspace with standard Kubernetes\nclient libraries and command line tools.\n\nSet by the system.",
                "type": "string"
              },
              "cluster": {
                "description": "cluster is the name of the logical cluster this workspace is stored under.\n\nSet by the system.",
                "type": "string",
                "x-kubernetes-validations": [
                  {
                    "message": "cluster is immutable",
                    "rule": "self == oldSelf"
                  }
                ]
              },
              "location": {
                "description": "location constraints where this workspace can be scheduled to.\n\nIf the no location is specified, an arbitrary location is chosen.",
                "type": "object",
                "properties": {
                  "selector": {
                    "description": "selector is a label selector that filters workspace scheduling targets.",
                    "type": "object",
                    "properties": {
                      "matchExpressions": {
                        "description": "matchExpressions is a list of label selector requirements. The requirements are ANDed.",
                        "type": "array",
                        "items": {
                          "description": "A label selector requirement is a selector that contains values, a key, and an operator that\nrelates the key and values.",
                          "type": "object",
                          "required": ["key", "operator"],
                          "properties": {
                            "key": {
                              "description": "key is the label key that the selector applies to.",
                              "type": "string"
                            },
                            "operator": {
                              "description": "operator represents a key's relationship to a set of values.\nValid operators are In, NotIn, Exists and DoesNotExist.",
                              "type": "string"
                            },
                            "values": {
                              "description": "values is an array of string values. If the operator is In or NotIn,\nthe values array must be non-empty. If the operator is Exists or DoesNotExist,\nthe values array must be empty. This array is replaced during a strategic\nmerge patch.",
                              "type": "array",
                              "items": { "type": "string" },
                              "x-kubernetes-list-type": "atomic",
                              "x-kubernetes-patch-strategy": "replace"
                            }
                          }
                        },
                        "x-kubernetes-list-type": "atomic",
                        "x-kubernetes-patch-strategy": "replace"
                      },
                      "matchLabels": {
                        "description": "matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels\nmap is equivalent to an element of matchExpressions, whose key field is \"key\", the\noperator is \"In\", and the values array contains only \"value\". The requirements are ANDed.",
                        "type": "object",
                        "additionalProperties": { "type": "string" }
                      }
                    },
                    "x-kubernetes-map-type": "atomic",
                    "x-kubernetes-patch-strategy": "replace"
                  }
                }
              },
              "type": {
                "description": "type defines properties of the workspace both on creation (e.g. initial\nresources and initially installed APIs) and during runtime (e.g. permissions).\nIf no type is provided, the default type for the workspace in which this workspace\nis nesting will be used.\n\nThe type is a reference to a WorkspaceType in the listed workspace, but\nlower-cased. The WorkspaceType existence is validated at admission during\ncreation. The type is immutable after creation. The use of a type is gated via\nthe RBAC workspacetypes/use resource permission.",
                "type": "object",
                "required": ["name"],
                "properties": {
                  "name": {
                    "description": "name is the name of the WorkspaceType",
                    "type": "string",
                    "pattern": "^[a-z]([a-z0-9-]{0,61}[a-z0-9])?"
                  },
                  "path": {
                    "description": "path is an absolute reference to the workspace that owns this type, e.g. root:org:ws.",
                    "type": "string",
                    "pattern": "^[a-z0-9]([-a-z0-9]*[a-z0-9])?(:[a-z0-9]([-a-z0-9]*[a-z0-9])?)*$"
                  }
                },
                "x-kubernetes-validations": [
                  {
                    "message": "name is immutable",
                    "rule": "self.name == oldSelf.name"
                  },
                  {
                    "message": "path is immutable",
                    "rule": "has(oldSelf.path) == has(self.path)"
                  },
                  {
                    "message": "path is immutable",
                    "rule": "!has(oldSelf.path) || !has(self.path) || self.path == oldSelf.path"
                  }
                ]
              }
            },
            "x-kubernetes-validations": [
              {
                "message": "URL cannot be unset",
                "rule": "!has(oldSelf.URL) || has(self.URL)"
              },
              {
                "message": "cluster cannot be unset",
                "rule": "!has(oldSelf.cluster) || has(self.cluster)"
              }
            ]
          },
          "status": {
            "description": "WorkspaceStatus communicates the observed state of the Workspace.",
            "type": "object",
            "default": {},
            "properties": {
              "conditions": {
                "description": "Current processing state of the Workspace.",
                "type": "array",
                "items": {
                  "description": "Condition defines an observation of a object operational state.",
                  "type": "object",
                  "required": ["lastTransitionTime", "status", "type"],
                  "properties": {
                    "lastTransitionTime": {
                      "description": "Last time the condition transitioned from one status to another.\nThis should be when the underlying condition changed. If that is not known, then using the time when\nthe API field changed is acceptable.",
                      "type": "string",
                      "format": "date-time"
                    },
                    "message": {
                      "description": "A human readable message indicating details about the transition.\nThis field may be empty.",
                      "type": "string"
                    },
                    "reason": {
                      "description": "The reason for the condition's last transition in CamelCase.\nThe specific API may choose whether or not this field is considered a guaranteed API.\nThis field may not be empty.",
                      "type": "string"
                    },
                    "severity": {
                      "description": "Severity provides an explicit classification of Reason code, so the users or machines can immediately\nunderstand the current situation and act accordingly.\nThe Severity field MUST be set only when Status=False.",
                      "type": "string"
                    },
                    "status": {
                      "description": "Status of the condition, one of True, False, Unknown.",
                      "type": "string"
                    },
                    "type": {
                      "description": "Type of condition in CamelCase or in foo.example.com/CamelCase.\nMany .condition.type values are consistent across resources like Available, but because arbitrary conditions\ncan be useful (see .node.status.conditions), the ability to deconflict is important.",
                      "type": "string"
                    }
                  }
                }
              },
              "initializers": {
                "description": "initializers must be cleared by a controller before the workspace is ready\nand can be used.",
                "type": "array",
                "items": {
                  "description": "LogicalClusterInitializer is a unique string corresponding to a logical cluster\ninitialization controller.",
                  "type": "string",
                  "pattern": "^([a-z0-9]([-a-z0-9]*[a-z0-9])?(:[a-z0-9]([-a-z0-9]*[a-z0-9])?)*(:[a-z0-9][a-z0-9]([-a-z0-9]*[a-z0-9])?))|(system:.+)$"
                }
              },
              "phase": {
                "description": "Phase of the workspace (Scheduling, Initializing, Ready).",
                "type": "string",
                "default": "Scheduling",
                "enum": ["Scheduling", "Initializing", "Ready"]
              }
            }
          }
        },
        "x-kubernetes-group-version-kind": [
          {
            "group": "tenancy.kcp.io",
            "kind": "Workspace",
            "version": "v1alpha1"
          }
        ]
      },
      "io.kcp.tenancy.v1alpha1.WorkspaceList": {
        "description": "WorkspaceList is a list of Workspace",
        "type": "object",
        "required": ["items"],
        "properties": {
          "apiVersion": {
            "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
            "type": "string"
          },
          "items": {
            "description": "List of workspaces. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md",
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/io.kcp.tenancy.v1alpha1.Workspace"
            }
          },
          "kind": {
            "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
            "type": "string"
          },
          "metadata": {
            "description": "Standard list metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
            "allOf": [
              {
                "$ref": "#/components/schemas/io.k8s.apimachinery.pkg.apis.meta.v1.ListMeta"
              }
            ]
          }
        },
        "x-kubernetes-group-version-kind": [
          {
            "group": "tenancy.kcp.io",
            "kind": "WorkspaceList",
            "version": "v1alpha1"
          }
        ]
      },
      "io.kcp.tenancy.v1alpha1.WorkspaceType": {
        "description": "WorkspaceType specifies behaviour of workspaces of this type.",
        "type": "object",
        "properties": {
          "apiVersion": {
            "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
            "type": "string"
          },
          "kind": {
            "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
            "type": "string"
          },
          "metadata": {
            "description": "Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata",
            "allOf": [
              {
                "$ref": "#/components/schemas/io.k8s.apimachinery.pkg.apis.meta.v1.ObjectMeta"
              }
            ]
          },
          "spec": {
            "type": "object",
            "properties": {
              "additionalWorkspaceLabels": {
                "description": "additionalWorkspaceLabels are a set of labels that will be added to a\nWorkspace on creation.",
                "type": "object",
                "additionalProperties": { "type": "string" }
              },
              "defaultAPIBindings": {
                "description": "defaultAPIBindings are the APIs to bind during initialization of workspaces created from this type.\nThe APIBinding names will be generated dynamically.",
                "type": "array",
                "items": {
                  "description": "APIExportReference provides the fields necessary to resolve an APIExport.",
                  "type": "object",
                  "required": ["export"],
                  "properties": {
                    "export": {
                      "description": "export is the name of the APIExport.",
                      "type": "string"
                    },
                    "path": {
                      "description": "path is the fully-qualified path to the workspace containing the APIExport. If it is\nempty, the current workspace is assumed.",
                      "type": "string",
                      "pattern": "^[a-z0-9]([-a-z0-9]*[a-z0-9])?(:[a-z0-9]([-a-z0-9]*[a-z0-9])?)*$"
                    }
                  }
                }
              },
              "defaultChildWorkspaceType": {
                "description": "defaultChildWorkspaceType is the WorkspaceType that will be used\nby default if another, nested Workspace is created in a workspace\nof this type. When this field is unset, the user must specify a type when\ncreating nested workspaces. Extending another WorkspaceType does\nnot inherit its defaultChildWorkspaceType.",
                "type": "object",
                "default": { "name": "universal", "path": "root" },
                "required": ["name"],
                "properties": {
                  "name": {
                    "description": "name is the name of the WorkspaceType",
                    "type": "string",
                    "pattern": "^[a-z]([a-z0-9-]{0,61}[a-z0-9])?"
                  },
                  "path": {
                    "description": "path is an absolute reference to the workspace that owns this type, e.g. root:org:ws.",
                    "type": "string",
                    "pattern": "^[a-z0-9]([-a-z0-9]*[a-z0-9])?(:[a-z0-9]([-a-z0-9]*[a-z0-9])?)*$"
                  }
                }
              },
              "extend": {
                "description": "extend is a list of other WorkspaceTypes whose initializers and limitAllowedChildren\nand limitAllowedParents this WorkspaceType is inheriting. By (transitively) extending\nanother WorkspaceType, this WorkspaceType will be considered as that\nother type in evaluation of limitAllowedChildren and limitAllowedParents constraints.\n\nA dependency cycle stop this WorkspaceType from being admitted as the type\nof a Workspace.\n\nA non-existing dependency stop this WorkspaceType from being admitted as the type\nof a Workspace.",
                "type": "object",
                "properties": {
                  "with": {
                    "description": "with are WorkspaceTypes whose initializers are added to the list\nfor the owning type, and for whom the owning type becomes an alias, as long\nas all of their required types are not mentioned in without.",
                    "type": "array",
                    "items": {
                      "description": "WorkspaceTypeReference is a globally unique, fully qualified reference to a workspace type.",
                      "type": "object",
                      "required": ["name"],
                      "properties": {
                        "name": {
                          "description": "name is the name of the WorkspaceType",
                          "type": "string",
                          "pattern": "^[a-z]([a-z0-9-]{0,61}[a-z0-9])?"
                        },
                        "path": {
                          "description": "path is an absolute reference to the workspace that owns this type, e.g. root:org:ws.",
                          "type": "string",
                          "pattern": "^[a-z0-9]([-a-z0-9]*[a-z0-9])?(:[a-z0-9]([-a-z0-9]*[a-z0-9])?)*$"
                        }
                      }
                    }
                  }
                }
              },
              "initializer": {
                "description": "initializer determines if this WorkspaceType has an associated initializing\ncontroller. These controllers are used to add functionality to a Workspace;\nall controllers must finish their work before the Workspace becomes ready\nfor use.\n\nOne initializing controller is supported per WorkspaceType; the identifier\nfor this initializer will be a colon-delimited string using the workspace in which\nthe WorkspaceType is defined, and the type's name. For example, if a\nWorkspaceType `example` is created in the `root:org` workspace, the implicit\ninitializer name is `root:org:Example`.",
                "type": "boolean"
              },
              "limitAllowedChildren": {
                "description": "limitAllowedChildren specifies constraints for sub-workspaces created in workspaces\nof this type. These are in addition to child constraints of types this one extends.",
                "type": "object",
                "oneOf": [{ "required": ["none"] }, { "required": ["types"] }],
                "properties": {
                  "none": {
                    "description": "none means that no type matches.",
                    "type": "boolean"
                  },
                  "types": {
                    "description": "types is a list of WorkspaceTypes that match. A workspace type extending\nanother workspace type automatically is considered as that extended type as well\n(even transitively).\n\nAn empty list matches all types.",
                    "type": "array",
                    "minItems": 1,
                    "items": {
                      "description": "WorkspaceTypeReference is a globally unique, fully qualified reference to a workspace type.",
                      "type": "object",
                      "required": ["name"],
                      "properties": {
                        "name": {
                          "description": "name is the name of the WorkspaceType",
                          "type": "string",
                          "pattern": "^[a-z]([a-z0-9-]{0,61}[a-z0-9])?"
                        },
                        "path": {
                          "description": "path is an absolute reference to the workspace that owns this type, e.g. root:org:ws.",
                          "type": "string",
                          "pattern": "^[a-z0-9]([-a-z0-9]*[a-z0-9])?(:[a-z0-9]([-a-z0-9]*[a-z0-9])?)*$"
                        }
                      }
                    }
                  }
                }
              },
              "limitAllowedParents": {
                "description": "limitAllowedParents specifies constraints for the parent workspace that workspaces\nof this type are created in. These are in addition to parent constraints of types this one\nextends.",
                "type": "object",
                "oneOf": [{ "required": ["none"] }, { "required": ["types"] }],
                "properties": {
                  "none": {
                    "description": "none means that no type matches.",
                    "type": "boolean"
                  },
                  "types": {
                    "description": "types is a list of WorkspaceTypes that match. A workspace type extending\nanother workspace type automatically is considered as that extended type as well\n(even transitively).\n\nAn empty list matches all types.",
                    "type": "array",
                    "minItems": 1,
                    "items": {
                      "description": "WorkspaceTypeReference is a globally unique, fully qualified reference to a workspace type.",
                      "type": "object",
                      "required": ["name"],
                      "properties": {
                        "name": {
                          "description": "name is the name of the WorkspaceType",
                          "type": "string",
                          "pattern": "^[a-z]([a-z0-9-]{0,61}[a-z0-9])?"
                        },
                        "path": {
                          "description": "path is an absolute reference to the workspace that owns this type, e.g. root:org:ws.",
                          "type": "string",
                          "pattern": "^[a-z0-9]([-a-z0-9]*[a-z0-9])?(:[a-z0-9]([-a-z0-9]*[a-z0-9])?)*$"
                        }
                      }
                    }
                  }
                }
              }
            }
          },
          "status": {
            "description": "WorkspaceTypeStatus defines the observed state of WorkspaceType.",
            "type": "object",
            "properties": {
              "conditions": {
                "description": "conditions is a list of conditions that apply to the APIExport.",
                "type": "array",
                "items": {
                  "description": "Condition defines an observation of a object operational state.",
                  "type": "object",
                  "required": ["lastTransitionTime", "status", "type"],
                  "properties": {
                    "lastTransitionTime": {
                      "description": "Last time the condition transitioned from one status to another.\nThis should be when the underlying condition changed. If that is not known, then using the time when\nthe API field changed is acceptable.",
                      "type": "string",
                      "format": "date-time"
                    },
                    "message": {
                      "description": "A human readable message indicating details about the transition.\nThis field may be empty.",
                      "type": "string"
                    },
                    "reason": {
                      "description": "The reason for the condition's last transition in CamelCase.\nThe specific API may choose whether or not this field is considered a guaranteed API.\nThis field may not be empty.",
                      "type": "string"
                    },
                    "severity": {
                      "description": "Severity provides an explicit classification of Reason code, so the users or machines can immediately\nunderstand the current situation and act accordingly.\nThe Severity field MUST be set only when Status=False.",
                      "type": "string"
                    },
                    "status": {
                      "description": "Status of the condition, one of True, False, Unknown.",
                      "type": "string"
                    },
                    "type": {
                      "description": "Type of condition in CamelCase or in foo.example.com/CamelCase.\nMany .condition.type values are consistent across resources like Available, but because arbitrary conditions\ncan be useful (see .node.status.conditions), the ability to deconflict is important.",
                      "type": "string"
                    }
                  }
                }
              },
              "virtualWorkspaces": {
                "description": "virtualWorkspaces contains all APIExport virtual workspace URLs.",
                "type": "array",
                "items": {
                  "type": "object",
                  "required": ["url"],
                  "properties": {
                    "url": {
                      "description": "url is a WorkspaceType initialization virtual workspace URL.",
                      "type": "string",
                      "minLength": 1
                    }
                  }
                }
              }
            }
          }
        },
        "x-kubernetes-group-version-kind": [
          {
            "group": "tenancy.kcp.io",
            "kind": "WorkspaceType",
            "version": "v1alpha1"
          }
        ]
      },
      "io.kcp.tenancy.v1alpha1.WorkspaceTypeList": {
        "description": "WorkspaceTypeList is a list of WorkspaceType",
        "type": "object",
        "required": ["items"],
        "properties": {
          "apiVersion": {
            "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
            "type": "string"
          },
          "items": {
            "description": "List of workspacetypes. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md",
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/io.kcp.tenancy.v1alpha1.WorkspaceType"
            }
          },
          "kind": {
            "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
            "type": "string"
          },
          "metadata": {
            "description": "Standard list metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
            "allOf": [
              {
                "$ref": "#/components/schemas/io.k8s.apimachinery.pkg.apis.meta.v1.ListMeta"
              }
            ]
          }
        },
        "x-kubernetes-group-version-kind": [
          {
            "group": "tenancy.kcp.io",
            "kind": "WorkspaceTypeList",
            "version": "v1alpha1"
          }
        ]
      },
      "io.kcp.topology.v1alpha1.Partition": {
        "description": "Partition defines the selection of a set of shards along multiple dimensions.\nPartitions can get automatically generated through a partitioner or manually crafted.",
        "type": "object",
        "required": ["spec"],
        "properties": {
          "apiVersion": {
            "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
            "type": "string"
          },
          "kind": {
            "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
            "type": "string"
          },
          "metadata": {
            "description": "Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata",
            "allOf": [
              {
                "$ref": "#/components/schemas/io.k8s.apimachinery.pkg.apis.meta.v1.ObjectMeta"
              }
            ]
          },
          "spec": {
            "description": "spec holds the desired state.",
            "type": "object",
            "properties": {
              "selector": {
                "description": "selector (optional) is a label selector that filters shard targets.",
                "type": "object",
                "properties": {
                  "matchExpressions": {
                    "description": "matchExpressions is a list of label selector requirements. The requirements are ANDed.",
                    "type": "array",
                    "items": {
                      "description": "A label selector requirement is a selector that contains values, a key, and an operator that\nrelates the key and values.",
                      "type": "object",
                      "required": ["key", "operator"],
                      "properties": {
                        "key": {
                          "description": "key is the label key that the selector applies to.",
                          "type": "string"
                        },
                        "operator": {
                          "description": "operator represents a key's relationship to a set of values.\nValid operators are In, NotIn, Exists and DoesNotExist.",
                          "type": "string"
                        },
                        "values": {
                          "description": "values is an array of string values. If the operator is In or NotIn,\nthe values array must be non-empty. If the operator is Exists or DoesNotExist,\nthe values array must be empty. This array is replaced during a strategic\nmerge patch.",
                          "type": "array",
                          "items": { "type": "string" },
                          "x-kubernetes-list-type": "atomic",
                          "x-kubernetes-patch-strategy": "replace"
                        }
                      }
                    },
                    "x-kubernetes-list-type": "atomic",
                    "x-kubernetes-patch-strategy": "replace"
                  },
                  "matchLabels": {
                    "description": "matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels\nmap is equivalent to an element of matchExpressions, whose key field is \"key\", the\noperator is \"In\", and the values array contains only \"value\". The requirements are ANDed.",
                    "type": "object",
                    "additionalProperties": { "type": "string" }
                  }
                },
                "x-kubernetes-map-type": "atomic",
                "x-kubernetes-patch-strategy": "replace"
              }
            }
          }
        },
        "x-kubernetes-group-version-kind": [
          {
            "group": "topology.kcp.io",
            "kind": "Partition",
            "version": "v1alpha1"
          }
        ]
      },
      "io.kcp.topology.v1alpha1.PartitionList": {
        "description": "PartitionList is a list of Partition",
        "type": "object",
        "required": ["items"],
        "properties": {
          "apiVersion": {
            "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
            "type": "string"
          },
          "items": {
            "description": "List of partitions. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md",
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/io.kcp.topology.v1alpha1.Partition"
            }
          },
          "kind": {
            "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
            "type": "string"
          },
          "metadata": {
            "description": "Standard list metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
            "allOf": [
              {
                "$ref": "#/components/schemas/io.k8s.apimachinery.pkg.apis.meta.v1.ListMeta"
              }
            ]
          }
        },
        "x-kubernetes-group-version-kind": [
          {
            "group": "topology.kcp.io",
            "kind": "PartitionList",
            "version": "v1alpha1"
          }
        ]
      },
      "io.kcp.topology.v1alpha1.PartitionSet": {
        "description": "PartitionSet defines a target domain and dimensions to divide a set of shards into 1 or more partitions.",
        "type": "object",
        "required": ["spec"],
        "properties": {
          "apiVersion": {
            "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
            "type": "string"
          },
          "kind": {
            "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
            "type": "string"
          },
          "metadata": {
            "description": "Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata",
            "allOf": [
              {
                "$ref": "#/components/schemas/io.k8s.apimachinery.pkg.apis.meta.v1.ObjectMeta"
              }
            ]
          },
          "spec": {
            "description": "spec holds the desired state.",
            "type": "object",
            "properties": {
              "dimensions": {
                "description": "dimensions (optional) are used to group shards into partitions",
                "type": "array",
                "items": { "type": "string" }
              },
              "shardSelector": {
                "description": "shardSelector (optional) specifies filtering for shard targets.",
                "type": "object",
                "properties": {
                  "matchExpressions": {
                    "description": "matchExpressions is a list of label selector requirements. The requirements are ANDed.",
                    "type": "array",
                    "maxItems": 10,
                    "items": {
                      "description": "A label selector requirement is a selector that contains values, a key, and an operator that\nrelates the key and values.",
                      "type": "object",
                      "required": ["key", "operator"],
                      "properties": {
                        "key": {
                          "description": "key is the label key that the selector applies to.",
                          "type": "string",
                          "maxLength": 317,
                          "x-kubernetes-validations": [
                            {
                              "message": "Label key prefixes are optional and limited to 253 characters. They should match \"^[a-z0-9]([-a-z0-9]{0,251}[a-z0-9])?$\". Names are limited to 63 characters and should match \"^[A-Za-z0-9]([-A-Za-z0-9_.]{0,61}[A-Za-z0-9])?$\". \"/\" is used as separator.",
                              "rule": "self.contains(\"/\") ? self.split(\"/\", 2)[0].matches(\"^[a-z0-9]([-a-z0-9]{0,251}[a-z0-9])?$\") \u0026\u0026 self.split(\"/\", 2)[1].matches(\"^[A-Za-z0-9]([-A-Za-z0-9_.]{0,61}[A-Za-z0-9])?$\") : self.matches(\"^[A-Za-z0-9]([-A-Za-z0-9_.]{0,61}[A-Za-z0-9])?$\")"
                            }
                          ]
                        },
                        "operator": {
                          "description": "operator represents a key's relationship to a set of values.\nValid operators are In, NotIn, Exists and DoesNotExist.",
                          "type": "string",
                          "enum": ["In", "NotIn", "Exists", "DoesNotExist"]
                        },
                        "values": {
                          "description": "values is an array of string values. If the operator is In or NotIn,\nthe values array must be non-empty. If the operator is Exists or DoesNotExist,\nthe values array must be empty. This array is replaced during a strategic\nmerge patch.",
                          "type": "array",
                          "items": {
                            "type": "string",
                            "maxLength": 63,
                            "pattern": "^[A-Za-z0-9]([-A-Za-z0-9_.]{0,61}[A-Za-z0-9])?$"
                          },
                          "x-kubernetes-list-type": "atomic",
                          "x-kubernetes-patch-strategy": "replace"
                        }
                      },
                      "x-kubernetes-validations": [
                        {
                          "message": "There should be at least one value for In and NotIn operators. There should not be any value for Exists and DoesNotExist operators.",
                          "rule": "self.operator in [\"In\", \"NotIn\"] ? size(self.values) \u003e 0 : (self.operator in [\"Exists\", \"DoesNotExist\"] ? !has(self.values) : true)"
                        }
                      ]
                    },
                    "x-kubernetes-list-type": "atomic",
                    "x-kubernetes-patch-strategy": "replace"
                  },
                  "matchLabels": {
                    "description": "matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels\nmap is equivalent to an element of matchExpressions, whose key field is \"key\", the\noperator is \"In\", and the values array contains only \"value\". The requirements are ANDed.",
                    "type": "object",
                    "maxProperties": 10,
                    "additionalProperties": {
                      "type": "string",
                      "maxLength": 380
                    },
                    "x-kubernetes-validations": [
                      {
                        "message": "Label key prefixes are optional and limited to 253 characters. They should match \"^[a-z0-9]([-a-z0-9]{0,251}[a-z0-9])?$\". Names are limited to 63 characters and should match \"^[A-Za-z0-9]([-A-Za-z0-9_.]{0,61}[A-Za-z0-9])?$\". \"/\" is used as separator.",
                        "rule": "self.all(k, k.contains(\"/\") ? k.split(\"/\", 2)[0].matches(\"^[a-z0-9]([-a-z0-9]{0,251}[a-z0-9])?$\") \u0026\u0026 k.split(\"/\", 2)[1].matches(\"^[A-Za-z0-9]([-A-Za-z0-9_.]{0,61}[A-Za-z0-9])?$\") : k.matches(\"^[A-Za-z0-9]([-A-Za-z0-9_.]{0,61}[A-Za-z0-9])?$\"))"
                      },
                      {
                        "message": "Label values are limited to 63 characters and should match \"^[A-Za-z0-9]([-A-Za-z0-9_.]{0,61}[A-Za-z0-9])?$\".",
                        "rule": "self.all(k, self[k].matches(\"^[A-Za-z0-9]([-A-Za-z0-9_.]{0,61}[A-Za-z0-9])?$\"))"
                      }
                    ]
                  }
                },
                "x-kubernetes-map-type": "atomic",
                "x-kubernetes-patch-strategy": "replace"
              }
            }
          },
          "status": {
            "description": "status holds information about the current status",
            "type": "object",
            "properties": {
              "conditions": {
                "description": "conditions is a list of conditions that apply to the APIExportEndpointSlice.",
                "type": "array",
                "items": {
                  "description": "Condition defines an observation of a object operational state.",
                  "type": "object",
                  "required": ["lastTransitionTime", "status", "type"],
                  "properties": {
                    "lastTransitionTime": {
                      "description": "Last time the condition transitioned from one status to another.\nThis should be when the underlying condition changed. If that is not known, then using the time when\nthe API field changed is acceptable.",
                      "type": "string",
                      "format": "date-time"
                    },
                    "message": {
                      "description": "A human readable message indicating details about the transition.\nThis field may be empty.",
                      "type": "string"
                    },
                    "reason": {
                      "description": "The reason for the condition's last transition in CamelCase.\nThe specific API may choose whether or not this field is considered a guaranteed API.\nThis field may not be empty.",
                      "type": "string"
                    },
                    "severity": {
                      "description": "Severity provides an explicit classification of Reason code, so the users or machines can immediately\nunderstand the current situation and act accordingly.\nThe Severity field MUST be set only when Status=False.",
                      "type": "string"
                    },
                    "status": {
                      "description": "Status of the condition, one of True, False, Unknown.",
                      "type": "string"
                    },
                    "type": {
                      "description": "Type of condition in CamelCase or in foo.example.com/CamelCase.\nMany .condition.type values are consistent across resources like Available, but because arbitrary conditions\ncan be useful (see .node.status.conditions), the ability to deconflict is important.",
                      "type": "string"
                    }
                  }
                }
              },
              "count": {
                "description": "count is the total number of partitions.",
                "type": "integer"
              }
            }
          }
        },
        "x-kubernetes-group-version-kind": [
          {
            "group": "topology.kcp.io",
            "kind": "PartitionSet",
            "version": "v1alpha1"
          }
        ]
      },
      "io.kcp.topology.v1alpha1.PartitionSetList": {
        "description": "PartitionSetList is a list of PartitionSet",
        "type": "object",
        "required": ["items"],
        "properties": {
          "apiVersion": {
            "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
            "type": "string"
          },
          "items": {
            "description": "List of partitionsets. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md",
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/io.kcp.topology.v1alpha1.PartitionSet"
            }
          },
          "kind": {
            "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
            "type": "string"
          },
          "metadata": {
            "description": "Standard list metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
            "allOf": [
              {
                "$ref": "#/components/schemas/io.k8s.apimachinery.pkg.apis.meta.v1.ListMeta"
              }
            ]
          }
        },
        "x-kubernetes-group-version-kind": [
          {
            "group": "topology.kcp.io",
            "kind": "PartitionSetList",
            "version": "v1alpha1"
          }
        ]
      }
    }
  }
}
